<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>2014.1_doc: xilflash.c File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>Globals</span></a></li>
  </ul></div>
<h1>xilflash.c File Reference</h1><code>#include &quot;<a class="el" href="xilflash_8h.html">include/xilflash.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xilflash__cfi_8h.html">include/xilflash_cfi.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#610c8f437cec0667b0624295aa4910ed">XFlash_Initialize</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 BaseAddress, u8 BusWidth, int IsPlatformFlash)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#50969bfcb9f81978d00ef46c117a909a">XFlash_Read</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 Offset, u32 Bytes, void *DestPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#565740998b53646a59f7d4938a7fcd02">XFlash_Write</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 Offset, u32 Bytes, void *SrcPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#74526155b23ac3fb515ab7bdd8088f91">XFlash_Erase</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 Offset, u32 Bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#e4afca07edcb164e1ef36ebdb4f54e5f">XFlash_Lock</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 Offset, u32 Bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#d9b92d9197221539a9d88bb9a0519c9e">XFlash_Unlock</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 Offset, u32 Bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#6f68f59948e2627e9da60dcc0fef6512">XFlash_Reset</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#f1dbc1bd39f8af51bc8841edd9e34257">XFlash_DeviceControl</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr, u32 Command, DeviceCtrlParam *Parameters)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#02b6780c6a9e727d666caae54dfe27ba">XFlash_IsReady</a> (<a class="el" href="struct_x_flash_tag.html">XFlash</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#09c3223f6c26afc1bf7f1ecf27de668c">XFlashGeometry_ToAbsolute</a> (<a class="el" href="struct_x_flash_geometry.html">XFlashGeometry</a> *InstancePtr, u16 Region, u16 Block, u32 BlockOffset, u32 *AbsoluteOffsetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xilflash_8c.html#cbc4e37249272e98175cb71a9d1d1d57">XFlashGeometry_ToBlock</a> (<a class="el" href="struct_x_flash_geometry.html">XFlashGeometry</a> *InstancePtr, u32 AbsoluteOffset, u16 *RegionPtr, u16 *BlockPtr, u32 *BlockOffsetPtr)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This file contains the library functions to Initialize, Read, Write, Erase, Lock and Unlock the Parallel Flash Device. The family specific functionalities are implemented in DeviceControl API. Refer <a class="el" href="xilflash_8h.html">xilflash.h</a> for detailed description.<p>
<dl compact><dt><b>Note:</b></dt><dd>None</dd></dl>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a rmm  10/20/07 First release
 1.00a mta  10/25/07 Updated to flash library
 1.01a ksu  04/10/08 Added support for AMD CFI Interface
 1.02a ksu  06/16/09 Added support for multiple banks in Intel flash.
                     Added support for Xilinx Platform Flash XL. If the
                     user selects to use the Xilinx Platfrom Flash XL then
                     it is set to Async mode during the initialization.
                     If the user wants to use it in Sync mode then it can be
                     done using the XFlash_DeviceControl API.
 2.00a ktn  12/04/09 Updated to use the HAL processor APIs/macros.
 3.00a sdm  03/03/11 Removed static parameters in mld and updated code to
		      determine these parameters from the CFI data.
 3.01a srt  03/02/12 Added support for Micron G18 Flash device to fix
		      CRs 648372, 648282.
 3.02a srt  05/30/12 Changed Implementation for Micron G18 Flash, which
		      fixes the CR 662317.
		      CR 662317 Description - Xilinx Platform Flash on ML605
		      fails to work.
 </pre> <hr><h2>Function Documentation</h2>
<a class="anchor" name="f1dbc1bd39f8af51bc8841edd9e34257"></a><!-- doxytag: member="xilflash.c::XFlash_DeviceControl" ref="f1dbc1bd39f8af51bc8841edd9e34257" args="(XFlash *InstancePtr, u32 Command, DeviceCtrlParam *Parameters)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_DeviceControl           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Command</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>DeviceCtrlParam *&nbsp;</td>
          <td class="mdname" nowrap> <em>Parameters</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is used to execute device specific commands. For a list of device specific commands, see the <a class="el" href="xilflash_8h.html">xilflash.h</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Command</em>&nbsp;</td><td>is the device specific command to issue. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Parameters</em>&nbsp;</td><td>specifies the arguments passed to the device control function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_NOT_SUPPORTED if the command is not recognized/supported by the device(s).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="74526155b23ac3fb515ab7bdd8088f91"></a><!-- doxytag: member="xilflash.c::XFlash_Erase" ref="74526155b23ac3fb515ab7bdd8088f91" args="(XFlash *InstancePtr, u32 Offset, u32 Bytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Erase           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Bytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function erases the specified address range in the flash device. The number of bytes to erase can be any number as long as it is within the bounds of the device(s).<p>
The device is polled until an error or the operation completes successfully.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset into the device(s) address space from which to begin erasure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>is the number of bytes to erase.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ADDRESS_ERROR if the destination address range is not completely within the addressable areas of the device(s).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Due to flash memory design, the range actually erased may be larger than what was specified by the Offset &amp; Bytes parameters. This will occur if the parameters do not align to block boundaries. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="610c8f437cec0667b0624295aa4910ed"></a><!-- doxytag: member="xilflash.c::XFlash_Initialize" ref="610c8f437cec0667b0624295aa4910ed" args="(XFlash *InstancePtr, u32 BaseAddress, u8 BusWidth, int IsPlatformFlash)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Initialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>BusWidth</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>IsPlatformFlash</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific XFlash instance. The initialization entails:<ul>
<li>Check the Device family type.</li><li>Issuing the CFI query command.</li><li>Get and translate relevant CFI query information.</li><li>Set default options for the instance.</li><li>Setup the VTable.</li><li>Call the family initialize function of the instance.</li><li>Initialize the Xilinx Platform Flash XL to Async mode if the user selects to use the Platform Flash XL in the MLD. The Platform Flash XL is an Intel CFI complaint device.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the flash memory. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BusWidth</em>&nbsp;</td><td>is the total width of the flash memory, in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsPlatformFlash</em>&nbsp;</td><td>is used to specify if the flash is a platform flash.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_PART_NOT_SUPPORTED if the command set algorithm or Layout is not supported by any flash family compiled into the system.</li><li>XFLASH_CFI_QUERY_ERROR if the device would not enter CFI query mode. Either the device(s) do not support CFI, the wrong BaseAddress param was used, an unsupported part layout exists, or a hardware problem exists with the part.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>BusWidth is not the width of an individual part. Its the total operating width. For example, if there are two 16-bit parts, with one tied to data lines D0-D15 and other tied to D15-D31, BusWidth would be (32 / 8) = 4. If a single 16-bit flash is in 8-bit mode, then BusWidth should be (8 / 8) = 1. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="02b6780c6a9e727d666caae54dfe27ba"></a><!-- doxytag: member="xilflash.c::XFlash_IsReady" ref="02b6780c6a9e727d666caae54dfe27ba" args="(XFlash *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_IsReady           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Checks the readiness of the device, which means it has been successfully initialized.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XFlash instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if the device has been initialized (but not necessarily started), and FALSE otherwise.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e4afca07edcb164e1ef36ebdb4f54e5f"></a><!-- doxytag: member="xilflash.c::XFlash_Lock" ref="e4afca07edcb164e1ef36ebdb4f54e5f" args="(XFlash *InstancePtr, u32 Offset, u32 Bytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Lock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Bytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function Locks the blocks in the specified range of the flash device(s).<p>
The device is polled until an error or the operation completes successfully.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset into the device(s) address space from which to begin block locking. The first three bytes of every block is reserved for special purpose. The offset should be atleast three bytes from start of the block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>indicates the number of bytes to Lock in the Block starting from Offset.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ADDRESS_ERROR if the destination address range is not completely within the addressable areas of the device(s).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Due to flash memory design, the range actually locked may be larger than what was specified by the Offset &amp; Bytes parameters. This will occur if the parameters do not align to block boundaries. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="50969bfcb9f81978d00ef46c117a909a"></a><!-- doxytag: member="xilflash.c::XFlash_Read" ref="50969bfcb9f81978d00ef46c117a909a" args="(XFlash *InstancePtr, u32 Offset, u32 Bytes, void *DestPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Read           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Bytes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>DestPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function reads the data from the Flash device and copies it into the specified user buffer. The source and destination addresses can be on any alignment supported by the processor.<p>
The device is polled until an error or the operation completes successfully.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset into the device(s) address space from which to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>is the number of bytes to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is the destination address to copy data to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ADDRESS_ERROR if the source address does not start within the addressable areas of the device(s).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function allows the transfer of data past the end of the device's address space. If this occurs, then results are undefined. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="6f68f59948e2627e9da60dcc0fef6512"></a><!-- doxytag: member="xilflash.c::XFlash_Reset" ref="6f68f59948e2627e9da60dcc0fef6512" args="(XFlash *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function resets the flash device and places it in read mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_BUSY if the flash devices were in the middle of an operation and could not be reset.</li><li>XFLASH_ERROR if the device(s) have experienced an internal error during the operation. <a class="el" href="xilflash_8h.html#f1dbc1bd39f8af51bc8841edd9e34257">XFlash_DeviceControl()</a> must be used to access the cause of the device specific error. condition.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="d9b92d9197221539a9d88bb9a0519c9e"></a><!-- doxytag: member="xilflash.c::XFlash_Unlock" ref="d9b92d9197221539a9d88bb9a0519c9e" args="(XFlash *InstancePtr, u32 Offset, u32 Bytes)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Unlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Bytes</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function Unlocks the blocks in the specified range of the flash device(s).<p>
The device is polled until an error or the operation completes successfully.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset into the device(s) address space from which to begin block UnLocking. The first three bytes of every block is reserved for special purpose. The offset should be atleast three bytes from start of the block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>indicates the number of bytes to UnLock in the Block starting from Offset.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ADDRESS_ERROR if the destination address range is not completely within the addressable areas of the device(s).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="565740998b53646a59f7d4938a7fcd02"></a><!-- doxytag: member="xilflash.c::XFlash_Write" ref="565740998b53646a59f7d4938a7fcd02" args="(XFlash *InstancePtr, u32 Offset, u32 Bytes, void *SrcPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlash_Write           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_tag.html">XFlash</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Bytes</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>SrcPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function programs the flash device(s) with data specified in the user buffer. The source and destination address must be aligned to the width of the flash's data bus.<p>
The device is polled until an error or the operation completes successfully.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset into the device(s) address space from which to begin programming. Must be aligned to the width of the flash's data bus. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>is the number of bytes to program. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is the source address containing data to be programmed. Must be aligned to the width of the flash's data bus. The SrcPtr doesn't have to be aligned to the flash width if the processor supports unaligned access. But, since this library is generic, and some processors (eg. Microblaze) do not support unaligned access; this API requires the SrcPtr to be aligned.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ERROR if a write error occurred. This error is usually device specific. Use <a class="el" href="xilflash_8h.html#f1dbc1bd39f8af51bc8841edd9e34257">XFlash_DeviceControl()</a> to retrieve specific error conditions. When this error is returned, it is possible that the target address range was only partially programmed.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="09c3223f6c26afc1bf7f1ecf27de668c"></a><!-- doxytag: member="xilflash.c::XFlashGeometry_ToAbsolute" ref="09c3223f6c26afc1bf7f1ecf27de668c" args="(XFlashGeometry *InstancePtr, u16 Region, u16 Block, u32 BlockOffset, u32 *AbsoluteOffsetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlashGeometry_ToAbsolute           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_geometry.html">XFlashGeometry</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>Region</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>Block</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>BlockOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>AbsoluteOffsetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts block coordinates to a part offset. Region, Block, &amp; BlockOffset are converted to PartOffset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XFlash instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Region</em>&nbsp;</td><td>is the erase region the physical address appears in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Block</em>&nbsp;</td><td>is the block within Region the physical address appears in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockOffset</em>&nbsp;</td><td>is the offset within Block where the physical address appears. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AbsoluteOffsetPtr</em>&nbsp;</td><td>is the returned offset value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ADDRESS_ERROR if the block coordinates are invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="cbc4e37249272e98175cb71a9d1d1d57"></a><!-- doxytag: member="xilflash.c::XFlashGeometry_ToBlock" ref="cbc4e37249272e98175cb71a9d1d1d57" args="(XFlashGeometry *InstancePtr, u32 AbsoluteOffset, u16 *RegionPtr, u16 *BlockPtr, u32 *BlockOffsetPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XFlashGeometry_ToBlock           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_flash_geometry.html">XFlashGeometry</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>AbsoluteOffset</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>RegionPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BlockPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32 *&nbsp;</td>
          <td class="mdname" nowrap> <em>BlockOffsetPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts part offset block coordinates. PartOffset is converted to Region, Block &amp; BlockOffset<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the <a class="el" href="struct_x_flash_geometry.html">XFlashGeometry</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AbsoluteOffset</em>&nbsp;</td><td>is the offset within part to find block coordinates for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegionPtr</em>&nbsp;</td><td>is the region that corresponds to AbsoluteOffset. This is a return parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockPtr</em>&nbsp;</td><td>is the block within Region that corresponds to AbsoluteOffset. This is a return parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockOffsetPtr</em>&nbsp;</td><td>is the offset within Block that corresponds to AbsoluteOffset. This is a return parameter.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XFLASH_ADDRESS_ERROR if the block coordinates are invalid.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Thu Feb 13 14:37:13 2014 for 2014.1_doc by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.5 </small></address>
</body>
</html>
