<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver nandps v2_1: xnandps.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xnandps.c File Reference</h1><code>#include &quot;<a class="el" href="xnandps_8h.html">xnandps.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xnandps__bbm_8h.html">xnandps_bbm.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xnandps__onfi_8h.html">xnandps_onfi.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#ae2862ccd7e9180b843d9e73e2a8c7e7b">XNandPs_SendCommand</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, <a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a> *Command, int Page, int Column)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a92acb0aedbfa7e76759062d70a2c4a67">XNandPs_InitBbtDesc</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a454c0738c0ffe28c49ba8fced47e8d9c">XNandPs_ScanBbt</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a7f3a46694f4b3c4baffca71e6fcfebab">Onfi_CmdReadStatus</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#acb42515d1fa541b8ac5e785d1fb7eefd">Onfi_NandInit</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#addb9f847fae34f6d137f591375a7c962">XNandPs_CfgInitialize</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, <a class="el" href="struct_x_nand_ps___config.html">XNandPs_Config</a> *ConfigPtr, u32 SmcBaseAddr, u32 FlashBaseAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a8e72425d265074f1c2f8c66edfd22857">XNandPs_Read</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a605bd783f065806f1d1f602f88128f9b">XNandPs_ReadCache</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#aebab330d0fd9efef74c26a50b5829d9f">XNandPs_Write</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a8ecd5bb0fc73b3011ee0ba500e0161fe">XNandPs_WriteCache</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#af9857df5e1359875e429f66e46ca5a86">XNandPs_ReadSpareBytes</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u32 Page, u8 *Buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#aa987d756af43c965a6439f077a4ce158">XNandPs_WriteSpareBytes</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u32 Page, u8 *Buf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a22b4e2bc1af7e4bfecd4428c25a77bb8">XNandPs_EraseBlock</a> (<a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *InstancePtr, u32 BlockNum)</td></tr>
<tr><td colspan="2"><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#ae980af68044391bcf0c94bd2b35c910b">NandOob16</a> [] = {13, 14, 15}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#ad8d144dd94afdb026486d7b34e6c58f1">NandOob32</a> [] = {26, 27, 28, 29, 30, 31}</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#aed173a3e7bda0d3a84e8f7d55aa4e81d">NandOob64</a> []</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xnandps_8c.html#a6256f01deb0ca40af90a3b6ceb0aef94">OnfiCommands</a> []</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file contains the implementation of the interface functions for XNandPs driver. Refer to the header file <a class="el" href="xnandps_8h.html">xnandps.h</a> for more detailed information.</p>
<p>This module supports for NAND flash memory devices that conform to the "Open NAND Flash Interface" (ONFI) Specification. This modules implements basic flash operations like read, write and erase.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None</dd></dl>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who    Date    	   Changes
 ----- ----   ----------  -----------------------------------------------
 1.00a nm     12/10/2010  First release
 1.01a nm     28/02/2012  Fixed 16-bit issue with ONFI commands like
                          read, write and read status command. The config
                          structure width is updated after ONFI query
                          with the parameter page width.
 1.02a nm     20/09/2012  Removed setting of set_cycles and set_opmode
                          register values as it is now done in FSBL using
                          the PCW generated files. CR#678949.
 1.03a nm     10/22/2012  Fixed CR# 673348.
 1.04a nm     04/15/2013  Fixed CR# 704401. Removed warnings when compiled
 			   with -Wall and -Wextra option in bsp.
	       04/25/2013  Implemented PR# 699544. Added page cache read
			   and program support. Added API's XNandPs_ReadCache
			   and XNandPs_WriteCache for page cache support.
			   Added ECC handling functions XNandPs_EccSetCfg,
			   XNandPs_EccSetMemCmd1...etc, to support better 
			   usage of ECC block for page cache commands.
			   Modified Read/Write API's so that there is common
			   code for normal read/write and page cache commands.
			   Disabling/Re-enabling ECC block in read/write API's
			   of spare bytes since we don't calculate ECC for
			   spare bytes.
 2.01 kpc    07/24/2014   Fixed CR#808770. Update command register twice only
                           if flash device requires &gt;= four address cycles.
 </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a7f3a46694f4b3c4baffca71e6fcfebab"></a><!-- doxytag: member="xnandps.c::Onfi_CmdReadStatus" ref="a7f3a46694f4b3c4baffca71e6fcfebab" args="(XNandPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 Onfi_CmdReadStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends read status command to the flash device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>flash status value read</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="acb42515d1fa541b8ac5e785d1fb7eefd"></a><!-- doxytag: member="xnandps.c::Onfi_NandInit" ref="acb42515d1fa541b8ac5e785d1fb7eefd" args="(XNandPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Onfi_NandInit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes the NAND flash and gets the geometry information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if failed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="addb9f847fae34f6d137f591375a7c962"></a><!-- doxytag: member="xnandps.c::XNandPs_CfgInitialize" ref="addb9f847fae34f6d137f591375a7c962" args="(XNandPs *InstancePtr, XNandPs_Config *ConfigPtr, u32 SmcBaseAddr, u32 FlashBaseAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps___config.html">XNandPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SmcBaseAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>FlashBaseAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes a specific XNandPs device/instance. This function must be called prior to using the flash device to read or write any data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>points to the XNandPs device configuration structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SmcBaseAddr</em>&nbsp;</td><td>is the base address of SMC controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FlashBaseAddr</em>&nbsp;</td><td>is the base address of NAND flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The user needs to first call the <a class="el" href="xnandps_8h.html#a0eb3e99243066b9145f3c437081988b5">XNandPs_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xnandps_8c.html#addb9f847fae34f6d137f591375a7c962">XNandPs_CfgInitialize()</a> API. </dd></dl>

</div>
</div>
<a class="anchor" id="a22b4e2bc1af7e4bfecd4428c25a77bb8"></a><!-- doxytag: member="xnandps.c::XNandPs_EraseBlock" ref="a22b4e2bc1af7e4bfecd4428c25a77bb8" args="(XNandPs *InstancePtr, u32 BlockNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_EraseBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BlockNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function erases a specific block in the NAND device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockNum</em>&nbsp;</td><td>is the block number of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
<li>XST_NAND_WRITE_PROTECTED if the flash is write protected.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a92acb0aedbfa7e76759062d70a2c4a67"></a><!-- doxytag: member="xnandps.c::XNandPs_InitBbtDesc" ref="a92acb0aedbfa7e76759062d70a2c4a67" args="(XNandPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XNandPs_InitBbtDesc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes the Bad Block Table(BBT) descriptors with a predefined pattern for searching Bad Block Table(BBT) in flash.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>NONE </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a8e72425d265074f1c2f8c66edfd22857"></a><!-- doxytag: member="xnandps.c::XNandPs_Read" ref="a8e72425d265074f1c2f8c66edfd22857" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>UserSparePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the data from the Flash device and copies it into the specified user buffer. It doesn't check for the bad blocks while reading the flash pages that cross block boundary. User must take care of handling bad blocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is the destination address to copy data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer to which spare data must be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function reads sequential pages from the Flash device. </dd></dl>

</div>
</div>
<a class="anchor" id="a605bd783f065806f1d1f602f88128f9b"></a><!-- doxytag: member="xnandps.c::XNandPs_ReadCache" ref="a605bd783f065806f1d1f602f88128f9b" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *DestPtr, u8 *UserSparePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_ReadCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>UserSparePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the data from the Flash device using read page cache command and copies it into the specified user buffer. It doesn't check for the bad blocks while reading the flash pages that cross block boundary. User must take care of handling bad blocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>is the destination address to copy data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer to which spare data must be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function reads sequential pages from the Flash device. </dd></dl>

</div>
</div>
<a class="anchor" id="af9857df5e1359875e429f66e46ca5a86"></a><!-- doxytag: member="xnandps.c::XNandPs_ReadSpareBytes" ref="af9857df5e1359875e429f66e46ca5a86" args="(XNandPs *InstancePtr, u32 Page, u8 *Buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_ReadSpareBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the spare area of a page.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Page</em>&nbsp;</td><td>is the page number from where spare data is read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buf</em>&nbsp;</td><td>is pointer to the buffer where the spare data is filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a454c0738c0ffe28c49ba8fced47e8d9c"></a><!-- doxytag: member="xnandps.c::XNandPs_ScanBbt" ref="a454c0738c0ffe28c49ba8fced47e8d9c" args="(XNandPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_ScanBbt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the Bad Block Table(BBT) if present in flash. If not it scans the flash for detecting factory marked bad blocks and creates a bad block table and write the Bad Block Table(BBT) into the flash.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XNandPs instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae2862ccd7e9180b843d9e73e2a8c7e7b"></a><!-- doxytag: member="xnandps.c::XNandPs_SendCommand" ref="ae2862ccd7e9180b843d9e73e2a8c7e7b" args="(XNandPs *InstancePtr, XNandPs_CommandFormat *Command, int Page, int Column)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XNandPs_SendCommand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a> *&nbsp;</td>
          <td class="paramname"> <em>Command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Column</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a NAND command to the flash device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to XNandPs struture </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Command</em>&nbsp;</td><td>is the NAND command to send </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Page</em>&nbsp;</td><td>is the page offset required for specific commands </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Column</em>&nbsp;</td><td>the column offset required for specific commands</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aebab330d0fd9efef74c26a50b5829d9f"></a><!-- doxytag: member="xnandps.c::XNandPs_Write" ref="aebab330d0fd9efef74c26a50b5829d9f" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>SrcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>UserSparePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function programs the flash device(s) with data specified in the user buffer. The source and destination address must be aligned to the width of the flash's data bus. It doesn't check for the bad blocks while writing to the flash pages that cross block boundary. User must take care of handling bad blocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is the source address to write the data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer which contains buffer to write into spare data area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
<li>XST_NAND_WRITE_PROTECTED if the flash is write protected.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function writes number of sequential pages into the Flash device. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ecd5bb0fc73b3011ee0ba500e0161fe"></a><!-- doxytag: member="xnandps.c::XNandPs_WriteCache" ref="a8ecd5bb0fc73b3011ee0ba500e0161fe" args="(XNandPs *InstancePtr, u64 Offset, u32 Length, void *SrcPtr, u8 *UserSparePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_WriteCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>SrcPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>UserSparePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function programs the flash device(s) with data specified in the user buffer using program cache command. The source and destination address must be aligned to the width of the flash's data bus. It doesn't check for the bad blocks while writing to the flash pages that cross block boundary. User must take care of handling bad blocks.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the flash data address to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcPtr</em>&nbsp;</td><td>is the source address to write the data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserSparePtr</em>&nbsp;</td><td>is the user buffer which contains buffer to write into spare data area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
<li>XST_NAND_WRITE_PROTECTED if the flash is write protected.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function writes number of sequential pages into the Flash device. </dd></dl>

</div>
</div>
<a class="anchor" id="aa987d756af43c965a6439f077a4ce158"></a><!-- doxytag: member="xnandps.c::XNandPs_WriteSpareBytes" ref="aa987d756af43c965a6439f077a4ce158" args="(XNandPs *InstancePtr, u32 Page, u8 *Buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XNandPs_WriteSpareBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_nand_ps_tag.html">XNandPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function write to the spare area of a page.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the XNandPs instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Page</em>&nbsp;</td><td>is the page number to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Buf</em>&nbsp;</td><td>is pointer to the buffer which holds the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if fail.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ae980af68044391bcf0c94bd2b35c910b"></a><!-- doxytag: member="xnandps.c::NandOob16" ref="ae980af68044391bcf0c94bd2b35c910b" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 <a class="el" href="xnandps_8c.html#ae980af68044391bcf0c94bd2b35c910b">NandOob16</a>[] = {13, 14, 15}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ecc position for 16 bytes spare area </p>

</div>
</div>
<a class="anchor" id="ad8d144dd94afdb026486d7b34e6c58f1"></a><!-- doxytag: member="xnandps.c::NandOob32" ref="ad8d144dd94afdb026486d7b34e6c58f1" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 <a class="el" href="xnandps_8c.html#ad8d144dd94afdb026486d7b34e6c58f1">NandOob32</a>[] = {26, 27, 28, 29, 30, 31}</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ecc position for 32 bytes spare area </p>

</div>
</div>
<a class="anchor" id="aed173a3e7bda0d3a84e8f7d55aa4e81d"></a><!-- doxytag: member="xnandps.c::NandOob64" ref="aed173a3e7bda0d3a84e8f7d55aa4e81d" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 <a class="el" href="xnandps_8c.html#aed173a3e7bda0d3a84e8f7d55aa4e81d">NandOob64</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {52, 53, 54, 55, 56, 57,
                   58, 59, 60, 61, 62, 63}
</pre></div><p>Ecc position for 64 bytes spare area </p>

</div>
</div>
<a class="anchor" id="a6256f01deb0ca40af90a3b6ceb0aef94"></a><!-- doxytag: member="xnandps.c::OnfiCommands" ref="a6256f01deb0ca40af90a3b6ceb0aef94" args="[]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_nand_ps___command_format.html">XNandPs_CommandFormat</a> <a class="el" href="xnandps__onfi_8c.html#a6256f01deb0ca40af90a3b6ceb0aef94">OnfiCommands</a>[]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ONFI commands</p>
<p>This structure defines the onfi command format sent to the flash. </p>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

