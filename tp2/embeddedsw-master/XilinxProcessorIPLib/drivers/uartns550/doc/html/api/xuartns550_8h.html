<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver uartns550 v3_1: xuartns550.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xuartns550.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xuartns550__l_8h.html">xuartns550_l.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_ns550___config.html">XUartNs550_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_ns550_buffer.html">XUartNs550Buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_ns550_format.html">XUartNs550Format</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_ns550_stats.html">XUartNs550Stats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#aed2b98e35e479c8f7e57f260ee5b4be3">XUARTNS550_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a0d0b450ce409b77274109a7610a9d4a9">XUN_NS16550_MAX_RATE</a>&nbsp;&nbsp;&nbsp;115200</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ad953e8f3c273533ab5613314fb3344b6">XUN_NS16550_MIN_RATE</a>&nbsp;&nbsp;&nbsp;300</td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a08a745fcffbdb351b5bac16197578eba">XUN_OPTION_RXLINE_INTR</a>&nbsp;&nbsp;&nbsp;0x0800</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a2b69543bcd3d4e794193b9b47da1bcce">XUN_OPTION_SET_BREAK</a>&nbsp;&nbsp;&nbsp;0x0400</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#aaf47eddf3f91b4dfea5fa70849ccf094">XUN_OPTION_LOOPBACK</a>&nbsp;&nbsp;&nbsp;0x0200</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a616329329f125e69b957d98d23c0c80d">XUN_OPTION_DATA_INTR</a>&nbsp;&nbsp;&nbsp;0x0100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#adcf53248ec112623a28737a2e584683d">XUN_OPTION_MODEM_INTR</a>&nbsp;&nbsp;&nbsp;0x0080</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a9bd45da1706d1d6cfc0f22d4fca46100">XUN_OPTION_FIFOS_ENABLE</a>&nbsp;&nbsp;&nbsp;0x0040</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a1cbbc5bddc953994ea0cb2366e3e5d60">XUN_OPTION_RESET_TX_FIFO</a>&nbsp;&nbsp;&nbsp;0x0020</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a7aa1ecea52619ad2676a6d4ac3beb759">XUN_OPTION_RESET_RX_FIFO</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a98ca88cd5c9a0dbbb44ab7feee22e1ea">XUN_OPTION_ASSERT_OUT2</a>&nbsp;&nbsp;&nbsp;0x0008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#adfd56895540a03acdc510be3df5d2af2">XUN_OPTION_ASSERT_OUT1</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a0b4be9e79ab42ff65c9ccbccfd53d1e8">XUN_OPTION_ASSERT_RTS</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a98413720ccbd9c0e7a47468885d894a8">XUN_OPTION_ASSERT_DTR</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td colspan="2"><div class="groupHeader">Data format values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp561393cbc57b8d06fe9ef22b8e254efb"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a7d074166a6d63f05a7f5b4d8600eef81">XUN_FORMAT_8_BITS</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a42ab3cfade8f43ee12f04f111c336ddc">XUN_FORMAT_7_BITS</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a88d0995c5946998d12141d57a1f42a11">XUN_FORMAT_6_BITS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a5ab6a6a6c4ba6f74203012cb83a2d7f8">XUN_FORMAT_5_BITS</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a3ceb996b058ef788676793d1da22b4fd">XUN_FORMAT_EVEN_PARITY</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ae820f584c1473ec1fcb8dcab5ff53752">XUN_FORMAT_ODD_PARITY</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a12c4007e0384a40140cff2ccd42d20d6">XUN_FORMAT_NO_PARITY</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a87a29bbab99baca04a1b2f860000f45d">XUN_FORMAT_2_STOP_BIT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#adde11ab1bed0554bf6863a425a9b6883">XUN_FORMAT_1_STOP_BIT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td colspan="2"><div class="groupHeader">FIFO trigger values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7f9997554f126f65df81d8456926ac38"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#aa456eb0224a4c1d84177c39e3514d446">XUN_FIFO_TRIGGER_14</a>&nbsp;&nbsp;&nbsp;0xC0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ab3a4c3dc39b03ebc237b78d99980ee53">XUN_FIFO_TRIGGER_08</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a098110c073d9bb2840174ec3bfd2d974">XUN_FIFO_TRIGGER_04</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a53fffaa233387f3bdc9f8524f4c0498f">XUN_FIFO_TRIGGER_01</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modem status values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7afef14bef286f3f1a476f52a1f97360"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ab901a667c0092c479c5d9010ed7502d2">XUN_MODEM_DCD_DELTA_MASK</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a82340069f99a118706aba7e7fb151dd4">XUN_MODEM_DSR_DELTA_MASK</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ae5813f86719707f5c77073752c691eec">XUN_MODEM_CTS_DELTA_MASK</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a04af798da0a7441edba3f2422311b407">XUN_MODEM_RINGING_MASK</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a1aeb58a464b66388317130cd8494d270">XUN_MODEM_DSR_MASK</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#abc81d97fc18bf0eb131fb8072c3cfc0e">XUN_MODEM_CTS_MASK</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a8e16fdbc7a9cfe0a278223cae7ea337a">XUN_MODEM_DCD_MASK</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#acf0b84214ccac5dc53ad63bfee0b2af1">XUN_MODEM_RING_STOP_MASK</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td colspan="2"><div class="groupHeader">Callback events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc478b096d0c15f7e00fb1b0587e19c87"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#abc9845fc2ec5078c1beea2b1e1f8458c">XUN_EVENT_RECV_DATA</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#adcf08384f79c532d7476ef470eeef32a">XUN_EVENT_RECV_TIMEOUT</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a935c9a27e790c469337b884f42db9266">XUN_EVENT_SENT_DATA</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a658d137ce80d2dba58593fdc9266eded">XUN_EVENT_RECV_ERROR</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ae10be1699ad350ccd9290a85e9d07832">XUN_EVENT_MODEM</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td colspan="2"><div class="groupHeader">Error values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp7a787613b99a96c2fb251cd80f992d14"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a30f8d32289eefb7b8f4144e702da0248">XUN_ERROR_BREAK_MASK</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a34ea957b9587fc0a2571be9d0816e994">XUN_ERROR_FRAMING_MASK</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#aaeba54cf3dd6a4113dbcea2c02acdfcf">XUN_ERROR_PARITY_MASK</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a87c3d1d1c50213ac56e0c60f544761e2">XUN_ERROR_OVERRUN_MASK</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a9f68b9cbaa34388aab27c289db3e390a">XUN_ERROR_NONE</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ae4e97640db5af678d474f3398045d64a">XUartNs550_Handler</a> )(void *CallBackRef, u32 Event, unsigned int EventData)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a97009bf7b2508c14225b0d5835c256d0">XUartNs550_Initialize</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_uart_ns550___config.html">XUartNs550_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#afd48f9c9264de4bbfa4ff387a9a4c057">XUartNs550_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a37a67d6e3901ba6bee3df7c51dab093b">XUartNs550_CfgInitialize</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, <a class="el" href="struct_x_uart_ns550___config.html">XUartNs550_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a421921af6a8df7c51ddbfa5d2301ad1b">XUartNs550_Send</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, u8 *BufferPtr, unsigned int NumBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a35fc171801e394fce29cbcb09dc1ff99">XUartNs550_Recv</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, u8 *BufferPtr, unsigned int NumBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ac2270082fbb7d7b2c32bd9208dae5be3">XUartNs550_SetOptions</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, u16 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a120797e7b4fc719c827c4378e387efe4">XUartNs550_GetOptions</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#aedd1056b9f1283ee15c1a3c349acb845">XUartNs550_SetFifoThreshold</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, u8 TriggerLevel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a4f7c185a91f28f3490fa8ef71dab1059">XUartNs550_GetFifoThreshold</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#aab822fbaed4a57714779e35b6be6f090">XUartNs550_IsSending</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ab5c78c74113daef4f74aefbc57e92b3a">XUartNs550_GetLastErrors</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a541b6125f67b83adfe5f508215d59ea6">XUartNs550_GetModemStatus</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a96a10aab5e44709b76eda319fce4b6dd">XUartNs550_SetDataFormat</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, <a class="el" href="struct_x_uart_ns550_format.html">XUartNs550Format</a> *Format)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a0b26f08e464f42a10a7eda114e101e64">XUartNs550_GetDataFormat</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, <a class="el" href="struct_x_uart_ns550_format.html">XUartNs550Format</a> *Format)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#adf7c4826f92d5e8fd70763f4448a360d">XUartNs550_SetHandler</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, <a class="el" href="xuartns550_8h.html#ae4e97640db5af678d474f3398045d64a">XUartNs550_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a6e8579fcf317e1f30d61b4fb7fe60434">XUartNs550_InterruptHandler</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#ad859e54c9baab85a7dd46b6851384ff6">XUartNs550_GetStats</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr, <a class="el" href="struct_x_uart_ns550_stats.html">XUartNs550Stats</a> *StatsPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a67e2cea916214f246e449b8438d01384">XUartNs550_ClearStats</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xuartns550_8h.html#a2ec86252a3b83b8d7b4815ffb960562d">XUartNs550_SelfTest</a> (<a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aed2b98e35e479c8f7e57f260ee5b4be3"></a><!-- doxytag: member="xuartns550.h::XUARTNS550_H" ref="aed2b98e35e479c8f7e57f260ee5b4be3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUARTNS550_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a30f8d32289eefb7b8f4144e702da0248"></a><!-- doxytag: member="xuartns550.h::XUN_ERROR_BREAK_MASK" ref="a30f8d32289eefb7b8f4144e702da0248" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_ERROR_BREAK_MASK&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants specify the errors that may be retrieved from the driver using the XUartNs550_GetLastErrors function. All of them are bit masks, except no error, such that multiple errors may be specified. Break detected </p>

</div>
</div>
<a class="anchor" id="a34ea957b9587fc0a2571be9d0816e994"></a><!-- doxytag: member="xuartns550.h::XUN_ERROR_FRAMING_MASK" ref="a34ea957b9587fc0a2571be9d0816e994" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_ERROR_FRAMING_MASK&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive framing error </p>

</div>
</div>
<a class="anchor" id="a9f68b9cbaa34388aab27c289db3e390a"></a><!-- doxytag: member="xuartns550.h::XUN_ERROR_NONE" ref="a9f68b9cbaa34388aab27c289db3e390a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_ERROR_NONE&nbsp;&nbsp;&nbsp;0x00</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No error </p>

</div>
</div>
<a class="anchor" id="a87c3d1d1c50213ac56e0c60f544761e2"></a><!-- doxytag: member="xuartns550.h::XUN_ERROR_OVERRUN_MASK" ref="a87c3d1d1c50213ac56e0c60f544761e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_ERROR_OVERRUN_MASK&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive overrun error </p>

</div>
</div>
<a class="anchor" id="aaeba54cf3dd6a4113dbcea2c02acdfcf"></a><!-- doxytag: member="xuartns550.h::XUN_ERROR_PARITY_MASK" ref="aaeba54cf3dd6a4113dbcea2c02acdfcf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_ERROR_PARITY_MASK&nbsp;&nbsp;&nbsp;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive parity error </p>

</div>
</div>
<a class="anchor" id="ae10be1699ad350ccd9290a85e9d07832"></a><!-- doxytag: member="xuartns550.h::XUN_EVENT_MODEM" ref="ae10be1699ad350ccd9290a85e9d07832" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_EVENT_MODEM&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A change in modem status </p>

</div>
</div>
<a class="anchor" id="abc9845fc2ec5078c1beea2b1e1f8458c"></a><!-- doxytag: member="xuartns550.h::XUN_EVENT_RECV_DATA" ref="abc9845fc2ec5078c1beea2b1e1f8458c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_EVENT_RECV_DATA&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants specify the handler events that are passed to a handler from the driver. These constants are not bit masks such that only one will be passed at a time to the handler. Data has been received </p>

</div>
</div>
<a class="anchor" id="a658d137ce80d2dba58593fdc9266eded"></a><!-- doxytag: member="xuartns550.h::XUN_EVENT_RECV_ERROR" ref="a658d137ce80d2dba58593fdc9266eded" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_EVENT_RECV_ERROR&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A receive error was detected </p>

</div>
</div>
<a class="anchor" id="adcf08384f79c532d7476ef470eeef32a"></a><!-- doxytag: member="xuartns550.h::XUN_EVENT_RECV_TIMEOUT" ref="adcf08384f79c532d7476ef470eeef32a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_EVENT_RECV_TIMEOUT&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A receive timeout occurred </p>

</div>
</div>
<a class="anchor" id="a935c9a27e790c469337b884f42db9266"></a><!-- doxytag: member="xuartns550.h::XUN_EVENT_SENT_DATA" ref="a935c9a27e790c469337b884f42db9266" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_EVENT_SENT_DATA&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data has been sent </p>

</div>
</div>
<a class="anchor" id="a53fffaa233387f3bdc9f8524f4c0498f"></a><!-- doxytag: member="xuartns550.h::XUN_FIFO_TRIGGER_01" ref="a53fffaa233387f3bdc9f8524f4c0498f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FIFO_TRIGGER_01&nbsp;&nbsp;&nbsp;0x00</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>1 byte trigger level </p>

</div>
</div>
<a class="anchor" id="a098110c073d9bb2840174ec3bfd2d974"></a><!-- doxytag: member="xuartns550.h::XUN_FIFO_TRIGGER_04" ref="a098110c073d9bb2840174ec3bfd2d974" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FIFO_TRIGGER_04&nbsp;&nbsp;&nbsp;0x40</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>4 byte trigger level </p>

</div>
</div>
<a class="anchor" id="ab3a4c3dc39b03ebc237b78d99980ee53"></a><!-- doxytag: member="xuartns550.h::XUN_FIFO_TRIGGER_08" ref="ab3a4c3dc39b03ebc237b78d99980ee53" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FIFO_TRIGGER_08&nbsp;&nbsp;&nbsp;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>8 byte trigger level </p>

</div>
</div>
<a class="anchor" id="aa456eb0224a4c1d84177c39e3514d446"></a><!-- doxytag: member="xuartns550.h::XUN_FIFO_TRIGGER_14" ref="aa456eb0224a4c1d84177c39e3514d446" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FIFO_TRIGGER_14&nbsp;&nbsp;&nbsp;0xC0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>14 byte trigger level </p>

</div>
</div>
<a class="anchor" id="adde11ab1bed0554bf6863a425a9b6883"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_1_STOP_BIT" ref="adde11ab1bed0554bf6863a425a9b6883" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_1_STOP_BIT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>1 stop bit </p>

</div>
</div>
<a class="anchor" id="a87a29bbab99baca04a1b2f860000f45d"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_2_STOP_BIT" ref="a87a29bbab99baca04a1b2f860000f45d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_2_STOP_BIT&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>2 stop bits </p>

</div>
</div>
<a class="anchor" id="a5ab6a6a6c4ba6f74203012cb83a2d7f8"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_5_BITS" ref="a5ab6a6a6c4ba6f74203012cb83a2d7f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_5_BITS&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>5 data bits </p>

</div>
</div>
<a class="anchor" id="a88d0995c5946998d12141d57a1f42a11"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_6_BITS" ref="a88d0995c5946998d12141d57a1f42a11" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_6_BITS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>6 data bits </p>

</div>
</div>
<a class="anchor" id="a42ab3cfade8f43ee12f04f111c336ddc"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_7_BITS" ref="a42ab3cfade8f43ee12f04f111c336ddc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_7_BITS&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>7 data bits </p>

</div>
</div>
<a class="anchor" id="a7d074166a6d63f05a7f5b4d8600eef81"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_8_BITS" ref="a7d074166a6d63f05a7f5b4d8600eef81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_8_BITS&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants specify the data format that may be set or retrieved with the driver. The data format includes the number of data bits, the number of stop bits and parity. 8 data bits </p>

</div>
</div>
<a class="anchor" id="a3ceb996b058ef788676793d1da22b4fd"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_EVEN_PARITY" ref="a3ceb996b058ef788676793d1da22b4fd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_EVEN_PARITY&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Even Parity </p>

</div>
</div>
<a class="anchor" id="a12c4007e0384a40140cff2ccd42d20d6"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_NO_PARITY" ref="a12c4007e0384a40140cff2ccd42d20d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_NO_PARITY&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No Parity </p>

</div>
</div>
<a class="anchor" id="ae820f584c1473ec1fcb8dcab5ff53752"></a><!-- doxytag: member="xuartns550.h::XUN_FORMAT_ODD_PARITY" ref="ae820f584c1473ec1fcb8dcab5ff53752" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_FORMAT_ODD_PARITY&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Odd Parity </p>

</div>
</div>
<a class="anchor" id="ae5813f86719707f5c77073752c691eec"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_CTS_DELTA_MASK" ref="ae5813f86719707f5c77073752c691eec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_CTS_DELTA_MASK&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>CTS signal changed state </p>

</div>
</div>
<a class="anchor" id="abc81d97fc18bf0eb131fb8072c3cfc0e"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_CTS_MASK" ref="abc81d97fc18bf0eb131fb8072c3cfc0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_CTS_MASK&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current state of CTS signal </p>

</div>
</div>
<a class="anchor" id="ab901a667c0092c479c5d9010ed7502d2"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_DCD_DELTA_MASK" ref="ab901a667c0092c479c5d9010ed7502d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_DCD_DELTA_MASK&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants specify the modem status that may be retrieved from the driver. DCD signal changed state </p>

</div>
</div>
<a class="anchor" id="a8e16fdbc7a9cfe0a278223cae7ea337a"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_DCD_MASK" ref="a8e16fdbc7a9cfe0a278223cae7ea337a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_DCD_MASK&nbsp;&nbsp;&nbsp;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current state of DCD signal </p>

</div>
</div>
<a class="anchor" id="a82340069f99a118706aba7e7fb151dd4"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_DSR_DELTA_MASK" ref="a82340069f99a118706aba7e7fb151dd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_DSR_DELTA_MASK&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DSR signal changed state </p>

</div>
</div>
<a class="anchor" id="a1aeb58a464b66388317130cd8494d270"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_DSR_MASK" ref="a1aeb58a464b66388317130cd8494d270" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_DSR_MASK&nbsp;&nbsp;&nbsp;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current state of DSR signal </p>

</div>
</div>
<a class="anchor" id="acf0b84214ccac5dc53ad63bfee0b2af1"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_RING_STOP_MASK" ref="acf0b84214ccac5dc53ad63bfee0b2af1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_RING_STOP_MASK&nbsp;&nbsp;&nbsp;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ringing has stopped </p>

</div>
</div>
<a class="anchor" id="a04af798da0a7441edba3f2422311b407"></a><!-- doxytag: member="xuartns550.h::XUN_MODEM_RINGING_MASK" ref="a04af798da0a7441edba3f2422311b407" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_MODEM_RINGING_MASK&nbsp;&nbsp;&nbsp;0x40</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Ring signal is active </p>

</div>
</div>
<a class="anchor" id="a0d0b450ce409b77274109a7610a9d4a9"></a><!-- doxytag: member="xuartns550.h::XUN_NS16550_MAX_RATE" ref="a0d0b450ce409b77274109a7610a9d4a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_NS16550_MAX_RATE&nbsp;&nbsp;&nbsp;115200</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad953e8f3c273533ab5613314fb3344b6"></a><!-- doxytag: member="xuartns550.h::XUN_NS16550_MIN_RATE" ref="ad953e8f3c273533ab5613314fb3344b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_NS16550_MIN_RATE&nbsp;&nbsp;&nbsp;300</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a98413720ccbd9c0e7a47468885d894a8"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_ASSERT_DTR" ref="a98413720ccbd9c0e7a47468885d894a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_ASSERT_DTR&nbsp;&nbsp;&nbsp;0x0001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assert DTR signal </p>

</div>
</div>
<a class="anchor" id="adfd56895540a03acdc510be3df5d2af2"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_ASSERT_OUT1" ref="adfd56895540a03acdc510be3df5d2af2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_ASSERT_OUT1&nbsp;&nbsp;&nbsp;0x0004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assert out1 signal </p>

</div>
</div>
<a class="anchor" id="a98ca88cd5c9a0dbbb44ab7feee22e1ea"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_ASSERT_OUT2" ref="a98ca88cd5c9a0dbbb44ab7feee22e1ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_ASSERT_OUT2&nbsp;&nbsp;&nbsp;0x0008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assert out2 signal </p>

</div>
</div>
<a class="anchor" id="a0b4be9e79ab42ff65c9ccbccfd53d1e8"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_ASSERT_RTS" ref="a0b4be9e79ab42ff65c9ccbccfd53d1e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_ASSERT_RTS&nbsp;&nbsp;&nbsp;0x0002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assert RTS signal </p>

</div>
</div>
<a class="anchor" id="a616329329f125e69b957d98d23c0c80d"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_DATA_INTR" ref="a616329329f125e69b957d98d23c0c80d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_DATA_INTR&nbsp;&nbsp;&nbsp;0x0100</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable data interrupts </p>

</div>
</div>
<a class="anchor" id="a9bd45da1706d1d6cfc0f22d4fca46100"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_FIFOS_ENABLE" ref="a9bd45da1706d1d6cfc0f22d4fca46100" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_FIFOS_ENABLE&nbsp;&nbsp;&nbsp;0x0040</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable FIFOs </p>

</div>
</div>
<a class="anchor" id="aaf47eddf3f91b4dfea5fa70849ccf094"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_LOOPBACK" ref="aaf47eddf3f91b4dfea5fa70849ccf094" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_LOOPBACK&nbsp;&nbsp;&nbsp;0x0200</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable local loopback </p>

</div>
</div>
<a class="anchor" id="adcf53248ec112623a28737a2e584683d"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_MODEM_INTR" ref="adcf53248ec112623a28737a2e584683d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_MODEM_INTR&nbsp;&nbsp;&nbsp;0x0080</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable modem interrupts </p>

</div>
</div>
<a class="anchor" id="a7aa1ecea52619ad2676a6d4ac3beb759"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_RESET_RX_FIFO" ref="a7aa1ecea52619ad2676a6d4ac3beb759" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_RESET_RX_FIFO&nbsp;&nbsp;&nbsp;0x0010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the receive FIFO </p>

</div>
</div>
<a class="anchor" id="a1cbbc5bddc953994ea0cb2366e3e5d60"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_RESET_TX_FIFO" ref="a1cbbc5bddc953994ea0cb2366e3e5d60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_RESET_TX_FIFO&nbsp;&nbsp;&nbsp;0x0020</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the transmit FIFO </p>

</div>
</div>
<a class="anchor" id="a08a745fcffbdb351b5bac16197578eba"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_RXLINE_INTR" ref="a08a745fcffbdb351b5bac16197578eba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_RXLINE_INTR&nbsp;&nbsp;&nbsp;0x0800</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants specify the options that may be set or retrieved with the driver, each is a unique bit mask such that multiple options may be specified. These constants indicate the function of the option when in the active state. Enable status interrupt </p>

</div>
</div>
<a class="anchor" id="a2b69543bcd3d4e794193b9b47da1bcce"></a><!-- doxytag: member="xuartns550.h::XUN_OPTION_SET_BREAK" ref="a2b69543bcd3d4e794193b9b47da1bcce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUN_OPTION_SET_BREAK&nbsp;&nbsp;&nbsp;0x0400</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set a break condition </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ae4e97640db5af678d474f3398045d64a"></a><!-- doxytag: member="xuartns550.h::XUartNs550_Handler" ref="ae4e97640db5af678d474f3398045d64a" args=")(void *CallBackRef, u32 Event, unsigned int EventData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xuartns550_8h.html#ae4e97640db5af678d474f3398045d64a">XUartNs550_Handler</a>)(void *CallBackRef, u32 Event, unsigned int EventData)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This data type defines a handler which the application must define when using interrupt mode. The handler will be called from the driver in an interrupt context to handle application specific processing.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the handler, and is passed back to the upper layer when the handler is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Event</em>&nbsp;</td><td>contains one of the event constants indicating why the handler is being called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EventData</em>&nbsp;</td><td>contains the number of bytes sent or received at the time of the call for send and receive events and contains the modem status for modem events. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a37a67d6e3901ba6bee3df7c51dab093b"></a><!-- doxytag: member="xuartns550.h::XUartNs550_CfgInitialize" ref="a37a67d6e3901ba6bee3df7c51dab093b" args="(XUartNs550 *InstancePtr, XUartNs550_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550___config.html">XUartNs550_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance such that it is ready to be used. The data format of the device is setup for 8 data bits, 1 stop bit, and no parity by default. The baud rate is set to a default value specified by Config-&gt;DefaultBaudRate if set, otherwise it is set to 19.2K baud. If the device has FIFOs (16550), they are enabled and the a receive FIFO threshold is set for 8 bytes. The default operating mode of the driver is polled mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific UART 16450/16550 device. XUartNs550_Init initializes an InstancePtr object for a specific device specified by the contents f Config. XUartNs550_Init can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful.</li>
<li>XST_UART_BAUD_ERROR if the baud rate is not possible because the input clock frequency is not divisible with an acceptable amount of error.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a67e2cea916214f246e449b8438d01384"></a><!-- doxytag: member="xuartns550.h::XUartNs550_ClearStats" ref="a67e2cea916214f246e449b8438d01384" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartNs550_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function zeros the statistics for the given instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b26f08e464f42a10a7eda114e101e64"></a><!-- doxytag: member="xuartns550.h::XUartNs550_GetDataFormat" ref="a0b26f08e464f42a10a7eda114e101e64" args="(XUartNs550 *InstancePtr, XUartNs550Format *Format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartNs550_GetDataFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550_format.html">XUartNs550Format</a> *&nbsp;</td>
          <td class="paramname"> <em>FormatPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the data format for the specified UART. The data format includes the baud rate, number of data bits, number of stop bits, and parity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FormatPtr</em>&nbsp;</td><td>is a pointer to a format structure that will contain the data format after this call completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f7c185a91f28f3490fa8ef71dab1059"></a><!-- doxytag: member="xuartns550.h::XUartNs550_GetFifoThreshold" ref="a4f7c185a91f28f3490fa8ef71dab1059" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XUartNs550_GetFifoThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the receive FIFO trigger level. The receive trigger level indicates the number of bytes in the receive FIFO that cause a receive data event (interrupt) to be generated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current receive FIFO trigger level. Constants which define each trigger level are contained in the file <a class="el" href="xuartns550_8h.html">xuartns550.h</a> and named XUN_FIFO_TRIGGER_*.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5c78c74113daef4f74aefbc57e92b3a"></a><!-- doxytag: member="xuartns550.h::XUartNs550_GetLastErrors" ref="ab5c78c74113daef4f74aefbc57e92b3a" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XUartNs550_GetLastErrors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the last errors that have occurred in the specified UART. It also clears the errors such that they cannot be retrieved again. The errors include parity error, receive overrun error, framing error, and break detection.</p>
<p>The last errors is an accumulation of the errors each time an error is discovered in the driver. A status is checked for each received byte and this status is accumulated in the last errors.</p>
<p>If this function is called after receiving a buffer of data, it will indicate any errors that occurred for the bytes of the buffer. It does not indicate which bytes contained errors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last errors that occurred. The errors are bit masks that are contained in the file <a class="el" href="xuartns550_8h.html">xuartns550.h</a> and named XUN_ERROR_*.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a541b6125f67b83adfe5f508215d59ea6"></a><!-- doxytag: member="xuartns550.h::XUartNs550_GetModemStatus" ref="a541b6125f67b83adfe5f508215d59ea6" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XUartNs550_GetModemStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the modem status from the specified UART. The modem status indicates any changes of the modem signals. This function allows the modem status to be read in a polled mode. The modem status is updated whenever it is read such that reading it twice may not yield the same results.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The modem status which are bit masks that are contained in the file <a class="el" href="xuartns550_8h.html">xuartns550.h</a> and named XUN_MODEM_*.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The bit masks used for the modem status are the exact bits of the modem status register with no abstraction. </p>

</div>
</div>
<a class="anchor" id="a120797e7b4fc719c827c4378e387efe4"></a><!-- doxytag: member="xuartns550.h::XUartNs550_GetOptions" ref="a120797e7b4fc719c827c4378e387efe4" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XUartNs550_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the options for the specified driver instance. The options are implemented as bit masks such that multiple options may be enabled or disabled simulataneously.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current options for the UART. The optionss are bit masks that are contained in the file <a class="el" href="xuartns550_8h.html">xuartns550.h</a> and named XUN_OPTION_*.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad859e54c9baab85a7dd46b6851384ff6"></a><!-- doxytag: member="xuartns550.h::XUartNs550_GetStats" ref="ad859e54c9baab85a7dd46b6851384ff6" args="(XUartNs550 *InstancePtr, XUartNs550Stats *StatsPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartNs550_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550_stats.html">XUartNs550Stats</a> *&nbsp;</td>
          <td class="paramname"> <em>StatsPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions returns a snapshot of the current statistics in the area provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatsPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_uart_ns550_stats.html">XUartNs550Stats</a> structure to where the statistics are to be copied to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a97009bf7b2508c14225b0d5835c256d0"></a><!-- doxytag: member="xuartns550.h::XUartNs550_Initialize" ref="a97009bf7b2508c14225b0d5835c256d0" args="(XUartNs550 *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance such that it is ready to be used. The data format of the device is setup for 8 data bits, 1 stop bit, and no parity by default. The baud rate is set to a default value specified by XPAR_DEFAULT_BAUD_RATE if the symbol is defined, otherwise it is set to 19.2K baud. If the device has FIFOs (16550), they are enabled and the a receive FIFO threshold is set for 8 bytes. The default operating mode of the driver is polled mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_NOT_FOUND if the device ID could not be found in the configuration table</li>
<li>XST_UART_BAUD_ERROR if the baud rate is not possible because the input clock frequency is not divisible with an acceptable amount of error</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e8579fcf317e1f30d61b4fb7fe60434"></a><!-- doxytag: member="xuartns550.h::XUartNs550_InterruptHandler" ref="a6e8579fcf317e1f30d61b4fb7fe60434" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartNs550_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the 16450/16550 UART driver. It must be connected to an interrupt system by the user such that it is called when an interrupt for any 16450/16550 UART occurs. This function does not save or restore the processor context such that the user must ensure this occurs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>contains a pointer to the instance of the UART that the interrupt is for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aab822fbaed4a57714779e35b6be6f090"></a><!-- doxytag: member="xuartns550.h::XUartNs550_IsSending" ref="aab822fbaed4a57714779e35b6be6f090" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_IsSending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function determines if the specified UART is sending data. If the transmitter register is not empty, it is sending data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value of TRUE if the UART is sending data, otherwise FALSE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afd48f9c9264de4bbfa4ff387a9a4c057"></a><!-- doxytag: member="xuartns550.h::XUartNs550_LookupConfig" ref="afd48f9c9264de4bbfa4ff387a9a4c057" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_uart_ns550___config.html">XUartNs550_Config</a>* XUartNs550_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>contains the ID of the device to look up the configuration for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the configuration found or NULL if the specified device ID was not found.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a35fc171801e394fce29cbcb09dc1ff99"></a><!-- doxytag: member="xuartns550.h::XUartNs550_Recv" ref="a35fc171801e394fce29cbcb09dc1ff99" args="(XUartNs550 *InstancePtr, u8 *BufferPtr, unsigned int NumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XUartNs550_Recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer, either in the receiver or in the FIFO if present and enabled. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue receiving data until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur. Interrupt mode must be enabled using the SetOptions function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is pointer to buffer for data to be received into </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to be received. A value of zero will stop a previous receive operation that is in progress in interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </p>

</div>
</div>
<a class="anchor" id="a2ec86252a3b83b8d7b4815ffb960562d"></a><!-- doxytag: member="xuartns550.h::XUartNs550_SelfTest" ref="a2ec86252a3b83b8d7b4815ffb960562d" args="(XUartNs550 *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions runs a self-test on the driver and hardware device. This self test performs a local loopback and verifies data can be sent and received.</p>
<p>The statistics are cleared at the end of the test. The time for this test to execute is proportional to the baud rate that has been set prior to calling this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the test was successful</li>
<li>XST_UART_TEST_FAIL if the test failed looping back the data</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>This function can hang if the hardware is not functioning properly. </dd></dl>

</div>
</div>
<a class="anchor" id="a421921af6a8df7c51ddbfa5d2301ad1b"></a><!-- doxytag: member="xuartns550.h::XUartNs550_Send" ref="a421921af6a8df7c51ddbfa5d2301ad1b" args="(XUartNs550 *InstancePtr, u8 *BufferPtr, unsigned int NumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XUartNs550_Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART. If the UART is busy sending data, it will return and indicate zero bytes were sent.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer, either in the transmitter or in the FIFO if present and enabled. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue sending data until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is pointer to a buffer of data to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>contains the number of bytes to be sent. A value of zero will stop a previous send operation that is in progress in interrupt mode. Any data that was already put into the transmit FIFO will be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually sent.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. <br/>
<br/>
 This function and the <a class="el" href="xuartns550_8h.html#ac2270082fbb7d7b2c32bd9208dae5be3">XUartNs550_SetOptions()</a> function modify shared data such that there may be a need for mutual exclusion in a multithreaded environment and if <a class="el" href="xuartns550_8h.html#ac2270082fbb7d7b2c32bd9208dae5be3">XUartNs550_SetOptions()</a> if called from a handler. </p>

</div>
</div>
<a class="anchor" id="a96a10aab5e44709b76eda319fce4b6dd"></a><!-- doxytag: member="xuartns550.h::XUartNs550_SetDataFormat" ref="a96a10aab5e44709b76eda319fce4b6dd" args="(XUartNs550 *InstancePtr, XUartNs550Format *Format)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_SetDataFormat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550_format.html">XUartNs550Format</a> *&nbsp;</td>
          <td class="paramname"> <em>FormatPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the data format for the specified UART. The data format includes the baud rate, number of data bits, number of stop bits, and parity. It is the caller's responsibility to ensure that the UART is not sending or receiving data when this function is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FormatPtr</em>&nbsp;</td><td>is a pointer to a format structure containing the data format to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the data format was successfully set.</li>
<li>XST_UART_BAUD_ERROR indicates the baud rate could not be set because of the amount of error with the baud rate and the input clock frequency.</li>
<li>XST_INVALID_PARAM if one of the parameters was not valid.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The data types in the format type, data bits and parity, are 32 bit fields to prevent a compiler warning that is a bug with the GNU PowerPC compiler. The asserts in this function will cause a warning if these fields are bytes. <br/>
<br/>
 The baud rates tested include: 1200, 2400, 4800, 9600, 19200, 38400, 57600 and 115200. </p>

</div>
</div>
<a class="anchor" id="aedd1056b9f1283ee15c1a3c349acb845"></a><!-- doxytag: member="xuartns550.h::XUartNs550_SetFifoThreshold" ref="aedd1056b9f1283ee15c1a3c349acb845" args="(XUartNs550 *InstancePtr, u8 TriggerLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_SetFifoThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TriggerLevel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sets the receive FIFO trigger level. The receive trigger level specifies the number of bytes in the receive FIFO that cause a receive data event (interrupt) to be generated. The FIFOs must be enabled to set the trigger level.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TriggerLevel</em>&nbsp;</td><td>contains the trigger level to set. Constants which define each trigger level are contained in the file <a class="el" href="xuartns550_8h.html">xuartns550.h</a> and named XUN_FIFO_TRIGGER_*.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the trigger level was set</li>
<li>XST_UART_CONFIG_ERROR if the trigger level could not be set, either the hardware does not support the FIFOs or FIFOs are not enabled</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adf7c4826f92d5e8fd70763f4448a360d"></a><!-- doxytag: member="xuartns550.h::XUartNs550_SetHandler" ref="adf7c4826f92d5e8fd70763f4448a360d" args="(XUartNs550 *InstancePtr, XUartNs550_Handler FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUartNs550_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xuartns550_8h.html#ae4e97640db5af678d474f3398045d64a">XUartNs550_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver. The purpose of the handler is to allow application specific processing to be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </p>

</div>
</div>
<a class="anchor" id="ac2270082fbb7d7b2c32bd9208dae5be3"></a><!-- doxytag: member="xuartns550.h::XUartNs550_SetOptions" ref="ac2270082fbb7d7b2c32bd9208dae5be3" args="(XUartNs550 *InstancePtr, u16 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUartNs550_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the options for the specified driver instance. The options are implemented as bit masks such that multiple options may be enabled or disabled simultaneously.</p>
<p>The GetOptions function may be called to retrieve the currently enabled options. The result is ORed in the desired new settings to be enabled and ANDed with the inverse to clear the settings to be disabled. The resulting value is then used as the options for the SetOption function call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_uart_ns550.html">XUartNs550</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>contains the options to be set which are bit masks contained in the file <a class="el" href="xuartns550_8h.html">xuartns550.h</a> and named XUN_OPTION_*.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully.</li>
<li>XST_UART_CONFIG_ERROR if the options could not be set because the hardware does not support FIFOs</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
