<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver mbox v4_0: xmbox.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xmbox.c File Reference</h1><code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="xmbox_8h.html">xmbox.h</a>&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#ae0968f8608b3f8667ef6f5ec89e56f58">XMbox_CfgInitialize</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, <a class="el" href="struct_x_mbox___config.html">XMbox_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#aa1f68405027d147c68aa53bcb49fbd5a">XMbox_Read</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesRecvdPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#ab14511b623c1d3c191cdc441b8909006">XMbox_ReadBlocking</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a254c4e5a042e34520c3669fbf9651bc2">XMbox_Write</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesSentPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a23ee00f97807790770f2dab9b2ea3b0e">XMbox_WriteBlocking</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#abb01fe466ffcd0da315ffee115f4cd60">XMbox_IsEmpty</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#aa9db05bc2935bcc2230ff023b5c9cbcc">XMbox_IsFull</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a10691489238a2a1b8515468b416d773e">XMbox_Flush</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a8e56860ea2cf7f4f1df0f1862d8c4c61">XMbox_SetInterruptEnable</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#acb96b1964aa476b4d60df4fd2440022c">XMbox_GetInterruptEnable</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#af73757d06d4cc60466e563ab185a6c07">XMbox_GetInterruptStatus</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#ab93a50b0032e4b6202c23c4201e0591e">XMbox_ClearInterrupt</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a4fb918498d8adc676f4ea554585609d2">XMbox_SetSendThreshold</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a8c05b007d0f92ca32702db58573302a9">XMbox_SetReceiveThreshold</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr, u32 Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xmbox_8c.html#a8620711a04da0032b216e3f57a80570d">XMbox_GetStatus</a> (<a class="el" href="struct_x_mbox.html">XMbox</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains required functions for the <a class="el" href="struct_x_mbox.html">XMbox</a> driver.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.00a va            First release
 1.00a ecm  06/01/07 Cleanup, new coding standard, check into XCS
 1.01a ecm  08/19/08 Fixed the receive routine, FSL leg, was using SendID
			instead of the correct RecvID.
 			Fixed CRs 466320, 466322, 476535, 476242, 476243
					  new rev
 2.00a hm   04/09/09 Added support for mailbox v2.0, which has interrupts;
			Fixed CR 502464, which removed extra
			definitions that are not associated with
			the interface.
			Fixed the canonical definition so that each
			interface is considered as a device instance.
 3.00a hbm  10/19/09   Migrated to HAL phase 1 to use xil_io.
			Removed _m from the function names.
			Renamed _mIsEmpty to _IsEmptyHw and _mIsFull
			to _IsFullHw.
 3.02a bss  08/18/12   Added XMbox_GetStatus API for CR 676187</pre><pre> </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae0968f8608b3f8667ef6f5ec89e56f58"></a><!-- doxytag: member="xmbox.c::XMbox_CfgInitialize" ref="ae0968f8608b3f8667ef6f5ec89e56f58" args="(XMbox *InstancePtr, XMbox_Config *ConfigPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_mbox___config.html">XMbox_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific mailbox.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment. It is the Base Address in a stand alone environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab93a50b0032e4b6202c23c4201e0591e"></a><!-- doxytag: member="xmbox.c::XMbox_ClearInterrupt" ref="ab93a50b0032e4b6202c23c4201e0591e" args="(XMbox *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears pending interrupts with the provided mask. This function should be called after the software has serviced the interrupts that are pending. This function clears the corresponding bits of the Interrupt Status Register. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is a logical OR of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a10691489238a2a1b8515468b416d773e"></a><!-- doxytag: member="xmbox.c::XMbox_Flush" ref="a10691489238a2a1b8515468b416d773e" args="(XMbox *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_Flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the mailbox FIFOs by empting the READ FIFO and making sure the Error Status is zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XST_FAILURE if there are any outstanding errors.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Data from read FIFO is thrown away. </dd></dl>

</div>
</div>
<a class="anchor" id="acb96b1964aa476b4d60df4fd2440022c"></a><!-- doxytag: member="xmbox.c::XMbox_GetInterruptEnable" ref="acb96b1964aa476b4d60df4fd2440022c" args="(XMbox *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_GetInterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieves the interrupt enable for the mailbox. AND the result of this function with XMB_IX_* to determine which interrupts of this mailbox are enabled. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mask of interrupt bits made up of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af73757d06d4cc60466e563ab185a6c07"></a><!-- doxytag: member="xmbox.c::XMbox_GetInterruptStatus" ref="af73757d06d4cc60466e563ab185a6c07" args="(XMbox *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Retrieve the interrupt status for the mailbox. AND the results of this function with XMB_IX_* to determine which interrupts are currently pending to the processor. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Mask of interrupt bits made up of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8620711a04da0032b216e3f57a80570d"></a><!-- doxytag: member="xmbox.c::XMbox_GetStatus" ref="a8620711a04da0032b216e3f57a80570d" args="(XMbox *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns Status register contents. This function can only be used for Non-FSL interface. If not, the function will fail in an assert. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value returns Status Register contents.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abb01fe466ffcd0da315ffee115f4cd60"></a><!-- doxytag: member="xmbox.c::XMbox_IsEmpty" ref="abb01fe466ffcd0da315ffee115f4cd60" args="(XMbox *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see if there is data available to be read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>FALSE if there is data to be read.</li>
<li>TRUE is there no data to be read.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9db05bc2935bcc2230ff023b5c9cbcc"></a><!-- doxytag: member="xmbox.c::XMbox_IsFull" ref="aa9db05bc2935bcc2230ff023b5c9cbcc" args="(XMbox *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XMbox_IsFull </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks to see if there is room in the write FIFO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>FALSE if there is room in write FIFO.</li>
<li>TRUE if there is room in write FIFO.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1f68405027d147c68aa53bcb49fbd5a"></a><!-- doxytag: member="xmbox.c::XMbox_Read" ref="aa1f68405027d147c68aa53bcb49fbd5a" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesRecvdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RequestedBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BytesRecvdPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer. The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<p>This function is non blocking.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the buffer to read the mailbox contents into, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes of data requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesRecvdPtr</em>&nbsp;</td><td>is the memory that is updated with the number of bytes of data actually read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on success.</li>
<li>XST_NO_DATA ifthere was no data in the mailbox.</li>
</ul>
</dd></dl>
<p>On success, the number of bytes read is returned through the pointer. The call may return with fewer bytes placed in the buffer than requested (not including zero). This is not necessarily an error condition and indicates the amount of data that was currently available in the mailbox.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab14511b623c1d3c191cdc441b8909006"></a><!-- doxytag: member="xmbox.c::XMbox_ReadBlocking" ref="ab14511b623c1d3c191cdc441b8909006" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_ReadBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RequestedBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads requested bytes from the mailbox referenced by InstancePtr,into the buffer pointed to by the provided pointer. The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the buffer to read the mailbox contents into, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes of data requested.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The call blocks until the number of bytes requested are available. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e56860ea2cf7f4f1df0f1862d8c4c61"></a><!-- doxytag: member="xmbox.c::XMbox_SetInterruptEnable" ref="a8e56860ea2cf7f4f1df0f1862d8c4c61" args="(XMbox *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_SetInterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the interrupt enable register for this mailbox. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is a logical OR of XMB_IX_* constants found in <a class="el" href="xmbox__hw_8h.html">xmbox_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c05b007d0f92ca32702db58573302a9"></a><!-- doxytag: member="xmbox.c::XMbox_SetReceiveThreshold" ref="a8c05b007d0f92ca32702db58573302a9" args="(XMbox *InstancePtr, u32 Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_SetReceiveThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the Receive Interrupt Threshold. This function can only be used for Non-FSL interface. If not, the function will fail in an assert. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is a value to set for the RIT. Only lower Log2(FIFO Depth) bits are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4fb918498d8adc676f4ea554585609d2"></a><!-- doxytag: member="xmbox.c::XMbox_SetSendThreshold" ref="a4fb918498d8adc676f4ea554585609d2" args="(XMbox *InstancePtr, u32 Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_SetSendThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the Send Interrupt Threshold. This function can only be used for Non-FSL interface. If not, the function will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is a value to set for the SIT. Only lower Log2(FIFO Depth) bits are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a254c4e5a042e34520c3669fbf9651bc2"></a><!-- doxytag: member="xmbox.c::XMbox_Write" ref="a254c4e5a042e34520c3669fbf9651bc2" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes, u32 *BytesSentPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XMbox_Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RequestedBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BytesSentPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr.The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<p>This function is non blocking.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the source data buffer, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes requested to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesRecvdPtr</em>&nbsp;</td><td>points to memory which is updated with the actual number of bytes written, return value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS on success.</li>
<li>XST_FIFO_NO_ROOM if the fifo was full.</li>
</ul>
<p>On success, the number of bytes successfully written into the destination mailbox is returned in the provided pointer. The call may return with zero. This is not necessarily an error condition and indicates that the mailbox is currently full.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The provided buffer pointed to by BufferPtr must be aligned to a word boundary. </dd></dl>

</div>
</div>
<a class="anchor" id="a23ee00f97807790770f2dab9b2ea3b0e"></a><!-- doxytag: member="xmbox.c::XMbox_WriteBlocking" ref="a23ee00f97807790770f2dab9b2ea3b0e" args="(XMbox *InstancePtr, u32 *BufferPtr, u32 RequestedBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMbox_WriteBlocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_mbox.html">XMbox</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RequestedBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the requested bytes from the buffer pointed to by the provided pointer into the mailbox referenced by InstancePtr. The number of bytes must be a multiple of 4 (bytes). If not, the call will fail in an assert.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_mbox.html">XMbox</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is the source data buffer, aligned to a word boundary. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RequestedBytes</em>&nbsp;</td><td>is the number of bytes requested to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The call blocks until the number of bytes requested are written. The provided buffer pointed to by BufferPtr must be aligned to a word boundary. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
