<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver can v3_0: xaxicdma.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xaxicdma.h File Reference</h1><code>#include &quot;<a class="el" href="xaxicdma__bd_8h.html">xaxicdma_bd.h</a>&quot;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;xil_cache.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_cdma___intr_handler_list.html">XAxiCdma_IntrHandlerList</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_cdma___config.html">XAxiCdma_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a6f61cbb8624c65bb64d0012bf24a5284">XAXICDMA_COALESCE_NO_CHANGE</a>&nbsp;&nbsp;&nbsp;0xFFFFFFFF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#abc7205cc3ca63a53529e9de35491ee0e">XAXICDMA_ALL_BDS</a>&nbsp;&nbsp;&nbsp;0x7FFFFFFF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a91c5de92ad6a33c0eda5c1283e5281d4">XAXICDMA_SG_MODE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a57779d0c9c90168a091b83ccd9b44719">XAXICDMA_SIMPLE_MODE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#ae8226c9464f82e72e2d0043576347c00">XAXICDMA_MAXIMUM_MAX_HANDLER</a>&nbsp;&nbsp;&nbsp;20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#aee794b3af79e9784fcaaabc75e7cae6f">XAXICDMA_KEYHOLE_READ</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a2e31a8c43cde3589ce58ce75a8668a1d">XAXICDMA_KEYHOLE_WRITE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a920b87736bbfeff00324ef3bc74428d5">XAXICDMA_CACHE_FLUSH</a>(BdPtr)&nbsp;&nbsp;&nbsp;Xil_DCacheFlushRange((BdPtr), XAXICDMA_BD_HW_NUM_BYTES);</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#ab1ee176def1394c3bfe82340cc8396f2">XAXICDMA_CACHE_INVALIDATE</a>(BdPtr)&nbsp;&nbsp;&nbsp;Xil_DCacheInvalidateRange((BdPtr), XAXICDMA_BD_HW_NUM_BYTES)</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Call Back function</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8f6a3c00c046aeaf7eabb413297b5f97"></a> If interrupt is enabled, and the application wants to be notified about the completion of a transfer, the application should register its call back function to the driver.</p>
<p>The call back function is registered through the transfer submission.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the call back reference passed in by application. A NULL pointer is acceptable.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IrqMask</em>&nbsp;</td><td>is the interrupt mask regarding this completion </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBdPtr</em>&nbsp;</td><td>is the pointer to number of BDs this handler should handle, for simple transfer, it is ignored. </td></tr>
  </table>
  </dd>
</dl>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a190041f3a52f247fbc91a93041095aac">XAxiCdma_CallBackFn</a> )(void *CallBackRef, u32 IrqMask, int *NumBdPtr)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_axi_cdma___config.html">XAxiCdma_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#af3cf1436a4f58e5fe20967715a71061b">XAxiCdma_LookupConfig</a> (u32 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a6da52831640e9c242f626ec8b7478aa4">XAxiCdma_CfgInitialize</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, <a class="el" href="struct_x_axi_cdma___config.html">XAxiCdma_Config</a> *CfgPtr, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#aaf97cc8317af0bf1678973925beff0c5">XAxiCdma_Reset</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a2575375744593bd55425365dde7744e5">XAxiCdma_ResetIsDone</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#aee6e140ed15cd9b7e49145e01220115a">XAxiCdma_IsBusy</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a91adf55050cb617cee00b0ba2f0d754e">XAxiCdma_SetCoalesce</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 Counter, u32 Delay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a92087f03877293982f895e8178557f6a">XAxiCdma_GetCoalesce</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 *CounterPtr, u32 *DelayPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#ae1fbdb8f7ad8926f744c771e07814f72">XAxiCdma_GetError</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a9f146fe224ea4c9a86477de3030dd79a">XAxiCdma_IntrEnable</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a1a269e884ce6e3552313521dea8032b6">XAxiCdma_IntrGetEnabled</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#abdccf08d74f4e037b06a36a2e9db2877">XAxiCdma_IntrDisable</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a8acd5bf5f5f072c6e425a8cc1b589498">XAxiCdma_IntrHandler</a> (void *HandlerRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#af116bab75f6934e95cd3507a0e06299a">XAxiCdma_SimpleTransfer</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 SrcAddr, u32 DstAddr, int Length, <a class="el" href="xaxicdma_8h.html#a190041f3a52f247fbc91a93041095aac">XAxiCdma_CallBackFn</a> SimpleCallBack, void *CallbackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a815f36efce97dba797f67f9acbbb761d">XAxiCdma_SelectKeyHole</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 Direction, u32 Select)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a336f4afa8e207e21d5b1118152134b6d">XAxiCdma_BdRingCntCalc</a> (u32 Alignment, u32 Bytes, u32 BuffAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a1fdf9f83484b6869cc37249028def78a">XAxiCdma_BdRingMemCalc</a> (u32 Alignment, int NumBd)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a77af17739c5b58ca5440176355324022">XAxiCdma_BdRingGetCnt</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#abce64a96cfb86fe370be64ad3dda7e88">XAxiCdma_BdRingGetFreeCnt</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a4677cddba8354ca3979f9b6ae386ffde">XAxiCdma_BdRingSnapShotCurrBd</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a44b28bc8523d7770157b12d4f996d249">XAxiCdma_BdRingGetCurrBd</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#aef6cca02b3180f9a4d977dc1d9e8e1ae">XAxiCdma_BdRingNext</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *BdPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a95b6d2f63ea3b0ccefc4eb155070b719">XAxiCdma_BdRingPrev</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *BdPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a8c4e66e92f9739dd9de28d156e028c6b">XAxiCdma_BdRingCreate</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, int BdCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a39cf1df118ea142a91e35fb41d421929">XAxiCdma_BdRingClone</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *TemplateBdPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a4b168a008bd2ea4a7797d60a716e29f6">XAxiCdma_BdRingAlloc</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, int NumBd, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> **BdSetPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#afa7e792362f65151e2f854731f3002c1">XAxiCdma_BdRingUnAlloc</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, int NumBd, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *BdSetPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a58faef3eda9fdbd9b368d66e55702258">XAxiCdma_BdRingToHw</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, int NumBd, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *BdSetPtr, <a class="el" href="xaxicdma_8h.html#a190041f3a52f247fbc91a93041095aac">XAxiCdma_CallBackFn</a> CallBack, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#ae94bad12ae7b26d63871a6ed5e8593c6">XAxiCdma_BdRingFromHw</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, int BdLimit, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> **BdSetPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a2447d02b1d2c12ec812746b452ff53cc">XAxiCdma_BdRingFree</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr, int NumBd, <a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *BdSetPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxicdma_8h.html#a3287c31f1aa41a1e4a535af134324524">XAxiCdma_DumpRegisters</a> (<a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="abc7205cc3ca63a53529e9de35491ee0e"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_ALL_BDS" ref="abc7205cc3ca63a53529e9de35491ee0e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_ALL_BDS&nbsp;&nbsp;&nbsp;0x7FFFFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a920b87736bbfeff00324ef3bc74428d5"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_CACHE_FLUSH" ref="a920b87736bbfeff00324ef3bc74428d5" args="(BdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_CACHE_FLUSH</td>
          <td>(</td>
          <td class="paramtype">BdPtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;Xil_DCacheFlushRange((BdPtr), XAXICDMA_BD_HW_NUM_BYTES);</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1ee176def1394c3bfe82340cc8396f2"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_CACHE_INVALIDATE" ref="ab1ee176def1394c3bfe82340cc8396f2" args="(BdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_CACHE_INVALIDATE</td>
          <td>(</td>
          <td class="paramtype">BdPtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;Xil_DCacheInvalidateRange((BdPtr), XAXICDMA_BD_HW_NUM_BYTES)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f61cbb8624c65bb64d0012bf24a5284"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_COALESCE_NO_CHANGE" ref="a6f61cbb8624c65bb64d0012bf24a5284" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_COALESCE_NO_CHANGE&nbsp;&nbsp;&nbsp;0xFFFFFFFF</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee794b3af79e9784fcaaabc75e7cae6f"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_KEYHOLE_READ" ref="aee794b3af79e9784fcaaabc75e7cae6f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_KEYHOLE_READ&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e31a8c43cde3589ce58ce75a8668a1d"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_KEYHOLE_WRITE" ref="a2e31a8c43cde3589ce58ce75a8668a1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_KEYHOLE_WRITE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8226c9464f82e72e2d0043576347c00"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_MAXIMUM_MAX_HANDLER" ref="ae8226c9464f82e72e2d0043576347c00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_MAXIMUM_MAX_HANDLER&nbsp;&nbsp;&nbsp;20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91c5de92ad6a33c0eda5c1283e5281d4"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_SG_MODE" ref="a91c5de92ad6a33c0eda5c1283e5281d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_SG_MODE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a57779d0c9c90168a091b83ccd9b44719"></a><!-- doxytag: member="xaxicdma.h::XAXICDMA_SIMPLE_MODE" ref="a57779d0c9c90168a091b83ccd9b44719" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXICDMA_SIMPLE_MODE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a190041f3a52f247fbc91a93041095aac"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_CallBackFn" ref="a190041f3a52f247fbc91a93041095aac" args=")(void *CallBackRef, u32 IrqMask, int *NumBdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xaxicdma_8h.html#a190041f3a52f247fbc91a93041095aac">XAxiCdma_CallBackFn</a>)(void *CallBackRef, u32 IrqMask, int *NumBdPtr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a4b168a008bd2ea4a7797d60a716e29f6"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingAlloc" ref="a4b168a008bd2ea4a7797d60a716e29f6" args="(XAxiCdma *InstancePtr, int NumBd, XAxiCdma_Bd **BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> **&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function requests number of BDs from the BD ring.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to request </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the pointer to the set of BDs returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_INVALID_PARAM if requests non-positive number of BDs</li>
<li>XST_FAILURE if not enough free BDs available</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a39cf1df118ea142a91e35fb41d421929"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingClone" ref="a39cf1df118ea142a91e35fb41d421929" args="(XAxiCdma *InstancePtr, XAxiCdma_Bd *TemplateBdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingClone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>TemplateBdPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clones all BDs in the BD ring to be the same as the given BD.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TemplateBdPtr</em>&nbsp;</td><td>is the BD to be copied from</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_DMA_SG_NO_LIST if there is no BD ring</li>
<li>XST_DEVICE_IS_STARTED if the hardware is running</li>
<li>XST_DMA_SG_LIST_ERROR is the BD ring is still in use</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a336f4afa8e207e21d5b1118152134b6d"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingCntCalc" ref="a336f4afa8e207e21d5b1118152134b6d" args="(u32 Alignment, u32 Bytes, u32 BuffAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingCntCalc </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BdBuffAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function calculates how many BDs can be built using given number of bytes of memory, according to alignment provided.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>is the preferred alignment for the BDs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>is the number of bytes of memory to build BDs with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdBuffAddr</em>&nbsp;</td><td>is the buffer address allocated for the BDs. This is to check the alignment of the buffer to make sure the the buffer is aligned to the BD alignment. An invalid buffer address results in 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of BDs can be built. 0 means buffer address is not valid.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The application is responsible to align the buffer before pass it to this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c4e66e92f9739dd9de28d156e028c6b"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingCreate" ref="a8c4e66e92f9739dd9de28d156e028c6b" args="(XAxiCdma *InstancePtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, int BdCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingCreate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhysAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>VirtAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>BdCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function creates the BD ring for the driver instance. If a BD ring pre-exist of this ring, the previous ring is lost.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhysAddr</em>&nbsp;</td><td>is the physical address of the memory for the BD ring </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtAddr</em>&nbsp;</td><td>is the virtual address of the memory for the BD ring </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>is the alignment for the BDs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdCount</em>&nbsp;</td><td>is the number of BDs to create in the ring</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_INVALID_PARAM for invalid parameter</li>
<li>XST_DMA_SG_LIST_ERROR for invalid memory region</li>
<li>XST_FAILURE if the hardware build is simple mode only</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>For a system that has flat memory layout, then the PhysAddr and the VirtAddr are the same. </dd></dl>

</div>
</div>
<a class="anchor" id="a2447d02b1d2c12ec812746b452ff53cc"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingFree" ref="a2447d02b1d2c12ec812746b452ff53cc" args="(XAxiCdma *InstancePtr, int NumBd, XAxiCdma_Bd *BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingFree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the BDs back to the free pool of the BD ring.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to free </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the set of BDs to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_INVALID_PARAM if number of BDs is negative</li>
<li>XST_DMA_SG_LIST_ERROR if the BD ring management has a problem</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae94bad12ae7b26d63871a6ed5e8593c6"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingFromHw" ref="ae94bad12ae7b26d63871a6ed5e8593c6" args="(XAxiCdma *InstancePtr, int BdLimit, XAxiCdma_Bd **BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingFromHw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>BdLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> **&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function tries to retrieve completed BDs from the hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdLimit</em>&nbsp;</td><td>is the maximum number of completed BDs to retrieve </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the set of completed BDs</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of completed BDs.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a77af17739c5b58ca5440176355324022"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingGetCnt" ref="a77af17739c5b58ca5440176355324022" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingGetCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the total number of BDs in the BD ring.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total number of BDs for this instance</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a44b28bc8523d7770157b12d4f996d249"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingGetCurrBd" ref="a44b28bc8523d7770157b12d4f996d249" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a>* XAxiCdma_BdRingGetCurrBd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function grabs a copy of the current BD pointer from the hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The BD pointer in CDESC register</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abce64a96cfb86fe370be64ad3dda7e88"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingGetFreeCnt" ref="abce64a96cfb86fe370be64ad3dda7e88" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingGetFreeCnt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the number of free BDs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total number of free BDs for this instance</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdf9f83484b6869cc37249028def78a"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingMemCalc" ref="a1fdf9f83484b6869cc37249028def78a" args="(u32 Alignment, int NumBd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingMemCalc </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NumBd</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function calculates how much memory is needed to build requested number of BDs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>is the preferred alignment for the BDs </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to be built</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes of memory needed to build the BDs</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aef6cca02b3180f9a4d977dc1d9e8e1ae"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingNext" ref="aef6cca02b3180f9a4d977dc1d9e8e1ae" args="(XAxiCdma *InstancePtr, XAxiCdma_Bd *BdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a>* XAxiCdma_BdRingNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the next BD of the current BD on the BD ring.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdPtr</em>&nbsp;</td><td>is the current BD</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The next BD on the ring from the current BD, NULL if passed in BdPtr not valid.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a95b6d2f63ea3b0ccefc4eb155070b719"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingPrev" ref="a95b6d2f63ea3b0ccefc4eb155070b719" args="(XAxiCdma *InstancePtr, XAxiCdma_Bd *BdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a>* XAxiCdma_BdRingPrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the previous BD of the current BD on the BD ring.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdPtr</em>&nbsp;</td><td>is the current BD</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The previous BD on the ring from the current BD</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4677cddba8354ca3979f9b6ae386ffde"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingSnapShotCurrBd" ref="a4677cddba8354ca3979f9b6ae386ffde" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_BdRingSnapShotCurrBd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function grabs a copy of the current BD pointer from the hardware. It is normally used to prepare for the hardware reset. The snapshot of the current BD pointer should be reloaded once the reset is done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a58faef3eda9fdbd9b368d66e55702258"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingToHw" ref="a58faef3eda9fdbd9b368d66e55702258" args="(XAxiCdma *InstancePtr, int NumBd, XAxiCdma_Bd *BdSetPtr, XAxiCdma_CallBackFn CallBack, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingToHw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma_8h.html#a190041f3a52f247fbc91a93041095aac">XAxiCdma_CallBackFn</a>&nbsp;</td>
          <td class="paramname"> <em>CallBackFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function tries to enqueue the number of BDs to the hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to enqueue </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the set of BDs to be enqueued </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFn</em>&nbsp;</td><td>is the callback function for this transfer, NULL is fine </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the callback reference pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_INVALID_PARAM if enqueues negative number of BDs or zero transfer len</li>
<li>XST_DMA_SG_LIST_ERROR if BD ring management has a problem</li>
<li>XST_FIFO_NO_ROOM if the interrupt handler array is full</li>
<li>XST_FAILURE for: Hardware is in invalid state, for example, reset failed Or, the hardware build is simple mode only</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afa7e792362f65151e2f854731f3002c1"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_BdRingUnAlloc" ref="afa7e792362f65151e2f854731f3002c1" args="(XAxiCdma *InstancePtr, int NumBd, XAxiCdma_Bd *BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_BdRingUnAlloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma__bd_8h.html#a4e138c5e58429588fc171c17bc53e966">XAxiCdma_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function tries to free the number of BDs back to the ring.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to return </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the set of BDs to be returned</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_INVALID_PARAM if to free non-positive number of BDs</li>
<li>XST_FAILURE if BD ring management shows an error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6da52831640e9c242f626ec8b7478aa4"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_CfgInitialize" ref="a6da52831640e9c242f626ec8b7478aa4" args="(XAxiCdma *InstancePtr, XAxiCdma_Config *CfgPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma___config.html">XAxiCdma_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes the driver. It should be called before any other function calls to the driver.</p>
<p>It sets up the driver according to the hardware build. It resets the hardware at the end.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance that is working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the pointer to the hardware configuration structure </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the virtual address of the hardware instance. If address translation is not in use, please use the physical address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_INVALID_PARAM if word length is less than 4</li>
<li>XST_FAILURE for reset failure</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3287c31f1aa41a1e4a535af134324524"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_DumpRegisters" ref="a3287c31f1aa41a1e4a535af134324524" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_DumpRegisters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function dumps the registers of this DMA instance</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a92087f03877293982f895e8178557f6a"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_GetCoalesce" ref="a92087f03877293982f895e8178557f6a" args="(XAxiCdma *InstancePtr, u32 *CounterPtr, u32 *DelayPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_GetCoalesce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>CounterPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DelayPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the current setting of the interrupt coalescing threshold counter and the delay counter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CounterPtr</em>&nbsp;</td><td>is the return value for the coalescing counter setting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DelayPtr</em>&nbsp;</td><td>is the return value for the delay counter setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A zero coalescing threshold indicates invalid results</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae1fbdb8f7ad8926f744c771e07814f72"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_GetError" ref="ae1fbdb8f7ad8926f744c771e07814f72" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAxiCdma_GetError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the status on error bits.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The error bits in the status register. Zero indicates no errors.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abdccf08d74f4e037b06a36a2e9db2877"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_IntrDisable" ref="abdccf08d74f4e037b06a36a2e9db2877" args="(XAxiCdma *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables interrupts specified by the Mask. Interrupts that are not in the mask are not affected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask for the interrupts to be disabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f146fe224ea4c9a86477de3030dd79a"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_IntrEnable" ref="a9f146fe224ea4c9a86477de3030dd79a" args="(XAxiCdma *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables interrupts specified by the Mask. Interrupts that are not in the mask are not affected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask for the interrupts to be enabled</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a269e884ce6e3552313521dea8032b6"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_IntrGetEnabled" ref="a1a269e884ce6e3552313521dea8032b6" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAxiCdma_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the mask for the interrupts that are currently enabled</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bit mask for the interrupts that are currently enabled</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8acd5bf5f5f072c6e425a8cc1b589498"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_IntrHandler" ref="a8acd5bf5f5f072c6e425a8cc1b589498" args="(void *HandlerRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>HandlerRef</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the driver, it handles all the interrupts. For the completion of a transfer that has a callback function, the callback function is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>HandlerRef</em>&nbsp;</td><td>is a reference pointer passed to the interrupt registration function. It will be a pointer to the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If one transfer does not have all its submitted BDs completed successfully,then a reset is needed to clean up the mess left by that transfer.Otherwise, the wrong interrupt callback maybe called for the following transfers. However, if you always use the same interrupt callback for all the transfers, and you are the only user of the DMA engine, then you do not have to worry about this. </dd></dl>

</div>
</div>
<a class="anchor" id="aee6e140ed15cd9b7e49145e01220115a"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_IsBusy" ref="aee6e140ed15cd9b7e49145e01220115a" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_IsBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function checks whether the hardware is doing transfer</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>1 if the hardware is doing a transfer</li>
<li>0 if the hardware is idle</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af3cf1436a4f58e5fe20967715a71061b"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_LookupConfig" ref="af3cf1436a4f58e5fe20967715a71061b" args="(u32 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_axi_cdma___config.html">XAxiCdma_Config</a>* XAxiCdma_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Look up the hardware configuration for a device instance</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device to lookup for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The configuration structure for the device. If the device ID is not found,a NULL pointer is returned.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf97cc8317af0bf1678973925beff0c5"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_Reset" ref="aaf97cc8317af0bf1678973925beff0c5" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiCdma_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function conducts hardware reset</p>
<p>Current transfer will finish gracefully. However, all queued SG transfers that have not started will be flushed from the hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2575375744593bd55425365dde7744e5"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_ResetIsDone" ref="a2575375744593bd55425365dde7744e5" args="(XAxiCdma *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_ResetIsDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function checks whether the hardware reset is done</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>1 if the reset has finished successfully</li>
<li>0 if the reset is not done</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a815f36efce97dba797f67f9acbbb761d"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_SelectKeyHole" ref="a815f36efce97dba797f67f9acbbb761d" args="(XAxiCdma *InstancePtr, u32 Direction, u32 Select)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_SelectKeyHole </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Select</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function configures KeyHole Write/Read Feature</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is WRITE/READ  Select is the option to enable (TRUE) or disable (FALSE).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- XST_SUCCESS for success<ul>
<li>XST_DEVICE_BUSY when transfer is in progress</li>
<li>XST_NO_FEATURE when not configured with feature</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a91adf55050cb617cee00b0ba2f0d754e"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_SetCoalesce" ref="a91adf55050cb617cee00b0ba2f0d754e" args="(XAxiCdma *InstancePtr, u32 Counter, u32 Delay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_SetCoalesce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Delay</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function tries to set the interrupt coalescing threshold counter and the delay counter. If to set only one of the counters, set the value of the other counter to be XAXICDMA_COALESCE_NO_CHANGE.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the driver instance we are working on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Counter</em>&nbsp;</td><td>is the coalescing threshold to set to, the valid range is 1 to XAXICDMA_COALESCE_MAX. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Delay</em>&nbsp;</td><td>is the delay timeout counter to set to, the valid range is 0 to XAXICDMA_DELAY_MAX. Setting a value of 0 disables the delay interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success</li>
<li>XST_FAILURE if hardware is in invalid state, for example, reset failed</li>
<li>XST_INVALID_PARAM if one of the counters is not in the valid range</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af116bab75f6934e95cd3507a0e06299a"></a><!-- doxytag: member="xaxicdma.h::XAxiCdma_SimpleTransfer" ref="af116bab75f6934e95cd3507a0e06299a" args="(XAxiCdma *InstancePtr, u32 SrcAddr, u32 DstAddr, int Length, XAxiCdma_CallBackFn SimpleCallBack, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiCdma_SimpleTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_cdma.html">XAxiCdma</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xaxicdma_8h.html#a190041f3a52f247fbc91a93041095aac">XAxiCdma_CallBackFn</a>&nbsp;</td>
          <td class="paramname"> <em>SimpleCallBack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function does one simple transfer submission</p>
<p>It checks in the following sequence:</p>
<ul>
<li>if engine is busy, cannot submit</li>
<li>if software is still handling the completion of the previous simple transfer, cannot submit</li>
<li>if engine is in SG mode and cannot switch to simple mode, cannot submit</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the pointer to the driver instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcAddr</em>&nbsp;</td><td>is the address of the source buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DstAddr</em>&nbsp;</td><td>is the address of the destination buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is the length of the transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SimpleCallBack</em>&nbsp;</td><td>is the callback function for the simple transfer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the callback reference pointer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS for success of submission</li>
<li>XST_FAILURE for submission failure, maybe caused by: Another simple transfer is still going . Another SG transfer is still going</li>
<li>XST_INVALID_PARAM if: Length out of valid range [1:8M] Or, address not aligned when DRE is not built in</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only set the callback function if using interrupt to signal the completion.If used in polling mode, please set the callback function to be NULL. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
