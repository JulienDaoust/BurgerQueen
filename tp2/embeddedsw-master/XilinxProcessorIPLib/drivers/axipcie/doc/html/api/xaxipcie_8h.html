<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver axipcie v3_0: xaxipcie.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xaxipcie.h File Reference</h1><code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xaxipcie__hw_8h.html">xaxipcie_hw.h</a>&quot;</code><br/>
<code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;xil_cache.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a02ad1a5f3d0ed294888c77c60b229a3b">XAXIPCIE_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#aea6bdd6f359208f120597390fe6cad0b">XAXIPCIE_IS_RC</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#afa73b84cb240d4b683d33ed8e48f4f49">ALIGN_4KB</a>&nbsp;&nbsp;&nbsp;0xFFFFF000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a7e5fb7cdef729030bf31e9c3651253b1">XAXIPCIE_VSEC1</a>&nbsp;&nbsp;&nbsp;0x00</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a08b7198f8d99e2f00b912ae94f25d088">XAXIPCIE_VSEC2</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#acd9a5078571848df63efc237fac1a672">XAxiPcie_GetRequestId</a>&nbsp;&nbsp;&nbsp;XAxiPcie_GetRequesterId</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a08e3f639ed3ca042d429630fec260654">XAxiPcie_IsLinkUp</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a4eff130db70eebadac90b43cbd2561fa">XAxiPcie_IsEcamBusy</a>(InstancePtr)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a911e4cd0c119271f6c01c9b1ac827df1">XAxiPcie_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#ad3cc0935e856f755e3eea92f29a87ca8">XAxiPcie_CfgInitialize</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, <a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a> *CfgPtr, u32 EffectiveAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a745d2811e366fbe0e5499cfef90adbcc">XAxiPcie_GetVsecCapability</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *VersionPtr, u16 *NextCapPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#aa26f5255cb42e55351c7cb802f71d56c">XAxiPcie_GetVsecHeader</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *RevisionPtr, u16 *LengthPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a75ca6a068024666c0199ea90d3ce4276">XAxiPcie_GetBridgeInfo</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 *Gen2Ptr, u8 *RootPortPtr, u8 *ECAMSizePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a77063428b5641d07910419770813c148">XAxiPcie_GetRequesterId</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 *BusNumPtr, u8 *DevNumPtr, u8 *FunNumPtr, u8 *PortNumPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a372301905fec6833c06320fb45261cd7">XAxiPcie_GetPhyStatusCtrl</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 *PhyState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a0899628f4ecfb6d3b05671933c375ae5">XAxiPcie_GetRootPortStatusCtrl</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 *StatusPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a2860cd7b0180a99fb324c085fc8fa746">XAxiPcie_SetRootPortStatusCtrl</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 StatusData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a0ce4f790929f629f225c2ef2fbcc2647">XAxiPcie_SetRootPortMSIBase</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, unsigned long long MsiBase)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a32604cb99f7d35107ee59ff121e0024d">XAxiPcie_GetRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 *ReqIdPtr, u8 *ErrType, u8 *ErrValid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a225811fdbd9b22b8208a83ca4d3818ce">XAxiPcie_ClearRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a8b13520d9f4472bc16cfa5a6266f6795">XAxiPcie_GetRootPortIntFIFOReg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 *ReqIdPtr, u16 *MsiAddr, u8 *MsiInt, u8 *IntValid, u16 *MsiMsgData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a4b043d41a5668f97f83518327023ea0d">XAxiPcie_ClearRootPortIntFIFOReg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a19d8a1973231160bdd518b1c62bda3d4">XAxiPcie_GetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a51ee29d03fbefc82b9208f46a12d5a06">XAxiPcie_SetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#ad9494095b9350f455af9e7da5375d522">XAxiPcie_ReadLocalConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 Offset, u32 *DataPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#afbdf9a7e71effb96353079d1c177888b">XAxiPcie_WriteLocalConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 Offset, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#ae4aafc6b1766352ed5347e40762f0649">XAxiPcie_ReadRemoteConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 *DataPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#adb4d67df95f1c7b0010e370312283f22">XAxiPcie_WriteRemoteConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a062809d176f81251886d5372c0714f7a">XAxiPcie_EnableGlobalInterrupt</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#aace3ba2f6c70cd207c9c65d92c634ee8">XAxiPcie_DisableGlobalInterrupt</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#a22a95261655e78a944d1a2462031da57">XAxiPcie_EnableInterrupts</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 EnableMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#ae238cf115bd039e0f7228e385c893aad">XAxiPcie_DisableInterrupts</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 DisableMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#ae118e9d7fd6b78ca0b8d4fd6694f9808">XAxiPcie_GetEnabledInterrupts</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 *EnabledMaskPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#aec39c65db1aeac38798a250a25298208">XAxiPcie_GetPendingInterrupts</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 *PendingMaskPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8h.html#abdf66d0cb481a5eea62e1f98e71d9520">XAxiPcie_ClearPendingInterrupts</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 ClearMask)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="afa73b84cb240d4b683d33ed8e48f4f49"></a><!-- doxytag: member="xaxipcie.h::ALIGN_4KB" ref="afa73b84cb240d4b683d33ed8e48f4f49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGN_4KB&nbsp;&nbsp;&nbsp;0xFFFFF000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acd9a5078571848df63efc237fac1a672"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetRequestId" ref="acd9a5078571848df63efc237fac1a672" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiPcie_GetRequestId&nbsp;&nbsp;&nbsp;XAxiPcie_GetRequesterId</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a02ad1a5f3d0ed294888c77c60b229a3b"></a><!-- doxytag: member="xaxipcie.h::XAXIPCIE_H" ref="a02ad1a5f3d0ed294888c77c60b229a3b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXIPCIE_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea6bdd6f359208f120597390fe6cad0b"></a><!-- doxytag: member="xaxipcie.h::XAXIPCIE_IS_RC" ref="aea6bdd6f359208f120597390fe6cad0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXIPCIE_IS_RC&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4eff130db70eebadac90b43cbd2561fa"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_IsEcamBusy" ref="a4eff130db70eebadac90b43cbd2561fa" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiPcie_IsEcamBusy</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xaxipcie__hw_8h.html#ab5e38a3a5815c463c52461a8f7f52b75">XAxiPcie_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,    \
        <a class="code" href="xaxipcie__hw_8h.html#a10e385edef3931106642fcf07d5a5fec">XAXIPCIE_BSC_OFFSET</a>) &amp; <a class="code" href="xaxipcie__hw_8h.html#abfb6e478c3f181fcec8e4918f9442296">XAXIPCIE_BSC_ECAM_BUSY_MASK</a>) ? TRUE : FALSE
</pre></div><p>Check whether ECAM is busy or not.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if ECAM is busy</li>
<li>FALSE if ECAM is idel</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex </dd></dl>

</div>
</div>
<a class="anchor" id="a08e3f639ed3ca042d429630fec260654"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_IsLinkUp" ref="a08e3f639ed3ca042d429630fec260654" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiPcie_IsLinkUp</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xaxipcie__hw_8h.html#ab5e38a3a5815c463c52461a8f7f52b75">XAxiPcie_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,    \
        <a class="code" href="xaxipcie__hw_8h.html#a84f89f155288e2a5de41a09bdf5d8672">XAXIPCIE_PHYSC_OFFSET</a>) &amp; <a class="code" href="xaxipcie__hw_8h.html#a1b1c63c3222b1c3585b7b7ba73a46db8">XAXIPCIE_PHYSC_LINK_UP_MASK</a>) ? TRUE : FALSE
</pre></div><p>Check whether link is up or not.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if link is up</li>
<li>FALSE if link is down</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a7e5fb7cdef729030bf31e9c3651253b1"></a><!-- doxytag: member="xaxipcie.h::XAXIPCIE_VSEC1" ref="a7e5fb7cdef729030bf31e9c3651253b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXIPCIE_VSEC1&nbsp;&nbsp;&nbsp;0x00</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First VSEC Register </p>

</div>
</div>
<a class="anchor" id="a08b7198f8d99e2f00b912ae94f25d088"></a><!-- doxytag: member="xaxipcie.h::XAXIPCIE_VSEC2" ref="a08b7198f8d99e2f00b912ae94f25d088" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXIPCIE_VSEC2&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Second VSEC Register </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad3cc0935e856f755e3eea92f29a87ca8"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_CfgInitialize" ref="ad3cc0935e856f755e3eea92f29a87ca8" args="(XAxiPcie *InstancePtr, XAxiPcie_Config *CfgPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiPcie_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance provided by the caller based on the given Config structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on.The memory of the pointer references must be pre-allocated by the caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment.It is the Base Address in a stand alone environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS Initialization was successful.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abdf66d0cb481a5eea62e1f98e71d9520"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_ClearPendingInterrupts" ref="abdf66d0cb481a5eea62e1f98e71d9520" args="(XAxiPcie *InstancePtr, u32 ClearMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ClearPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ClearMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear the currently pending interrupt bits of the IP passed from the caller into "ClearMask".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ClearMask</em>&nbsp;</td><td>is the bit pattern for pending interrupts wanted to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a225811fdbd9b22b8208a83ca4d3818ce"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_ClearRootPortErrFIFOMsg" ref="a225811fdbd9b22b8208a83ca4d3818ce" args="(XAxiPcie *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ClearRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear Root Port Error FIFO Message</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b043d41a5668f97f83518327023ea0d"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_ClearRootPortIntFIFOReg" ref="a4b043d41a5668f97f83518327023ea0d" args="(XAxiPcie *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ClearRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear Root Port FIFO Interrupt message Register 1 &amp; 2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex.Clearing any one Interrupt FIFO register clears both registers. </dd></dl>

</div>
</div>
<a class="anchor" id="aace3ba2f6c70cd207c9c65d92c634ee8"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_DisableGlobalInterrupt" ref="aace3ba2f6c70cd207c9c65d92c634ee8" args="(XAxiPcie *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_DisableGlobalInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable the Global Interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This bit is in the Bridge Status and Control Register. </dd></dl>

</div>
</div>
<a class="anchor" id="ae238cf115bd039e0f7228e385c893aad"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_DisableInterrupts" ref="ae238cf115bd039e0f7228e385c893aad" args="(XAxiPcie *InstancePtr, u32 DisableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_DisableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DisableMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable the IP interrupt bits passed into "DisableMask".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DisableMask</em>&nbsp;</td><td>is the bit pattern for interrupts wanted to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If an interrupt is already disabled before calling this function, it will stay disabled regardless of the value of "DisableMask" passed from the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a062809d176f81251886d5372c0714f7a"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_EnableGlobalInterrupt" ref="a062809d176f81251886d5372c0714f7a" args="(XAxiPcie *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_EnableGlobalInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the Global Interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This bit is in the Bridge Status and Control Register. </dd></dl>

</div>
</div>
<a class="anchor" id="a22a95261655e78a944d1a2462031da57"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_EnableInterrupts" ref="a22a95261655e78a944d1a2462031da57" args="(XAxiPcie *InstancePtr, u32 EnableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_EnableInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EnableMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the IP interrupt bits passed into "EnableMask".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EnableMask</em>&nbsp;</td><td>is the bit pattern for interrupts wanted to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If an interrupt is already enabled before calling this function, it will stay enabled regardless of the value of "EnableMask" passed from the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a75ca6a068024666c0199ea90d3ce4276"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetBridgeInfo" ref="a75ca6a068024666c0199ea90d3ce4276" args="(XAxiPcie *InstancePtr, u8 *Gen2Ptr, u8 *RootPortPtr, u8 *ECAMSizePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetBridgeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Gen2Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RootPortPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ECAMSizePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API Reads the Bridge info register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Gen2Ptr</em>&nbsp;</td><td>is a pointer to a variable indicating whether underlying PCIe block support PCIe Gen2 Speed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RootPortPtr</em>&nbsp;</td><td>is a pointer to a variable indication whether underlying PCIe block is root port. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ECAMSizePtr</em>&nbsp;</td><td>is a pointer to a variable where it indicates ECAM size. Value is between 1 to 8. Total address bits dedicated to ECAM is 20 + ECAM size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ae118e9d7fd6b78ca0b8d4fd6694f9808"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetEnabledInterrupts" ref="ae118e9d7fd6b78ca0b8d4fd6694f9808" args="(XAxiPcie *InstancePtr, u32 *EnabledMaskPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetEnabledInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>EnabledMaskPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the currently enabled interrupt bits of the IP and pass them back to the caller into "EnabledMask".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EnabledMaskPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the enabled interrupt bits after reading them from IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a19d8a1973231160bdd518b1c62bda3d4"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetLocalBusBar2PcieBar" ref="a19d8a1973231160bdd518b1c62bda3d4" args="(XAxiPcie *InstancePtr, u8 BarNumber, XAxiPcie_BarAddr *BarAddrPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *&nbsp;</td>
          <td class="paramname"> <em>BarAddrPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarNumber</em>&nbsp;</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarAddrPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will . pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aec39c65db1aeac38798a250a25298208"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetPendingInterrupts" ref="aec39c65db1aeac38798a250a25298208" args="(XAxiPcie *InstancePtr, u32 *PendingMaskPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetPendingInterrupts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>PendingMaskPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the currently pending interrupt bits of the IP and pass them back to the caller into "PendingMask".</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PendingMaskPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the pending interrupt bits after reading them from IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a372301905fec6833c06320fb45261cd7"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetPhyStatusCtrl" ref="a372301905fec6833c06320fb45261cd7" args="(XAxiPcie *InstancePtr, u32 *PhyState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetPhyStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>PhyState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to read the Phy Status/Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyState</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back Current physical status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a77063428b5641d07910419770813c148"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetRequesterId" ref="a77063428b5641d07910419770813c148" args="(XAxiPcie *InstancePtr, u8 *BusNumPtr, u8 *DevNumPtr, u8 *FunNumPtr, u8 *PortNumPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetRequesterId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BusNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DevNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>FunNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>PortNumPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the Bus Location register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BusNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the bus number of requester ID assigned to IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DevNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the device number of requester ID assigned to IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FunNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the function number of requester ID assigned to IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PortNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Port number of requester ID assigned to IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a32604cb99f7d35107ee59ff121e0024d"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetRootPortErrFIFOMsg" ref="a32604cb99f7d35107ee59ff121e0024d" args="(XAxiPcie *InstancePtr, u16 *ReqIdPtr, u8 *ErrType, u8 *ErrValid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ErrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ErrValid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read Root Port Error FIFO Message</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReqIdPtr</em>&nbsp;</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ErrType</em>&nbsp;</td><td>is a variable where the driver will pass back the type of error message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ErrValid</em>&nbsp;</td><td>is a variable where the driver will pass back the status of read operation of error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b13520d9f4472bc16cfa5a6266f6795"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetRootPortIntFIFOReg" ref="a8b13520d9f4472bc16cfa5a6266f6795" args="(XAxiPcie *InstancePtr, u16 *ReqIdPtr, u16 *MsiAddr, u8 *MsiInt, u8 *IntValid, u16 *MsiMsgData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiPcie_GetRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>MsiAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsiInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>IntValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>MsiMsgData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read Root Port Interrupt FIFO message Register 1 &amp; 2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReqIdPtr</em>&nbsp;</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiAddr</em>&nbsp;</td><td>is a variable where the driver will pass back the MSI address for which interrupt message recieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiInt</em>&nbsp;</td><td>is a variable where the driver will pass back the type of interrupt message recieved (MSI/INTx). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntValid</em>&nbsp;</td><td>is a variable where the driver will pass back the status of read operation of interrupt message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiMsgData</em>&nbsp;</td><td>is a variable where the driver will pass back the MSI data recieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>MsiMsgData if MSI interrupt is observed or 0 if there is no MSI interrupt.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a0899628f4ecfb6d3b05671933c375ae5"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetRootPortStatusCtrl" ref="a0899628f4ecfb6d3b05671933c375ae5" args="(XAxiPcie *InstancePtr, u32 *StatusPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>StatusPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read Root Port Status/Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the root port status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a745d2811e366fbe0e5499cfef90adbcc"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetVsecCapability" ref="a745d2811e366fbe0e5499cfef90adbcc" args="(XAxiPcie *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *VersionPtr, u16 *NextCapPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetVsecCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>VersionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>NextCapPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to read the VSEC Capability Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecNum</em>&nbsp;</td><td>is a VSEC register number as there are two registers. Possible values are.</p>
<ul>
<li>XAXIPCIE_VSEC1 (0)</li>
<li>XAXIPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecIdPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Vendor Specific Enhanced Capability ID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will . pass back the Version of VSEC. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NextCapPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Next Capability offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aa26f5255cb42e55351c7cb802f71d56c"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_GetVsecHeader" ref="aa26f5255cb42e55351c7cb802f71d56c" args="(XAxiPcie *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *RevisionPtr, u16 *LengthPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetVsecHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RevisionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>LengthPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to read the VSEC Header Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecNum</em>&nbsp;</td><td>is a VSEC register number as there are two registers. Possible values are.</p>
<ul>
<li>XAXIPCIE_VSEC1 (0)</li>
<li>XAXIPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecIdPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the VSEC header structure Id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RevisionPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Revision of VSEC capability Structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LengthPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass . back the length of the VSEC capability structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a911e4cd0c119271f6c01c9b1ac827df1"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_LookupConfig" ref="a911e4cd0c119271f6c01c9b1ac827df1" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a>* XAxiPcie_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lookup the device configuration based on the unique device ID. The table ConfigTable contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the device identifier to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> configuration structure pointer if DeviceID is found.</li>
<li>NULL if DeviceID is not found.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ad9494095b9350f455af9e7da5375d522"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_ReadLocalConfigSpace" ref="ad9494095b9350f455af9e7da5375d522" args="(XAxiPcie *InstancePtr, u16 Offset, u32 *DataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ReadLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 32-bit value from one of this IP own configuration space. Location is identified by its offset from the beginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beginning of IP own configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ae4aafc6b1766352ed5347e40762f0649"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_ReadRemoteConfigSpace" ref="ae4aafc6b1766352ed5347e40762f0649" args="(XAxiPcie *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 *DataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ReadRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 32-bit value from external PCIe Function's configuration space. External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the begginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bus</em>&nbsp;</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Device</em>&nbsp;</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Function</em>&nbsp;</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. The XAxiPcie_ReadLocalConfigSpace API should be used for reading the local config space. </dd></dl>

</div>
</div>
<a class="anchor" id="a51ee29d03fbefc82b9208f46a12d5a06"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_SetLocalBusBar2PcieBar" ref="a51ee29d03fbefc82b9208f46a12d5a06" args="(XAxiPcie *InstancePtr, u8 BarNumber, XAxiPcie_BarAddr *BarAddrPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_SetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *&nbsp;</td>
          <td class="paramname"> <em>BarAddrPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarNumber</em>&nbsp;</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarAddrPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ce4f790929f629f225c2ef2fbcc2647"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_SetRootPortMSIBase" ref="a0ce4f790929f629f225c2ef2fbcc2647" args="(XAxiPcie *InstancePtr, unsigned long long MsiBase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiPcie_SetRootPortMSIBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>MsiBase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write MSI Base Address to Root Port MSI Base Address Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiBase</em>&nbsp;</td><td>is 64 bit base address for MSI.This address should be 4kB aligned always.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS if success or XST_FAILURE if failure .</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a2860cd7b0180a99fb324c085fc8fa746"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_SetRootPortStatusCtrl" ref="a2860cd7b0180a99fb324c085fc8fa746" args="(XAxiPcie *InstancePtr, u32 StatusData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_SetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>StatusData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write Value in Root Port Status/Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusData</em>&nbsp;</td><td>is data to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="afbdf9a7e71effb96353079d1c177888b"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_WriteLocalConfigSpace" ref="afbdf9a7e71effb96353079d1c177888b" args="(XAxiPcie *InstancePtr, u16 Offset, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_WriteLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 32-bit value to one of this IP own configuration space. Location is identified by its offset from the begginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beggininng of IP own configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="adb4d67df95f1c7b0010e370312283f22"></a><!-- doxytag: member="xaxipcie.h::XAxiPcie_WriteRemoteConfigSpace" ref="adb4d67df95f1c7b0010e370312283f22" args="(XAxiPcie *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_WriteRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 32-bit value to external PCIe function's configuration space. External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the begginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bus</em>&nbsp;</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Device</em>&nbsp;</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Function</em>&nbsp;</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. The XAxiPcie_WriteLocalConfigSpace should be used for writing to local config space. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
