<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver axipcie v3_0: xaxipcie.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xaxipcie.c File Reference</h1><code>#include &quot;<a class="el" href="xaxipcie_8h.html">xaxipcie.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#ad3cc0935e856f755e3eea92f29a87ca8">XAxiPcie_CfgInitialize</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, <a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a> *CfgPtr, u32 EffectiveAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a745d2811e366fbe0e5499cfef90adbcc">XAxiPcie_GetVsecCapability</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *VersionPtr, u16 *NextCapPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#aa26f5255cb42e55351c7cb802f71d56c">XAxiPcie_GetVsecHeader</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *RevisionPtr, u16 *LengthPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a75ca6a068024666c0199ea90d3ce4276">XAxiPcie_GetBridgeInfo</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 *Gen2Ptr, u8 *RootPortPtr, u8 *ECAMSizePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a77063428b5641d07910419770813c148">XAxiPcie_GetRequesterId</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 *BusNumPtr, u8 *DevNumPtr, u8 *FunNumPtr, u8 *PortNumPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a372301905fec6833c06320fb45261cd7">XAxiPcie_GetPhyStatusCtrl</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 *PhyState)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a0899628f4ecfb6d3b05671933c375ae5">XAxiPcie_GetRootPortStatusCtrl</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 *StatusPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a2860cd7b0180a99fb324c085fc8fa746">XAxiPcie_SetRootPortStatusCtrl</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u32 StatusData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a0ce4f790929f629f225c2ef2fbcc2647">XAxiPcie_SetRootPortMSIBase</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, unsigned long long MsiBase)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a32604cb99f7d35107ee59ff121e0024d">XAxiPcie_GetRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 *ReqIdPtr, u8 *ErrType, u8 *ErrValid)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a225811fdbd9b22b8208a83ca4d3818ce">XAxiPcie_ClearRootPortErrFIFOMsg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a8b13520d9f4472bc16cfa5a6266f6795">XAxiPcie_GetRootPortIntFIFOReg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 *ReqIdPtr, u16 *MsiAddr, u8 *MsiInt, u8 *IntValid, u16 *MsiMsgData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a4b043d41a5668f97f83518327023ea0d">XAxiPcie_ClearRootPortIntFIFOReg</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a19d8a1973231160bdd518b1c62bda3d4">XAxiPcie_GetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a51ee29d03fbefc82b9208f46a12d5a06">XAxiPcie_SetLocalBusBar2PcieBar</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 BarNumber, <a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *BarAddrPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#ad9494095b9350f455af9e7da5375d522">XAxiPcie_ReadLocalConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 Offset, u32 *DataPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#afbdf9a7e71effb96353079d1c177888b">XAxiPcie_WriteLocalConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u16 Offset, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#a4bc61bf643e9bb9675f4570865c5c6d6">XAxiPcie_ComposeExternalConfigAddress</a> (u8 Bus, u8 Device, u8 Function, u16 Offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#ae4aafc6b1766352ed5347e40762f0649">XAxiPcie_ReadRemoteConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 *DataPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxipcie_8c.html#adb4d67df95f1c7b0010e370312283f22">XAxiPcie_WriteRemoteConfigSpace</a> (<a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 Data)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad3cc0935e856f755e3eea92f29a87ca8"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_CfgInitialize" ref="ad3cc0935e856f755e3eea92f29a87ca8" args="(XAxiPcie *InstancePtr, XAxiPcie_Config *CfgPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiPcie_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie___config.html">XAxiPcie_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance provided by the caller based on the given Config structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on.The memory of the pointer references must be pre-allocated by the caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the device configuration structure containing required HW build data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the Physical address of the hardware in a Virtual Memory operating system environment.It is the Base Address in a stand alone environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS Initialization was successful.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a225811fdbd9b22b8208a83ca4d3818ce"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_ClearRootPortErrFIFOMsg" ref="a225811fdbd9b22b8208a83ca4d3818ce" args="(XAxiPcie *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ClearRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear Root Port Error FIFO Message</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b043d41a5668f97f83518327023ea0d"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_ClearRootPortIntFIFOReg" ref="a4b043d41a5668f97f83518327023ea0d" args="(XAxiPcie *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ClearRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear Root Port FIFO Interrupt message Register 1 &amp; 2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex.Clearing any one Interrupt FIFO register clears both registers. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bc61bf643e9bb9675f4570865c5c6d6"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_ComposeExternalConfigAddress" ref="a4bc61bf643e9bb9675f4570865c5c6d6" args="(u8 Bus, u8 Device, u8 Function, u16 Offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAxiPcie_ComposeExternalConfigAddress </td>
          <td>(</td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a75ca6a068024666c0199ea90d3ce4276"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetBridgeInfo" ref="a75ca6a068024666c0199ea90d3ce4276" args="(XAxiPcie *InstancePtr, u8 *Gen2Ptr, u8 *RootPortPtr, u8 *ECAMSizePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetBridgeInfo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Gen2Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RootPortPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ECAMSizePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API Reads the Bridge info register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Gen2Ptr</em>&nbsp;</td><td>is a pointer to a variable indicating whether underlying PCIe block support PCIe Gen2 Speed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RootPortPtr</em>&nbsp;</td><td>is a pointer to a variable indication whether underlying PCIe block is root port. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ECAMSizePtr</em>&nbsp;</td><td>is a pointer to a variable where it indicates ECAM size. Value is between 1 to 8. Total address bits dedicated to ECAM is 20 + ECAM size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a19d8a1973231160bdd518b1c62bda3d4"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetLocalBusBar2PcieBar" ref="a19d8a1973231160bdd518b1c62bda3d4" args="(XAxiPcie *InstancePtr, u8 BarNumber, XAxiPcie_BarAddr *BarAddrPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *&nbsp;</td>
          <td class="paramname"> <em>BarAddrPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarNumber</em>&nbsp;</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarAddrPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will . pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a372301905fec6833c06320fb45261cd7"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetPhyStatusCtrl" ref="a372301905fec6833c06320fb45261cd7" args="(XAxiPcie *InstancePtr, u32 *PhyState)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetPhyStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>PhyState</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to read the Phy Status/Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyState</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back Current physical status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a77063428b5641d07910419770813c148"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetRequesterId" ref="a77063428b5641d07910419770813c148" args="(XAxiPcie *InstancePtr, u8 *BusNumPtr, u8 *DevNumPtr, u8 *FunNumPtr, u8 *PortNumPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetRequesterId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BusNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DevNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>FunNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>PortNumPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read the Bus Location register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BusNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the bus number of requester ID assigned to IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DevNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the device number of requester ID assigned to IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FunNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the function number of requester ID assigned to IP. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PortNumPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Port number of requester ID assigned to IP.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a32604cb99f7d35107ee59ff121e0024d"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetRootPortErrFIFOMsg" ref="a32604cb99f7d35107ee59ff121e0024d" args="(XAxiPcie *InstancePtr, u16 *ReqIdPtr, u8 *ErrType, u8 *ErrValid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetRootPortErrFIFOMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ErrType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ErrValid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read Root Port Error FIFO Message</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReqIdPtr</em>&nbsp;</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ErrType</em>&nbsp;</td><td>is a variable where the driver will pass back the type of error message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ErrValid</em>&nbsp;</td><td>is a variable where the driver will pass back the status of read operation of error message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b13520d9f4472bc16cfa5a6266f6795"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetRootPortIntFIFOReg" ref="a8b13520d9f4472bc16cfa5a6266f6795" args="(XAxiPcie *InstancePtr, u16 *ReqIdPtr, u16 *MsiAddr, u8 *MsiInt, u8 *IntValid, u16 *MsiMsgData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiPcie_GetRootPortIntFIFOReg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>ReqIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>MsiAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsiInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>IntValid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>MsiMsgData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read Root Port Interrupt FIFO message Register 1 &amp; 2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReqIdPtr</em>&nbsp;</td><td>is a variable where the driver will pass back the requester Id of error message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiAddr</em>&nbsp;</td><td>is a variable where the driver will pass back the MSI address for which interrupt message recieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiInt</em>&nbsp;</td><td>is a variable where the driver will pass back the type of interrupt message recieved (MSI/INTx). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntValid</em>&nbsp;</td><td>is a variable where the driver will pass back the status of read operation of interrupt message. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiMsgData</em>&nbsp;</td><td>is a variable where the driver will pass back the MSI data recieved.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>MsiMsgData if MSI interrupt is observed or 0 if there is no MSI interrupt.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a0899628f4ecfb6d3b05671933c375ae5"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetRootPortStatusCtrl" ref="a0899628f4ecfb6d3b05671933c375ae5" args="(XAxiPcie *InstancePtr, u32 *StatusPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>StatusPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read Root Port Status/Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the root port status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a745d2811e366fbe0e5499cfef90adbcc"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetVsecCapability" ref="a745d2811e366fbe0e5499cfef90adbcc" args="(XAxiPcie *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *VersionPtr, u16 *NextCapPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetVsecCapability </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>VersionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>NextCapPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to read the VSEC Capability Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecNum</em>&nbsp;</td><td>is a VSEC register number as there are two registers. Possible values are.</p>
<ul>
<li>XAXIPCIE_VSEC1 (0)</li>
<li>XAXIPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecIdPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Vendor Specific Enhanced Capability ID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VersionPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will . pass back the Version of VSEC. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NextCapPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Next Capability offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="aa26f5255cb42e55351c7cb802f71d56c"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_GetVsecHeader" ref="aa26f5255cb42e55351c7cb802f71d56c" args="(XAxiPcie *InstancePtr, u8 VsecNum, u16 *VsecIdPtr, u8 *RevisionPtr, u16 *LengthPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_GetVsecHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VsecNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>VsecIdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RevisionPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>LengthPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This API is used to read the VSEC Header Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecNum</em>&nbsp;</td><td>is a VSEC register number as there are two registers. Possible values are.</p>
<ul>
<li>XAXIPCIE_VSEC1 (0)</li>
<li>XAXIPCIE_VSEC2 (1) </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VsecIdPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the VSEC header structure Id. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RevisionPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the Revision of VSEC capability Structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LengthPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass . back the length of the VSEC capability structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ad9494095b9350f455af9e7da5375d522"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_ReadLocalConfigSpace" ref="ad9494095b9350f455af9e7da5375d522" args="(XAxiPcie *InstancePtr, u16 Offset, u32 *DataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ReadLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 32-bit value from one of this IP own configuration space. Location is identified by its offset from the beginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beginning of IP own configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ae4aafc6b1766352ed5347e40762f0649"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_ReadRemoteConfigSpace" ref="ae4aafc6b1766352ed5347e40762f0649" args="(XAxiPcie *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 *DataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_ReadRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 32-bit value from external PCIe Function's configuration space. External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the begginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bus</em>&nbsp;</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Device</em>&nbsp;</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Function</em>&nbsp;</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back the value read from the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. The XAxiPcie_ReadLocalConfigSpace API should be used for reading the local config space. </dd></dl>

</div>
</div>
<a class="anchor" id="a51ee29d03fbefc82b9208f46a12d5a06"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_SetLocalBusBar2PcieBar" ref="a51ee29d03fbefc82b9208f46a12d5a06" args="(XAxiPcie *InstancePtr, u8 BarNumber, XAxiPcie_BarAddr *BarAddrPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_SetLocalBusBar2PcieBar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BarNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie___bar_addr.html">XAxiPcie_BarAddr</a> *&nbsp;</td>
          <td class="paramname"> <em>BarAddrPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write PCIe address translation vector that corresponds to one of AXI local bus bars passed by the caller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the <a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarNumber</em>&nbsp;</td><td>is AXI bar number (0 - 5) passed by caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BarAddrPtr</em>&nbsp;</td><td>is a pointer to a variable where the driver will pass back translation vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ce4f790929f629f225c2ef2fbcc2647"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_SetRootPortMSIBase" ref="a0ce4f790929f629f225c2ef2fbcc2647" args="(XAxiPcie *InstancePtr, unsigned long long MsiBase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiPcie_SetRootPortMSIBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&nbsp;</td>
          <td class="paramname"> <em>MsiBase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write MSI Base Address to Root Port MSI Base Address Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsiBase</em>&nbsp;</td><td>is 64 bit base address for MSI.This address should be 4kB aligned always.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS if success or XST_FAILURE if failure .</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="a2860cd7b0180a99fb324c085fc8fa746"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_SetRootPortStatusCtrl" ref="a2860cd7b0180a99fb324c085fc8fa746" args="(XAxiPcie *InstancePtr, u32 StatusData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_SetRootPortStatusCtrl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>StatusData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write Value in Root Port Status/Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusData</em>&nbsp;</td><td>is data to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="afbdf9a7e71effb96353079d1c177888b"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_WriteLocalConfigSpace" ref="afbdf9a7e71effb96353079d1c177888b" args="(XAxiPcie *InstancePtr, u16 Offset, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_WriteLocalConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 32-bit value to one of this IP own configuration space. Location is identified by its offset from the begginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beggininng of IP own configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. </dd></dl>

</div>
</div>
<a class="anchor" id="adb4d67df95f1c7b0010e370312283f22"></a><!-- doxytag: member="xaxipcie.c::XAxiPcie_WriteRemoteConfigSpace" ref="adb4d67df95f1c7b0010e370312283f22" args="(XAxiPcie *InstancePtr, u8 Bus, u8 Device, u8 Function, u16 Offset, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiPcie_WriteRemoteConfigSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_pcie.html">XAxiPcie</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Bus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 32-bit value to external PCIe function's configuration space. External PCIe function is identified by its Requester ID (Bus#, Device#, Function#). Location is identified by its offset from the begginning of the configuration space.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the PCIe component to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bus</em>&nbsp;</td><td>is the external PCIe function's Bus number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Device</em>&nbsp;</td><td>is the external PCIe function's Device number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Function</em>&nbsp;</td><td>is the external PCIe function's Function number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>from beggininng of PCIe function's configuration space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>to be written to the specified location.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is valid only when IP is configured as a root complex. The XAxiPcie_WriteLocalConfigSpace should be used for writing to local config space. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
