<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver llfifo v4_0: xllfifo.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xllfifo.h File Reference</h1><code>#include &quot;<a class="el" href="xstreamer_8h.html">xstreamer.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xllfifo__hw_8h.html">xllfifo_hw.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_ll_fifo___config.html">XLlFifo_Config</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ae7e2d915a0bab3a686ef155a6523690c">XLLFIFO_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ace8f47c03f1818797c152cb27296df7c">XLlFifo_Reset</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a095f3e0f8571dc02959852e38237f23e">XLlFifo_Status</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XLlFifo_ReadReg((InstancePtr)-&gt;BaseAddress, XLLF_ISR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ae65ece5c6c9cce1ccdcf9d404fd8f463">XLlFifo_IntEnable</a>(InstancePtr, Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#abff8f5ef31f09865808da90055e29d42">XLlFifo_IntDisable</a>(InstancePtr, Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ac356d3e8d55aa6e82753400f0bd026a1">XLlFifo_IntPending</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ac712eea89e9d7fa37d095003c927c61e">XLlFifo_IntClear</a>(InstancePtr, Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#af3739a78b92f17cead0d831757b3a134">XLlFifo_RxReset</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#aba876eb888126638848fb2f89a9b4436">XLlFifo_IsRxEmpty</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a12da547aa1c9a85e2b0b151f438ff9d5">XLlFifo_RxOccupancy</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XStrm_RxOccupancy(&amp;((InstancePtr)-&gt;RxStreamer))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a53af32ae6901462cc8d6fb9adc04655e">XLlFifo_RxGetLen</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XStrm_RxGetLen(&amp;((InstancePtr)-&gt;RxStreamer))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#aadc3685592b060c0d864850e86be5c03">XLlFifo_Read</a>(InstancePtr, BufPtr, Bytes)&nbsp;&nbsp;&nbsp;XStrm_Read(&amp;((InstancePtr)-&gt;RxStreamer), (BufPtr), (Bytes))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a922419fdcd342fa709fb07ec1a9e5577">XLlFifo_TxReset</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a869bc4c1072da021e747a0a179bfe2da">XLlFifo_IsTxDone</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a556524c17aee71ae8407540a5e2cd65f">XLlFifo_IsRxDone</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#af2884c49ae41dc5c5317c2ef6df45a28">XLlFifo_TxVacancy</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XStrm_TxVacancy(&amp;((InstancePtr)-&gt;TxStreamer))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#acd09ed5189e0b85994901102655964f7">XLlFifo_TxSetLen</a>(InstancePtr, Bytes)&nbsp;&nbsp;&nbsp;XStrm_TxSetLen(&amp;((InstancePtr)-&gt;TxStreamer), (Bytes))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a1fa93f486abaaf35c7d599a8cd91b295">XLlFifo_Write</a>(InstancePtr, BufPtr, Bytes)&nbsp;&nbsp;&nbsp;XStrm_Write(&amp;((InstancePtr)-&gt;TxStreamer), (BufPtr), (Bytes))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a105828f79f13c07d571db218c5837fae">XLlFifo_WriteTdr</a>(InstancePtr, Tdest)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a59307ef23e5b4b71d0d01cef8e06e247">XLlFifo_ReadRdr</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XLlFifo_ReadReg((InstancePtr)-&gt;BaseAddress, XLLF_RDR_OFFSET)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#adc1db2785627a0d8da46dc60990889a0">XLlFifo_CfgInitialize</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, <a class="el" href="struct_x_ll_fifo___config.html">XLlFifo_Config</a> *Config, u32 EffectiveAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a1fdf07ca198f5cfe2dc14ced21e5631d">XLlFifo_Initialize</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, u32 BaseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_ll_fifo___config.html">XLlFifo_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#adeafd207ee98a329f48eea9769b0994d">XLlFfio_LookupConfig</a> (u32 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ae2da9fa947a6e50edd41375ddc4c9964">XLlFifo_iRxOccupancy</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#aad292ddf2a2c9dde261b93da802c8080">XLlFifo_iRxGetLen</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#ac02405b23499d780e7bc1dfe371281a6">XLlFifo_iTxVacancy</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#aa49ecc1529434fd932d8a65d63a1a04d">XLlFifo_iTxSetLen</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, u32 Bytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#aed3ae31c8c24f46139fbd709027329ec">XLlFifo_RxGetWord</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xllfifo_8h.html#a29654d755dce84b861022179c99ca7a3">XLlFifo_TxPutWord</a> (<a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *InstancePtr, u32 Word)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ae7e2d915a0bab3a686ef155a6523690c"></a><!-- doxytag: member="xllfifo.h::XLLFIFO_H" ref="ae7e2d915a0bab3a686ef155a6523690c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLLFIFO_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac712eea89e9d7fa37d095003c927c61e"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IntClear" ref="ac712eea89e9d7fa37d095003c927c61e" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntClear</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>, \
                        ((Mask) &amp; <a class="code" href="xllfifo__hw_8h.html#ae3bfcad24428233d9e2a8a861e2d9eed">XLLF_INT_ALL_MASK</a>))
</pre></div><p>XLlFifo_IntClear clears pending interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>. The corresponding pending interrupt for each bit set to 1 in <em>Mask</em>, will be cleared. In other words, XLlFifo_IntClear uses the "set a bit to clear it" scheme.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the pending interrupts to clear. The mask can be formed using a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xllfifo_8h.html#ac712eea89e9d7fa37d095003c927c61e">XLlFifo_IntClear(XLlFifo *InstancePtr, u32 Mask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abff8f5ef31f09865808da90055e29d42"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IntDisable" ref="abff8f5ef31f09865808da90055e29d42" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntDisable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        u32 Reg = <a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, \
                        <a class="code" href="xllfifo__hw_8h.html#ac34e090e52a9ef5cdf4337cae6ca717c">XLLF_IER_OFFSET</a>); \
        Reg &amp;= ~((Mask) &amp; <a class="code" href="xllfifo__hw_8h.html#ae3bfcad24428233d9e2a8a861e2d9eed">XLLF_INT_ALL_MASK</a>);  \
        <a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#ac34e090e52a9ef5cdf4337cae6ca717c">XLLF_IER_OFFSET</a>, \
                        Reg); \
}
</pre></div><p>XLlFifo_IntDisable disables the interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be disabled. In other words, XLlFifo_IntDisable uses the "set a bit to clear it" scheme.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the interrupts to disable. The mask can be formed using a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xllfifo_8h.html#abff8f5ef31f09865808da90055e29d42">XLlFifo_IntDisable(XLlFifo *InstancePtr, u32 Mask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae65ece5c6c9cce1ccdcf9d404fd8f463"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IntEnable" ref="ae65ece5c6c9cce1ccdcf9d404fd8f463" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntEnable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        u32 Reg = <a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, \
                        <a class="code" href="xllfifo__hw_8h.html#ac34e090e52a9ef5cdf4337cae6ca717c">XLLF_IER_OFFSET</a>); \
        Reg |= ((Mask) &amp; <a class="code" href="xllfifo__hw_8h.html#ae3bfcad24428233d9e2a8a861e2d9eed">XLLF_INT_ALL_MASK</a>);                    \
        <a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#ac34e090e52a9ef5cdf4337cae6ca717c">XLLF_IER_OFFSET</a>, \
                        Reg); \
}
</pre></div><p>XLlFifo_IntEnable enables the interrupts specified in <em>Mask</em> for the FIFO specified by <em>InstancePtr</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the interrupts to enable. The mask can be formed using a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xllfifo_8h.html#ae65ece5c6c9cce1ccdcf9d404fd8f463">XLlFifo_IntEnable(XLlFifo *InstancePtr, u32 Mask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac356d3e8d55aa6e82753400f0bd026a1"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IntPending" ref="ac356d3e8d55aa6e82753400f0bd026a1" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IntPending</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#ac34e090e52a9ef5cdf4337cae6ca717c">XLLF_IER_OFFSET</a>) &amp;  \
         <a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>))
</pre></div><p>XLlFifo_IntPending returns a bit mask of the pending interrupts for the FIFO specified by <em>InstancePtr</em>. Each bit set to 1 in the return value represents a pending interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_IntPending returns a bit mask of the interrupts that are pending. The mask will be a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xllfifo_8h.html#ac356d3e8d55aa6e82753400f0bd026a1">XLlFifo_IntPending(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a556524c17aee71ae8407540a5e2cd65f"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IsRxDone" ref="a556524c17aee71ae8407540a5e2cd65f" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IsRxDone</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>) &amp; \
                <a class="code" href="xllfifo__hw_8h.html#a838f0b2d56bffea01160c141b0c1de67">XLLF_INT_RC_MASK</a>) \
                ? TRUE : FALSE)
</pre></div><p>XLlFifo_IsRxDone returns true if the reception in the receive channel of the FIFO, specified by <em>InstancePtr</em>, is complete. XLlFifo_IsRxDone works only if the RC bit in the ISR register is cleared before receiving a frame.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_IsRxDone returns TRUE when the receive channel of the FIFO is complete. Otherwise, XLlFifo_IsRxDone returns FALSE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: int <a class="el" href="xllfifo_8h.html#a556524c17aee71ae8407540a5e2cd65f">XLlFifo_IsRxDone(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aba876eb888126638848fb2f89a9b4436"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IsRxEmpty" ref="aba876eb888126638848fb2f89a9b4436" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IsRxEmpty</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a9c4bbf51bc4b0410b61ef3933776a63c">XLLF_RDFO_OFFSET</a>) == 0) \
                                                        ? TRUE : FALSE)
</pre></div><p>XLlFifo_IsRxEmpty returns true if the receive channel of the FIFO, specified by <em>InstancePtr</em>, is empty.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_IsRxEmpty returns TRUE when the receive channel of the FIFO is empty. Otherwise, XLlFifo_IsRxEmpty returns FALSE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: int <a class="el" href="xllfifo_8h.html#aba876eb888126638848fb2f89a9b4436">XLlFifo_IsRxEmpty(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a869bc4c1072da021e747a0a179bfe2da"></a><!-- doxytag: member="xllfifo.h::XLlFifo_IsTxDone" ref="a869bc4c1072da021e747a0a179bfe2da" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_IsTxDone</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xllfifo__hw_8h.html#a7526eab563fa4e0fe8b60474e96afe55">XLlFifo_ReadReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a90a5fafb06870a7ff8043d3a34bf54cc">XLLF_ISR_OFFSET</a>) &amp; \
                <a class="code" href="xllfifo__hw_8h.html#abca5de4c7fc02bcad56912a2919319ae">XLLF_INT_TC_MASK</a>) \
                ? TRUE : FALSE)
</pre></div><p>XLlFifo_IsTxDone returns true if the transmission in the transmit channel of the FIFO, specified by <em>InstancePtr</em>, is complete. XLlFifo_IsTxDone works only if the TC bit in the IS register is cleared before sending a frame.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_IsTxDone returns TRUE when the transmit channel of the FIFO is complete. Otherwise, XLlFifo_IsTxDone returns FALSE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: int <a class="el" href="xllfifo_8h.html#a869bc4c1072da021e747a0a179bfe2da">XLlFifo_IsTxDone(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aadc3685592b060c0d864850e86be5c03"></a><!-- doxytag: member="xllfifo.h::XLlFifo_Read" ref="aadc3685592b060c0d864850e86be5c03" args="(InstancePtr, BufPtr, Bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Read</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XStrm_Read(&amp;((InstancePtr)-&gt;RxStreamer), (BufPtr), (Bytes))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_Read reads <em>Bytes</em> bytes from the receive channel of the FIFO referenced by <em>InstancePtr</em> to the block of memory, referenced by <em>BufPtr</em>.</p>
<p>Care must be taken to ensure that the number of bytes read with one or more calls to <a class="el" href="xllfifo_8h.html#aadc3685592b060c0d864850e86be5c03">XLlFifo_Read()</a> does not exceed the number of bytes available given from the last call to <a class="el" href="xllfifo_8h.html#a53af32ae6901462cc8d6fb9adc04655e">XLlFifo_RxGetLen()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufPtr</em>&nbsp;</td><td>specifies the memory address to place the data read.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>specifies the number of bytes to read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Error handling is handled through hardware exceptions and interrupts.</dd></dl>
<p>C Signature: void <a class="el" href="xllfifo_8h.html#aadc3685592b060c0d864850e86be5c03">XLlFifo_Read(XLlFifo *InstancePtr, void *BufPtr, unsigned Bytes)</a> </p>

</div>
</div>
<a class="anchor" id="a59307ef23e5b4b71d0d01cef8e06e247"></a><!-- doxytag: member="xllfifo.h::XLlFifo_ReadRdr" ref="a59307ef23e5b4b71d0d01cef8e06e247" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_ReadRdr</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XLlFifo_ReadReg((InstancePtr)-&gt;BaseAddress, XLLF_RDR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_ReadTdr returns the contents of the Receive Destination Register(RDR).</p>
<p>The RDR contains destination address corresponding to the valid packet that is received. The RDR should only be read when a receive packet is available for processing (the receive occupancy is not zero). Once the RDR is read, the receive packet data should be read from the receive data FIFO before the RDR is read again. The RDR values are stored in the receive data FIFO by the AXI4-Stream FIFO core with the data of each packet. The RDR value for the subsequent packet to be processed is moved to the RDR when the previous RDR value has been read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Receive Destination address read from the RDR.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C Signature: u32 <a class="el" href="xllfifo_8h.html#a59307ef23e5b4b71d0d01cef8e06e247">XLlFifo_ReadRdr(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ace8f47c03f1818797c152cb27296df7c"></a><!-- doxytag: member="xllfifo.h::XLlFifo_Reset" ref="ace8f47c03f1818797c152cb27296df7c" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Reset</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a5331d2736e9b1b516b4262d8e3f11690">XLLF_LLR_OFFSET</a>, \
                        <a class="code" href="xllfifo__hw_8h.html#ad8b59856939038963e68acf4e2e2c47c">XLLF_LLR_RESET_MASK</a>)
</pre></div><p>XLlFifo_Reset resets both the Tx and Rx channels and the local link interface the FIFO specified by <em>InstancePtr</em>. XLlFifo_TxReset resets also sends a reset pulse to the downstream device (e.g. TEMAC). XLlFifo_Reset drops any bytes in the FIFO not yet retrieved. XLlFifo_Reset drops any bytes in the FIFO not yet transmitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xllfifo_8h.html#ace8f47c03f1818797c152cb27296df7c">XLlFifo_Reset(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a53af32ae6901462cc8d6fb9adc04655e"></a><!-- doxytag: member="xllfifo.h::XLlFifo_RxGetLen" ref="a53af32ae6901462cc8d6fb9adc04655e" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_RxGetLen</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XStrm_RxGetLen(&amp;((InstancePtr)-&gt;RxStreamer))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_RxGetLen notifies the hardware that the program is ready to receive the next frame from the receive channel of the FIFO, specified by <em>InstancePtr</em>.</p>
<p>Note that the program must first call XLlFifo_RxGetLen before pulling data out of the receive channel of the FIFO with XLlFifo_Read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_RxGetLen returns the number of bytes available in the next frame.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>C Signature: u32 <a class="el" href="xllfifo_8h.html#a53af32ae6901462cc8d6fb9adc04655e">XLlFifo_RxGetLen(XLlFifo *InstancePtr)</a> </p>

</div>
</div>
<a class="anchor" id="a12da547aa1c9a85e2b0b151f438ff9d5"></a><!-- doxytag: member="xllfifo.h::XLlFifo_RxOccupancy" ref="a12da547aa1c9a85e2b0b151f438ff9d5" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_RxOccupancy</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XStrm_RxOccupancy(&amp;((InstancePtr)-&gt;RxStreamer))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_RxOccupancy returns the number of 32-bit words available (occupancy) to be read from the receive channel of the FIFO, specified by <em>InstancePtr</em>.</p>
<p>The xps_ll_fifo core uses the same fifo to store data values and frame length values. Upon initialization, the XLlFifo_RxOccupancy will give the value of 1, which means one length value (a reserved fifo location) and no data values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_RxOccupancy returns the occupancy count for the specified packet FIFO.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>C Signature: u32 <a class="el" href="xllfifo_8h.html#a12da547aa1c9a85e2b0b151f438ff9d5">XLlFifo_RxOccupancy(XLlFifo *InstancePtr)</a> </p>

</div>
</div>
<a class="anchor" id="af3739a78b92f17cead0d831757b3a134"></a><!-- doxytag: member="xllfifo.h::XLlFifo_RxReset" ref="af3739a78b92f17cead0d831757b3a134" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_RxReset</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#ae1533e466df30729597a1b44ed1059ed">XLLF_RDFR_OFFSET</a>, \
                        <a class="code" href="xllfifo__hw_8h.html#a11c4da53ae9b166832186f9a817fba6d">XLLF_RDFR_RESET_MASK</a>)
</pre></div><p>XLlFifo_RxReset resets the receive channel of the FIFO specified by <em>InstancePtr</em>. XLlFifo_RxReset drops any bytes in the FIFO not yet retrieved.</p>
<p>The calling software may want to test for the completion of the reset by reading the interrupt status (IS) register and testing for the Rx Reset complete (RRC) bit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xllfifo_8h.html#af3739a78b92f17cead0d831757b3a134">XLlFifo_RxReset(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a095f3e0f8571dc02959852e38237f23e"></a><!-- doxytag: member="xllfifo.h::XLlFifo_Status" ref="a095f3e0f8571dc02959852e38237f23e" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Status</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XLlFifo_ReadReg((InstancePtr)-&gt;BaseAddress, XLLF_ISR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_Status returns a bit mask of the interrupt status register (ISR) for the FIFO specified by <em>InstancePtr</em>. XLlFifo_Status can be used to query the status of the FIFO without having to have interrupts enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_IntStatus returns a bit mask of the status conditions. The mask will be a set of bitwise or'd values from the <code>XLLF_INT_*_MASK</code> preprocessor symbols.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 XLlFifo_IntStatus(XLlFifo *InstancePtr) </dd></dl>

</div>
</div>
<a class="anchor" id="a922419fdcd342fa709fb07ec1a9e5577"></a><!-- doxytag: member="xllfifo.h::XLlFifo_TxReset" ref="a922419fdcd342fa709fb07ec1a9e5577" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_TxReset</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#aa55be9e9452783cde92cd70a33e31e56">XLLF_TDFR_OFFSET</a>, \
                        <a class="code" href="xllfifo__hw_8h.html#af7b4bcf41280c1fb01684b6706603420">XLLF_TDFR_RESET_MASK</a>)
</pre></div><p>XLlFifo_TxReset resets the transmit channel of the FIFO specified by <em>InstancePtr</em>. XLlFifo_TxReset drops any bytes in the FIFO not yet transmitted.</p>
<p>The calling software may want to test for the completion of the reset by reading the interrupt status (IS) register and testing for the Tx Reset complete (TRC) bit.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xllfifo_8h.html#a922419fdcd342fa709fb07ec1a9e5577">XLlFifo_TxReset(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acd09ed5189e0b85994901102655964f7"></a><!-- doxytag: member="xllfifo.h::XLlFifo_TxSetLen" ref="acd09ed5189e0b85994901102655964f7" args="(InstancePtr, Bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_TxSetLen</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XStrm_TxSetLen(&amp;((InstancePtr)-&gt;TxStreamer), (Bytes))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_TxSetLen begins a hardware transfer of <em>Bytes</em> bytes out of the transmit channel of the FIFO specified by <em>InstancePtr</em>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>specifies the frame length in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>C Signature: void <a class="el" href="xllfifo_8h.html#acd09ed5189e0b85994901102655964f7">XLlFifo_TxSetLen(XLlFifo *InstancePtr, u32 Bytes)</a> </p>

</div>
</div>
<a class="anchor" id="af2884c49ae41dc5c5317c2ef6df45a28"></a><!-- doxytag: member="xllfifo.h::XLlFifo_TxVacancy" ref="af2884c49ae41dc5c5317c2ef6df45a28" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_TxVacancy</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XStrm_TxVacancy(&amp;((InstancePtr)-&gt;TxStreamer))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_TxVacancy returns the number of unused 32 bit words available (vacancy) in the send channel of the FIFO specified by <em>InstancePtr</em>.</p>
<p>The xps_ll_fifo core uses tXLLF_he same fifo to store data values and frame length values. Upon initialization, the XLlFifo_TxVacancy will give the value of FIFO_WIDTH - 1, which means one length value used (a reserved fifo location) and no data values yet present.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XLlFifo_TxVacancy returns the vacancy count in 32-bit words for the specified FIFO.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xllfifo_8h.html#af2884c49ae41dc5c5317c2ef6df45a28">XLlFifo_TxVacancy(XLlFifo *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1fa93f486abaaf35c7d599a8cd91b295"></a><!-- doxytag: member="xllfifo.h::XLlFifo_Write" ref="a1fa93f486abaaf35c7d599a8cd91b295" args="(InstancePtr, BufPtr, Bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_Write</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BufPtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XStrm_Write(&amp;((InstancePtr)-&gt;TxStreamer), (BufPtr), (Bytes))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_Write writes <em>Bytes</em> bytes of the block of memory, referenced by <em>BufPtr</em>, to the transmit channel of the FIFO referenced by <em>InstancePtr</em>.</p>
<p>Care must be taken to ensure that the number of bytes written with one or more calls to <a class="el" href="xllfifo_8h.html#a1fa93f486abaaf35c7d599a8cd91b295">XLlFifo_Write()</a> matches the number of bytes given in the next call to <a class="el" href="xllfifo_8h.html#acd09ed5189e0b85994901102655964f7">XLlFifo_TxSetLen()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufPtr</em>&nbsp;</td><td>specifies the memory address of data to write.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>specifies the number of bytes to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Error handling is handled through hardware exceptions and interrupts.</dd></dl>
<p>C Signature: void <a class="el" href="xllfifo_8h.html#a1fa93f486abaaf35c7d599a8cd91b295">XLlFifo_Write(XLlFifo *InstancePtr, void *BufPtr, unsigned Bytes)</a> </p>

</div>
</div>
<a class="anchor" id="a105828f79f13c07d571db218c5837fae"></a><!-- doxytag: member="xllfifo.h::XLlFifo_WriteTdr" ref="a105828f79f13c07d571db218c5837fae" args="(InstancePtr, Tdest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XLlFifo_WriteTdr</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tdest&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xllfifo__hw_8h.html#acd283ce73981f7f9eab94f8bb421bc78">XLlFifo_WriteReg</a>((InstancePtr)-&gt;BaseAddress, <a class="code" href="xllfifo__hw_8h.html#a5c691ac1237fb77b8e356a7d2b0b8b54">XLLF_TDR_OFFSET</a>, \
                          Tdest &amp; 0xF)
</pre></div><p>XLlFifo_WriteTdr writes to the Transmit Destination Register (TDR)</p>
<p>The TDR stores the destination address corresponding to the packet to be transmitted. When presenting a transmit packet to the AXI4-Stream FIFO core the following sequence should be followed</p>
<ul>
<li>Write the destination address into TDR first,</li>
<li>Write the packet data to the Transmit Data FIFO next</li>
<li>Write the length of the packet into the Transmit Length Register.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the FIFO on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tdest</em>&nbsp;</td><td>is the Transmit Destination address to be written to TDR.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C Signature: void <a class="el" href="xllfifo_8h.html#a105828f79f13c07d571db218c5837fae">XLlFifo_WriteTdr(XLlFifo *InstancePtr, u32 Tdest)</a>; </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="adeafd207ee98a329f48eea9769b0994d"></a><!-- doxytag: member="xllfifo.h::XLlFfio_LookupConfig" ref="adeafd207ee98a329f48eea9769b0994d" args="(u32 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_ll_fifo___config.html">XLlFifo_Config</a>* XLlFfio_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Look up the hardware configuration for a device instance</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device to lookup for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The configuration structure for the device. If the device ID is not found,a NULL pointer is returned.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="adc1db2785627a0d8da46dc60990889a0"></a><!-- doxytag: member="xllfifo.h::XLlFifo_CfgInitialize" ref="adc1db2785627a0d8da46dc60990889a0" args="(XLlFifo *InstancePtr, XLlFifo_Config *Config, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XLlFifo_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo___config.html">XLlFifo_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_CfgInitialize initializes an XPS_ll_Fifo device along with the <em>InstancePtr</em> that references it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Streaming FIFO instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>references the structure holding the hardware configuration for the Axi Streaming FIFO core to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdf07ca198f5cfe2dc14ced21e5631d"></a><!-- doxytag: member="xllfifo.h::XLlFifo_Initialize" ref="a1fdf07ca198f5cfe2dc14ced21e5631d" args="(XLlFifo *InstancePtr, u32 BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLlFifo_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>XLlFifo_Initialize initializes an XPS_ll_Fifo device along with the <em>InstancePtr</em> that references it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the memory instance to be associated with the FIFO device upon initialization.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the processor address used to access the base address of the Fifo device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>N/A </dd></dl>

</div>
</div>
<a class="anchor" id="aad292ddf2a2c9dde261b93da802c8080"></a><!-- doxytag: member="xllfifo.h::XLlFifo_iRxGetLen" ref="aad292ddf2a2c9dde261b93da802c8080" args="(XLlFifo *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_iRxGetLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae2da9fa947a6e50edd41375ddc4c9964"></a><!-- doxytag: member="xllfifo.h::XLlFifo_iRxOccupancy" ref="ae2da9fa947a6e50edd41375ddc4c9964" args="(XLlFifo *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_iRxOccupancy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa49ecc1529434fd932d8a65d63a1a04d"></a><!-- doxytag: member="xllfifo.h::XLlFifo_iTxSetLen" ref="aa49ecc1529434fd932d8a65d63a1a04d" args="(XLlFifo *InstancePtr, u32 Bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLlFifo_iTxSetLen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac02405b23499d780e7bc1dfe371281a6"></a><!-- doxytag: member="xllfifo.h::XLlFifo_iTxVacancy" ref="ac02405b23499d780e7bc1dfe371281a6" args="(XLlFifo *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_iTxVacancy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed3ae31c8c24f46139fbd709027329ec"></a><!-- doxytag: member="xllfifo.h::XLlFifo_RxGetWord" ref="aed3ae31c8c24f46139fbd709027329ec" args="(XLlFifo *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XLlFifo_RxGetWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a29654d755dce84b861022179c99ca7a3"></a><!-- doxytag: member="xllfifo.h::XLlFifo_TxPutWord" ref="a29654d755dce84b861022179c99ca7a3" args="(XLlFifo *InstancePtr, u32 Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XLlFifo_TxPutWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_ll_fifo.html">XLlFifo</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Word</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
