<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver usbps v2_2: xusbps_endpoint.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xusbps_endpoint.c File Reference</h1><code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="xusbps_8h.html">xusbps.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xusbps__endpoint_8h.html">xusbps_endpoint.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#a6daace32113a806a6822a6d5943a93f4">XUsbPs_ConfigureDevice</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, const <a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *CfgPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#a6bfe53ec45a998d5673b80e11ab4d292">XUsbPs_EpBufferSend</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#a1e4c0735be24ea24b73404db8d18133e">XUsbPs_EpBufferSendWithZLT</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#ac27a9d64ddf33a2400d7493e301a7192">XUsbPs_EpBufferReceive</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, u8 **BufferPtr, u32 *BufferLenPtr, u32 *Handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#aa01a009151d133f07249d7f932e22f11">XUsbPs_EpBufferRelease</a> (u32 Handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#a04fb0b564bcd01cdf33e29ca2732656a">XUsbPs_EpSetHandler</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, u8 Direction, <a class="el" href="xusbps_8h.html#ae8ddd7172b8cd5bb0059d6f3c42707d9">XUsbPs_EpHandlerFunc</a> CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#aba0ae2eac9c6b402e32e401333a5b105">XUsbPs_EpPrime</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, u8 Direction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#a91c44ff9dcae2e47ed8112c8a0779fa1">XUsbPs_EpGetSetupData</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, int EpNum, <a class="el" href="struct_x_usb_ps___setup_data.html">XUsbPs_SetupData</a> *SetupDataPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps__endpoint_8c.html#a90aab040f015299b2064124bed882896">XUsbPs_ReconfigureEp</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, <a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *CfgPtr, int EpNum, unsigned short NewDirection, int DirectionChanged)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Endpoint specific function implementations.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None.</dd></dl>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -------- --------------------------------------------------------
 1.00a jz  10/10/10 First release
 1.03a nm  09/21/12 Fixed CR#678977. Added proper sequence for setup packet
                    handling.
 1.04a nm  11/02/12 Fixed CR#683931. Mult bits are set properly in dQH.
 2.00a kpc 04/03/14 Fixed CR#777763. Updated the macro names 
 2.1   kpc 04/28/14 Added XUsbPs_EpBufferSendWithZLT api and merged common
		      code to XUsbPs_EpQueueRequest.
 </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6daace32113a806a6822a6d5943a93f4"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_ConfigureDevice" ref="a6daace32113a806a6822a6d5943a93f4" args="(XUsbPs *InstancePtr, const XUsbPs_DeviceConfig *CfgPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_ConfigureDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function configures the DEVICE side of the controller. The caller needs to pass in the desired configuration (e.g. number of endpoints) and a DMAable buffer that will hold the Queue Head List and the Transfer Descriptors. The required size for this buffer can be obtained by the caller using the: XUsbPs_DeviceMemRequired() macro.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is a pointer to the configuration structure that contains the desired DEVICE side configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The caller may configure the controller for both, DEVICE and HOST side. </dd></dl>

</div>
</div>
<a class="anchor" id="ac27a9d64ddf33a2400d7493e301a7192"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpBufferReceive" ref="ac27a9d64ddf33a2400d7493e301a7192" args="(XUsbPs *InstancePtr, u8 EpNum, u8 **BufferPtr, u32 *BufferLenPtr, u32 *Handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpBufferReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BufferLenPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>Handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives a data buffer from the endpoint of the given endpoint number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>(OUT param) is a pointer to the buffer pointer to hold the reference of the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLenPtr</em>&nbsp;</td><td>(OUT param) is a pointer to the integer that will hold the buffer length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>is the opaque handle to be used when the buffer is released.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_USB_NO_BUF: No buffer available.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After handling the data in the buffer, the user MUST release the buffer using the Handle by calling the <a class="el" href="xusbps_8h.html#aa01a009151d133f07249d7f932e22f11">XUsbPs_EpBufferRelease()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa01a009151d133f07249d7f932e22f11"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpBufferRelease" ref="aa01a009151d133f07249d7f932e22f11" args="(u32 Handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsbPs_EpBufferRelease </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns a previously received data buffer to the driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>is a pointer to the buffer that is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bfe53ec45a998d5673b80e11ab4d292"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpBufferSend" ref="a6bfe53ec45a998d5673b80e11ab4d292" args="(XUsbPs *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpBufferSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a given data buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is a pointer to the buffer to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLen</em>&nbsp;</td><td>is the Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_USB_BUF_TOO_BIG: Provided buffer is too big (&gt;16kB).</li>
<li>XST_USB_NO_DESC_AVAILABLE: No TX descriptor is available. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1e4c0735be24ea24b73404db8d18133e"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpBufferSendWithZLT" ref="a1e4c0735be24ea24b73404db8d18133e" args="(XUsbPs *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpBufferSendWithZLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a given data buffer and also zero length packet if the Bufferlen is in multiples of endpoint max packet size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is a pointer to the buffer to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLen</em>&nbsp;</td><td>is the Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_USB_BUF_TOO_BIG: Provided buffer is too big (&gt;16kB).</li>
<li>XST_USB_NO_DESC_AVAILABLE: No TX descriptor is available. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a91c44ff9dcae2e47ed8112c8a0779fa1"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpGetSetupData" ref="a91c44ff9dcae2e47ed8112c8a0779fa1" args="(XUsbPs *InstancePtr, int EpNum, XUsbPs_SetupData *SetupDataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpGetSetupData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps___setup_data.html">XUsbPs_SetupData</a> *&nbsp;</td>
          <td class="paramname"> <em>SetupDataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function extracts the Setup Data from a given endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SetupDataPtr</em>&nbsp;</td><td>is a pointer to the setup data structure to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aba0ae2eac9c6b402e32e401333a5b105"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpPrime" ref="aba0ae2eac9c6b402e32e401333a5b105" args="(XUsbPs *InstancePtr, u8 EpNum, u8 Direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function primes an endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a04fb0b564bcd01cdf33e29ca2732656a"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_EpSetHandler" ref="a04fb0b564bcd01cdf33e29ca2732656a" args="(XUsbPs *InstancePtr, u8 EpNum, u8 Direction, XUsbPs_EpHandlerFunc CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xusbps_8h.html#ae8ddd7172b8cd5bb0059d6f3c42707d9">XUsbPs_EpHandlerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler for endpoint events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the Handler callback function. Can be NULL if the user wants to disable the handler entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the user definable data pointer that will be passed back if the handler is called. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a90aab040f015299b2064124bed882896"></a><!-- doxytag: member="xusbps_endpoint.c::XUsbPs_ReconfigureEp" ref="a90aab040f015299b2064124bed882896" args="(XUsbPs *InstancePtr, XUsbPs_DeviceConfig *CfgPtr, int EpNum, unsigned short NewDirection, int DirectionChanged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_ReconfigureEp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>NewDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>DirectionChanged</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reconfigures one Ep corresponding to host's request of setting alternate interface. The endpoint has been disabled before this call.</p>
<p>Both QH and dTDs are updated for the new configuration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>Pointer to the updated <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> DEVICE configuration structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>The endpoint to be reconfigured.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewDirection</em>&nbsp;</td><td>The new transfer direction the endpoint.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DirectionChanged</em>&nbsp;</td><td>A boolean value indicate whether the transfer direction has changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS upon success, XST_FAILURE otherwise. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
