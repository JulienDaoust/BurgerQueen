<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver usbps v2_2: xusbps.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xusbps.h File Reference</h1><code>#include &quot;<a class="el" href="xusbps__hw_8h.html">xusbps_hw.h</a>&quot;</code><br/>
<code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___ep_out.html">XUsbPs_EpOut</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___ep_in.html">XUsbPs_EpIn</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___endpoint.html">XUsbPs_Endpoint</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___setup_data.html">XUsbPs_SetupData</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___ep_setup.html">XUsbPs_EpSetup</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___ep_config.html">XUsbPs_EpConfig</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a5a7ef0c01940cfeca4472b08b09e51f8">XUSBPS_MAX_PACKET_SIZE</a>&nbsp;&nbsp;&nbsp;1024</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a6cfc1ddd6f334d4350d652e9b8ef2d7d">XUsbPs_GetFrameNum</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XUsbPs_ReadReg((InstancePtr)-&gt;Config.BaseAddress, XUSBPS_FRAME_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#af222df779ee9f9dc1d681701a979f3d1">XUsbPs_Start</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XUsbPs_SetBits(InstancePtr, XUSBPS_CMD_OFFSET, XUSBPS_CMD_RS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a14248be9e30d77cb8f65ecedf8bfbdf0">XUsbPs_Stop</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XUsbPs_ClrBits(InstancePtr, XUSBPS_CMD_OFFSET, XUSBPS_CMD_RS_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a1ddcdadfa686680d26c83a44ce5dd594">XUsbPs_ForceFS</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#af6a63a477b73705c87fc4e4392ab1872">XUsbPs_StartTimer0</a>(InstancePtr, Interval)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aec886a5a612b352fecd24d60259ebb5b">XUsbPs_StopTimer0</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aad63046a069a39fd8683d8f1369cce8e">XUsbPs_ReadTimer0</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#afa7091750e5ec43f625c257e14fbe290">XUsbPs_RemoteWakeup</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ad5dcc2f75c336bb6ea4c9697b0d88c1d">XUsbPs_EpEnable</a>(InstancePtr, EpNum, Dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a5b9a6534a546a278e48e31c0f3f53cbf">XUsbPs_EpDisable</a>(InstancePtr, EpNum, Dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a4273a108c512645b721b48997017205d">XUsbPs_EpStall</a>(InstancePtr, EpNum, Dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aca88c57543720b88f0bc0d194ec16271">XUsbPs_EpUnStall</a>(InstancePtr, EpNum, Dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a6674b216929ec8351518d1ecda9b4940">XUsbPs_EpFlush</a>(InstancePtr, EpNum, Dir)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#af88d5cf6ea7f26426bf40b8ca330a416">XUsbPs_IntrEnable</a>(InstancePtr, IntrMask)&nbsp;&nbsp;&nbsp;XUsbPs_SetBits(InstancePtr, XUSBPS_IER_OFFSET, IntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a22acce11d7faba420e1a25aaffca8d86">XUsbPs_IntrDisable</a>(InstancePtr, IntrMask)&nbsp;&nbsp;&nbsp;XUsbPs_ClrBits(InstancePtr, XUSBPS_IER_OFFSET, IntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a1d949530dfa3f587d5cd95caa4d2bdc3">XUsbPs_NakIntrEnable</a>(InstancePtr, NakIntrMask)&nbsp;&nbsp;&nbsp;XUsbPs_SetBits(InstancePtr, XUSBPS_EPNAKIER_OFFSET, NakIntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a7ad3a92ab100b9bbaeeeb6be6ec08f22">XUsbPs_NakIntrDisable</a>(InstancePtr, NakIntrMask)&nbsp;&nbsp;&nbsp;XUsbPs_ClrBits(InstancePtr, XUSBPS_EPNAKIER_OFFSET, NakIntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aa11d1d4de05ea74369eec8c2cb243aa8">XUsbPs_NakIntrClear</a>(InstancePtr, NakIntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ab1ce53cae0c030e39b619345bbaef1a0">XUsbPs_SetIntrThreshold</a>(InstancePtr, Threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a232724ca8e31333747d5eb0e7c144695">XUsbPs_SetSetupTripwire</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a67d06e097966e561f940dcb60ec99cac">XUsbPs_ClrSetupTripwire</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ad9cfbb6b0afe50174fb8fb126e5ba120">XUsbPs_SetupTripwireIsSet</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, RegOffset, Bits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a27d356b912141651e96cfef9b100c5f1">XUsbPs_ClrBits</a>(InstancePtr, RegOffset, Bits)</td></tr>
<tr><td colspan="2"><div class="groupHeader">System hang prevention Timeout counter value.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp242ca41508ff1b8e3fc45e6d7c78f2d8"></a> This value is used throughout the code to initialize a Timeout counter that is used when hard polling a register. The ides is to initialize the Timeout counter to a value that is longer than any expected Timeout but short enough so the system will continue to work and report an error while the user is still paying attention. A reasonable Timeout time would be about 10 seconds. The XUSBPS_TIMEOUT_COUNTER value should be chosen so a polling loop would run about 10 seconds before a Timeout is detected. For example:</p>
<p>int Timeout = XUSBPS_TIMEOUT_COUNTER; while ((XUsbPs_ReadReg(InstancePtr-&gt;Config.BaseAddress, XUSBPS_CMD_OFFSET) &amp; XUSBPS_CMD_RST_MASK) &amp;&amp; --Timeout) { ; } if (0 == Timeout) { return XST_FAILURE; } </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a57f0ece484636153f47b87cfd7eeaa75">XUSBPS_TIMEOUT_COUNTER</a>&nbsp;&nbsp;&nbsp;1000000</td></tr>
<tr><td colspan="2"><div class="groupHeader">Endpoint Direction (bitmask)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8b44ba7e4a3cc805ca633291be1a927f"></a> Definitions to be used with Endpoint related function that require a 'Direction' parameter.</p>
<p>NOTE: The direction is always defined from the perspective of the HOST! This means that an IN endpoint on the controller is used for sending data while the OUT endpoint on the controller is used for receiving data. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a0f21b0f7da084c22abc4f0a9bf425bc7">XUSBPS_EP_DIRECTION_IN</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a86e363bb35c38123a924bd2af954ceab">XUSBPS_EP_DIRECTION_OUT</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td colspan="2"><div class="groupHeader">Endpoint Type</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp363497ee29233f513e6b7a80cac1cdf3"></a> Definitions to be used with Endpoint related functions that require a 'Type' parameter. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ac1d65456d504832a5a1426085545ff2d">XUSBPS_EP_TYPE_NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ad8b727ed129801690a987d1e475bc1d5">XUSBPS_EP_TYPE_CONTROL</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ae012590baed99e88cd4a92ff3f65faa0">XUSBPS_EP_TYPE_ISOCHRONOUS</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a1c2a58518c4f4ee1e9bcd200f566ddf7">XUSBPS_EP_TYPE_BULK</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ab9833b2c2a3e69cfa5c5b2cd0be4c185">XUSBPS_EP_TYPE_INTERRUPT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a693168c9588d90c92e04e665fb141fce">ENDPOINT_MAXP_LENGTH</a>&nbsp;&nbsp;&nbsp;0x400</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a728aec476cd85437e15b8f8fdf270545">ENDPOINT_MAXP_MULT_MASK</a>&nbsp;&nbsp;&nbsp;0xC00</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a2381962c65abbfb63e0a47d451ae3d90">ENDPOINT_MAXP_MULT_SHIFT</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td colspan="2"><div class="groupHeader">Field names for status retrieval</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp793d353261765afa0b856a99564c2800"></a> Definitions for the XUsbPs_GetStatus() function call 'StatusType' parameter. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a96ac93f4536cd0c0abeff764b0c752dd">XUSBPS_EP_STS_ADDRESS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a23671067697bfc0ea6b0a688cee5de2b">XUSBPS_EP_STS_CONTROLLER_STATE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td colspan="2"><div class="groupHeader">USB Default alternate setting</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp88822dd313aea9e62443e229742838a4"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ad86f6c8b6ff536870e40a018308ee9d7">XUSBPS_DEFAULT_ALT_SETTING</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Endpoint event types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpb53b7aa8814ae5f264500ee3e60943d6"></a> Definitions that are used to identify events that occur on endpoints. Passed to the endpoint event handler functions registered with <a class="el" href="xusbps_8h.html#a04fb0b564bcd01cdf33e29ca2732656a">XUsbPs_EpSetHandler()</a>. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a9934654d1c910d17fbeb9b5f75e96ecc">XUSBPS_EP_EVENT_SETUP_DATA_RECEIVED</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a8915f71ea9bef90eed401a44a39d7dba">XUSBPS_EP_EVENT_DATA_RX</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aaf96bbc1cb4b4c7d1e3399027a2e4823">XUSBPS_EP_EVENT_DATA_TX</a>&nbsp;&nbsp;&nbsp;0x03</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ae8ddd7172b8cd5bb0059d6f3c42707d9">XUsbPs_EpHandlerFunc</a> )(void *CallBackRef, u8 EpNum, u8 EventType, void *Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a874b9f224a6f0b430a95ec2d143173b4">XUsbPs_IntrHandlerFunc</a> )(void *CallBackRef, u32 IrqMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a5c6f9d3b7850e3256d48c037bdd713fd">XUsbPs_dQH</a> [XUSBPS_dQH_ALIGN]</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a7c5399f5d7978baf54eed460d1099d48">XUsbPs_dTD</a> [XUSBPS_dTD_ALIGN]</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a6bca90ee01163af1b154966082b91a92">XUsbPs_CfgInitialize</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, const <a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> *ConfigPtr, u32 BaseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a6daace32113a806a6822a6d5943a93f4">XUsbPs_ConfigureDevice</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, const <a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *CfgPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a2c583a4c515653fd70c111fe0d2ddb37">XUsbPs_Reset</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a69b214c21727c4b1f641d84414f397df">XUsbPs_DeviceReset</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aa47418bedd29f6bc36e075b124227eb0">XUsbPs_BusReset</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a8c700bcf9ba08271914145803776d265">XUsbPs_SetDeviceAddress</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a0f25904ea86f189b6597c0dff795f61f">XUsbPs_Suspend</a> (const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aa71f906531330b2f05ede2f17ab54c69">XUsbPs_Resume</a> (const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a5dc88831ee2823e24d7024e585704772">XUsbPs_RequestHostResume</a> (const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a6bfe53ec45a998d5673b80e11ab4d292">XUsbPs_EpBufferSend</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a1e4c0735be24ea24b73404db8d18133e">XUsbPs_EpBufferSendWithZLT</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ac27a9d64ddf33a2400d7493e301a7192">XUsbPs_EpBufferReceive</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, u8 **BufferPtr, u32 *BufferLenPtr, u32 *Handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aa01a009151d133f07249d7f932e22f11">XUsbPs_EpBufferRelease</a> (u32 Handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a04fb0b564bcd01cdf33e29ca2732656a">XUsbPs_EpSetHandler</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, u8 Direction, <a class="el" href="xusbps_8h.html#ae8ddd7172b8cd5bb0059d6f3c42707d9">XUsbPs_EpHandlerFunc</a> CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a91c44ff9dcae2e47ed8112c8a0779fa1">XUsbPs_EpGetSetupData</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, int EpNum, <a class="el" href="struct_x_usb_ps___setup_data.html">XUsbPs_SetupData</a> *SetupDataPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#aba0ae2eac9c6b402e32e401333a5b105">XUsbPs_EpPrime</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 EpNum, u8 Direction)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a90aab040f015299b2064124bed882896">XUsbPs_ReconfigureEp</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, <a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *CfgPtr, int EpNum, unsigned short NewDirection, int DirectionChanged)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a1fa8bf48bf7488cebb101c888489efc2">XUsbPs_IntrHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#a521c050d3b146bb58862f5fadf7f6ba6">XUsbPs_IntrSetHandler</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, <a class="el" href="xusbps_8h.html#a874b9f224a6f0b430a95ec2d143173b4">XUsbPs_IntrHandlerFunc</a> CallBackFunc, void *CallBackRef, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8h.html#ad0fc08318389471729fc392623e001ce">XUsbPs_LookupConfig</a> (u16 DeviceId)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a693168c9588d90c92e04e665fb141fce"></a><!-- doxytag: member="xusbps.h::ENDPOINT_MAXP_LENGTH" ref="a693168c9588d90c92e04e665fb141fce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAXP_LENGTH&nbsp;&nbsp;&nbsp;0x400</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint Max Packet Length in DeviceConfig is a coded value, ch9.6.6. </p>

</div>
</div>
<a class="anchor" id="a728aec476cd85437e15b8f8fdf270545"></a><!-- doxytag: member="xusbps.h::ENDPOINT_MAXP_MULT_MASK" ref="a728aec476cd85437e15b8f8fdf270545" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAXP_MULT_MASK&nbsp;&nbsp;&nbsp;0xC00</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2381962c65abbfb63e0a47d451ae3d90"></a><!-- doxytag: member="xusbps.h::ENDPOINT_MAXP_MULT_SHIFT" ref="a2381962c65abbfb63e0a47d451ae3d90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAXP_MULT_SHIFT&nbsp;&nbsp;&nbsp;10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27d356b912141651e96cfef9b100c5f1"></a><!-- doxytag: member="xusbps.h::XUsbPs_ClrBits" ref="a27d356b912141651e96cfef9b100c5f1" args="(InstancePtr, RegOffset, Bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_ClrBits</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bits&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps__hw_8h.html#aefd4e31b2628602507b5df0f7d9c934f">XUsbPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, RegOffset,   \
                <a class="code" href="xusbps__hw_8h.html#ae013de4110ae5cd348830c36a365fb14">XUsbPs_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,       \
                                RegOffset) &amp; ~(Bits));
</pre></div><p>This macro clears the given bits in the register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegOffset</em>&nbsp;</td><td>is the register offset to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bits</em>&nbsp;</td><td>are the bits to be cleared in the register</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a27d356b912141651e96cfef9b100c5f1">XUsbPs_ClrBits(u32 BaseAddress, u32 RegOffset, u32 Bits)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a67d06e097966e561f940dcb60ec99cac"></a><!-- doxytag: member="xusbps.h::XUsbPs_ClrSetupTripwire" ref="a67d06e097966e561f940dcb60ec99cac" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_ClrSetupTripwire</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#a27d356b912141651e96cfef9b100c5f1">XUsbPs_ClrBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af4e60df9453b2ca88e075768c80eb362">XUSBPS_CMD_OFFSET</a>,  \
                                <a class="code" href="xusbps__hw_8h.html#a28d755f3ecc320aea1c7f5d524c6ce04">XUSBPS_CMD_SUTW_MASK</a>)
</pre></div><p>This macro clears the Tripwire bit in the USB command register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void XUsbPs_ClrTripwire(XUsbPs *InstancePtr) </dd></dl>

</div>
</div>
<a class="anchor" id="ad86f6c8b6ff536870e40a018308ee9d7"></a><!-- doxytag: member="xusbps.h::XUSBPS_DEFAULT_ALT_SETTING" ref="ad86f6c8b6ff536870e40a018308ee9d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_DEFAULT_ALT_SETTING&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The default alternate setting is 0 </p>

</div>
</div>
<a class="anchor" id="a0f21b0f7da084c22abc4f0a9bf425bc7"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_DIRECTION_IN" ref="a0f21b0f7da084c22abc4f0a9bf425bc7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_DIRECTION_IN&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint direction IN. </p>

</div>
</div>
<a class="anchor" id="a86e363bb35c38123a924bd2af954ceab"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_DIRECTION_OUT" ref="a86e363bb35c38123a924bd2af954ceab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_DIRECTION_OUT&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint direction OUT. </p>

</div>
</div>
<a class="anchor" id="a8915f71ea9bef90eed401a44a39d7dba"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_EVENT_DATA_RX" ref="a8915f71ea9bef90eed401a44a39d7dba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_EVENT_DATA_RX&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data frame has been received on the endpoint. </p>

</div>
</div>
<a class="anchor" id="aaf96bbc1cb4b4c7d1e3399027a2e4823"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_EVENT_DATA_TX" ref="aaf96bbc1cb4b4c7d1e3399027a2e4823" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_EVENT_DATA_TX&nbsp;&nbsp;&nbsp;0x03</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Data frame has been sent on the endpoint. </p>

</div>
</div>
<a class="anchor" id="a9934654d1c910d17fbeb9b5f75e96ecc"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_EVENT_SETUP_DATA_RECEIVED" ref="a9934654d1c910d17fbeb9b5f75e96ecc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_EVENT_SETUP_DATA_RECEIVED&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup data has been received on the enpoint. </p>

</div>
</div>
<a class="anchor" id="a96ac93f4536cd0c0abeff764b0c752dd"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_STS_ADDRESS" ref="a96ac93f4536cd0c0abeff764b0c752dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_STS_ADDRESS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Address of controller. </p>

</div>
</div>
<a class="anchor" id="a23671067697bfc0ea6b0a688cee5de2b"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_STS_CONTROLLER_STATE" ref="a23671067697bfc0ea6b0a688cee5de2b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_STS_CONTROLLER_STATE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Current controller state. </p>

</div>
</div>
<a class="anchor" id="a1c2a58518c4f4ee1e9bcd200f566ddf7"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_TYPE_BULK" ref="a1c2a58518c4f4ee1e9bcd200f566ddf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_TYPE_BULK&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint for BULK Transfers. </p>

</div>
</div>
<a class="anchor" id="ad8b727ed129801690a987d1e475bc1d5"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_TYPE_CONTROL" ref="ad8b727ed129801690a987d1e475bc1d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_TYPE_CONTROL&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint for Control Transfers </p>

</div>
</div>
<a class="anchor" id="ab9833b2c2a3e69cfa5c5b2cd0be4c185"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_TYPE_INTERRUPT" ref="ab9833b2c2a3e69cfa5c5b2cd0be4c185" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_TYPE_INTERRUPT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint for interrupt Transfers </p>

</div>
</div>
<a class="anchor" id="ae012590baed99e88cd4a92ff3f65faa0"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_TYPE_ISOCHRONOUS" ref="ae012590baed99e88cd4a92ff3f65faa0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_TYPE_ISOCHRONOUS&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint for isochronous data </p>

</div>
</div>
<a class="anchor" id="ac1d65456d504832a5a1426085545ff2d"></a><!-- doxytag: member="xusbps.h::XUSBPS_EP_TYPE_NONE" ref="ac1d65456d504832a5a1426085545ff2d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_EP_TYPE_NONE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint is not used. </p>

</div>
</div>
<a class="anchor" id="a5b9a6534a546a278e48e31c0f3f53cbf"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpDisable" ref="a5b9a6534a546a278e48e31c0f3f53cbf" args="(InstancePtr, EpNum, Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_EpDisable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpNum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dir&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#a27d356b912141651e96cfef9b100c5f1">XUsbPs_ClrBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af457832b3446572ed58cc64bfd668d73">XUSBPS_EPCRn_OFFSET</a>(EpNum),          \
                ((Dir) &amp; <a class="code" href="xusbps_8h.html#a86e363bb35c38123a924bd2af954ceab">XUSBPS_EP_DIRECTION_OUT</a> ? <a class="code" href="xusbps__hw_8h.html#a47897095bd9001c405e4c1b43f4582cd">XUSBPS_EPCR_RXE_MASK</a> : 0) | \
                ((Dir) &amp; <a class="code" href="xusbps_8h.html#a0f21b0f7da084c22abc4f0a9bf425bc7">XUSBPS_EP_DIRECTION_IN</a>  ? <a class="code" href="xusbps__hw_8h.html#a5cc1450fbbe3d6e525b363a2faf54575">XUSBPS_EPCR_TXE_MASK</a> : 0))
</pre></div><p>This macro disables the given endpoint for the given direction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to disable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a5b9a6534a546a278e48e31c0f3f53cbf">XUsbPs_EpDisable(XUsbPs *InstancePtr, u8 EpNum, u8 Dir)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5dcc2f75c336bb6ea4c9697b0d88c1d"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpEnable" ref="ad5dcc2f75c336bb6ea4c9697b0d88c1d" args="(InstancePtr, EpNum, Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_EpEnable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpNum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dir&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af457832b3446572ed58cc64bfd668d73">XUSBPS_EPCRn_OFFSET</a>(EpNum),  \
        ((Dir) &amp; <a class="code" href="xusbps_8h.html#a86e363bb35c38123a924bd2af954ceab">XUSBPS_EP_DIRECTION_OUT</a> ? <a class="code" href="xusbps__hw_8h.html#a47897095bd9001c405e4c1b43f4582cd">XUSBPS_EPCR_RXE_MASK</a> : 0) | \
        ((Dir) &amp; <a class="code" href="xusbps_8h.html#a0f21b0f7da084c22abc4f0a9bf425bc7">XUSBPS_EP_DIRECTION_IN</a>  ? <a class="code" href="xusbps__hw_8h.html#a5cc1450fbbe3d6e525b363a2faf54575">XUSBPS_EPCR_TXE_MASK</a> : 0))
</pre></div><p>This macro enables the given endpoint for the given direction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is number of the endpoint to enable. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>is direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#ad5dcc2f75c336bb6ea4c9697b0d88c1d">XUsbPs_EpEnable(XUsbPs *InstancePtr, u8 EpNum, u8 Dir)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6674b216929ec8351518d1ecda9b4940"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpFlush" ref="a6674b216929ec8351518d1ecda9b4940" args="(InstancePtr, EpNum, Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_EpFlush</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpNum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dir&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#a62f7e5327dfbd7d8dc083194861a406e">XUSBPS_EPFLUSH_OFFSET</a>,      \
                EpNum &lt;&lt; ((Dir) &amp; <a class="code" href="xusbps_8h.html#a86e363bb35c38123a924bd2af954ceab">XUSBPS_EP_DIRECTION_OUT</a> ?             \
                        <a class="code" href="xusbps__hw_8h.html#aa80d1012ad67ac687495e255fb0356e3">XUSBPS_EPFLUSH_RX_SHIFT</a>:<a class="code" href="xusbps__hw_8h.html#a7ccddfc11a06ca28d7c1bb1086e1d66c">XUSBPS_EPFLUSH_TX_SHIFT</a>)) \
</pre></div><p>This macro flush an endpoint upon interface disable</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to flush. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a6674b216929ec8351518d1ecda9b4940">XUsbPs_EpFlush(XUsbPs *InstancePtr, u8 EpNum, u8 Dir)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4273a108c512645b721b48997017205d"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpStall" ref="a4273a108c512645b721b48997017205d" args="(InstancePtr, EpNum, Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_EpStall</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpNum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dir&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af457832b3446572ed58cc64bfd668d73">XUSBPS_EPCRn_OFFSET</a>(EpNum),  \
        ((Dir) &amp; <a class="code" href="xusbps_8h.html#a86e363bb35c38123a924bd2af954ceab">XUSBPS_EP_DIRECTION_OUT</a> ? <a class="code" href="xusbps__hw_8h.html#aaf4f7b7545c284558f021aa3f68e45cc">XUSBPS_EPCR_RXS_MASK</a> : 0) | \
        ((Dir) &amp; <a class="code" href="xusbps_8h.html#a0f21b0f7da084c22abc4f0a9bf425bc7">XUSBPS_EP_DIRECTION_IN</a>  ? <a class="code" href="xusbps__hw_8h.html#ad22deb4883894f452b73ed38418970d0">XUSBPS_EPCR_TXS_MASK</a> : 0))
</pre></div><p>This macro stalls the given endpoint for the given direction, and flush the buffers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is number of the endpoint to stall. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a4273a108c512645b721b48997017205d">XUsbPs_EpStall(XUsbPs *InstancePtr, u8 EpNum, u8 Dir)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aca88c57543720b88f0bc0d194ec16271"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpUnStall" ref="aca88c57543720b88f0bc0d194ec16271" args="(InstancePtr, EpNum, Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_EpUnStall</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EpNum, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dir&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#a27d356b912141651e96cfef9b100c5f1">XUsbPs_ClrBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af457832b3446572ed58cc64bfd668d73">XUSBPS_EPCRn_OFFSET</a>(EpNum),  \
        ((Dir) &amp; <a class="code" href="xusbps_8h.html#a86e363bb35c38123a924bd2af954ceab">XUSBPS_EP_DIRECTION_OUT</a> ? <a class="code" href="xusbps__hw_8h.html#aaf4f7b7545c284558f021aa3f68e45cc">XUSBPS_EPCR_RXS_MASK</a> : 0) | \
        ((Dir) &amp; <a class="code" href="xusbps_8h.html#a0f21b0f7da084c22abc4f0a9bf425bc7">XUSBPS_EP_DIRECTION_IN</a>  ? <a class="code" href="xusbps__hw_8h.html#ad22deb4883894f452b73ed38418970d0">XUSBPS_EPCR_TXS_MASK</a> : 0))
</pre></div><p>This macro unstalls the given endpoint for the given direction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the Number of the endpoint to unstall. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>is the Direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#aca88c57543720b88f0bc0d194ec16271">XUsbPs_EpUnStall(XUsbPs *InstancePtr, u8 EpNum, u8 Dir)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1ddcdadfa686680d26c83a44ce5dd594"></a><!-- doxytag: member="xusbps.h::XUsbPs_ForceFS" ref="a1ddcdadfa686680d26c83a44ce5dd594" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_ForceFS</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#a3e6302971cb6f32b61bd601152babdfd">XUSBPS_PORTSCR1_OFFSET</a>,             \
                <a class="code" href="xusbps__hw_8h.html#a56979f03747794e45b17e23f14361015">XUSBPS_PORTSCR_PFSC_MASK</a>)
</pre></div><p>This macro forces the USB engine to be in Full Speed (FS) mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a1ddcdadfa686680d26c83a44ce5dd594">XUsbPs_ForceFS(XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6cfc1ddd6f334d4350d652e9b8ef2d7d"></a><!-- doxytag: member="xusbps.h::XUsbPs_GetFrameNum" ref="a6cfc1ddd6f334d4350d652e9b8ef2d7d" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_GetFrameNum</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_ReadReg((InstancePtr)-&gt;Config.BaseAddress, XUSBPS_FRAME_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro returns the current frame number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current frame number.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xusbps_8h.html#a6cfc1ddd6f334d4350d652e9b8ef2d7d">XUsbPs_GetFrameNum(const XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22acce11d7faba420e1a25aaffca8d86"></a><!-- doxytag: member="xusbps.h::XUsbPs_IntrDisable" ref="a22acce11d7faba420e1a25aaffca8d86" args="(InstancePtr, IntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_IntrDisable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntrMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_ClrBits(InstancePtr, XUSBPS_IER_OFFSET, IntrMask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the interrupts defined by the bit mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntrMask</em>&nbsp;</td><td>is a Bit mask of interrupts to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a22acce11d7faba420e1a25aaffca8d86">XUsbPs_IntrDisable(XUsbPs *InstancePtr, u32 IntrMask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af88d5cf6ea7f26426bf40b8ca330a416"></a><!-- doxytag: member="xusbps.h::XUsbPs_IntrEnable" ref="af88d5cf6ea7f26426bf40b8ca330a416" args="(InstancePtr, IntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_IntrEnable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntrMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_SetBits(InstancePtr, XUSBPS_IER_OFFSET, IntrMask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro enables the interrupts defined by the bit mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntrMask</em>&nbsp;</td><td>is the Bit mask of interrupts to be enabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#af88d5cf6ea7f26426bf40b8ca330a416">XUsbPs_IntrEnable(XUsbPs *InstancePtr, u32 IntrMask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a7ef0c01940cfeca4472b08b09e51f8"></a><!-- doxytag: member="xusbps.h::XUSBPS_MAX_PACKET_SIZE" ref="a5a7ef0c01940cfeca4472b08b09e51f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_MAX_PACKET_SIZE&nbsp;&nbsp;&nbsp;1024</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum value can be put into the queue head </p>

</div>
</div>
<a class="anchor" id="aa11d1d4de05ea74369eec8c2cb243aa8"></a><!-- doxytag: member="xusbps.h::XUsbPs_NakIntrClear" ref="aa11d1d4de05ea74369eec8c2cb243aa8" args="(InstancePtr, NakIntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_NakIntrClear</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NakIntrMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps__hw_8h.html#aefd4e31b2628602507b5df0f7d9c934f">XUsbPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,              \
                                <a class="code" href="xusbps__hw_8h.html#a7f16bb1d54ffe9b9edf7ffc2a5b3bc2e">XUSBPS_EPNAKISR_OFFSET</a>, NakIntrMask)
</pre></div><p>This function clears the endpoint NAK interrupts status defined by the bit mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NakIntrMask</em>&nbsp;</td><td>is the Bit mask of endpoint NAK interrupts to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#aa11d1d4de05ea74369eec8c2cb243aa8">XUsbPs_NakIntrClear(XUsbPs *InstancePtr, u32 NakIntrMask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ad3a92ab100b9bbaeeeb6be6ec08f22"></a><!-- doxytag: member="xusbps.h::XUsbPs_NakIntrDisable" ref="a7ad3a92ab100b9bbaeeeb6be6ec08f22" args="(InstancePtr, NakIntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_NakIntrDisable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NakIntrMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_ClrBits(InstancePtr, XUSBPS_EPNAKIER_OFFSET, NakIntrMask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro disables the endpoint NAK interrupts defined by the bit mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NakIntrMask</em>&nbsp;</td><td>is a Bit mask of endpoint NAK interrupts to be disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a7ad3a92ab100b9bbaeeeb6be6ec08f22">XUsbPs_NakIntrDisable(XUsbPs *InstancePtr, u32 NakIntrMask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1d949530dfa3f587d5cd95caa4d2bdc3"></a><!-- doxytag: member="xusbps.h::XUsbPs_NakIntrEnable" ref="a1d949530dfa3f587d5cd95caa4d2bdc3" args="(InstancePtr, NakIntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_NakIntrEnable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NakIntrMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_SetBits(InstancePtr, XUSBPS_EPNAKIER_OFFSET, NakIntrMask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro enables the endpoint NAK interrupts defined by the bit mask.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NakIntrMask</em>&nbsp;</td><td>is the Bit mask of endpoint NAK interrupts to be enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a1d949530dfa3f587d5cd95caa4d2bdc3">XUsbPs_NakIntrEnable(XUsbPs *InstancePtr, u32 NakIntrMask)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aad63046a069a39fd8683d8f1369cce8e"></a><!-- doxytag: member="xusbps.h::XUsbPs_ReadTimer0" ref="aad63046a069a39fd8683d8f1369cce8e" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_ReadTimer0</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps__hw_8h.html#ae013de4110ae5cd348830c36a365fb14">XUsbPs_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,               \
                        <a class="code" href="xusbps__hw_8h.html#af7c6b9afa93b84998286417434bff9bc">XUSBPS_TIMER0_CTL_OFFSET</a>) &amp;                     \
                                        <a class="code" href="xusbps__hw_8h.html#aa4bd5ab3787a4eee54214fef61b39162">XUSBPS_TIMER_COUNTER_MASK</a>
</pre></div><p>This macro reads Timer 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#aad63046a069a39fd8683d8f1369cce8e">XUsbPs_ReadTimer0(XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afa7091750e5ec43f625c257e14fbe290"></a><!-- doxytag: member="xusbps.h::XUsbPs_RemoteWakeup" ref="afa7091750e5ec43f625c257e14fbe290" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_RemoteWakeup</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#a3e6302971cb6f32b61bd601152babdfd">XUSBPS_PORTSCR1_OFFSET</a>,              \
                        <a class="code" href="xusbps__hw_8h.html#a74d93aa96409e16a96e343829f8216ba">XUSBPS_PORTSCR_FPR_MASK</a>)
</pre></div><p>This macro force remote wakeup on host</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#afa7091750e5ec43f625c257e14fbe290">XUsbPs_RemoteWakeup(XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab3136c0894811be3b4406dff0d7634f8"></a><!-- doxytag: member="xusbps.h::XUsbPs_SetBits" ref="ab3136c0894811be3b4406dff0d7634f8" args="(InstancePtr, RegOffset, Bits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_SetBits</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bits&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps__hw_8h.html#aefd4e31b2628602507b5df0f7d9c934f">XUsbPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, RegOffset,   \
                <a class="code" href="xusbps__hw_8h.html#ae013de4110ae5cd348830c36a365fb14">XUsbPs_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,       \
                                        RegOffset) | (Bits));
</pre></div><p>This macro sets the given bit mask in the register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegOffset</em>&nbsp;</td><td>is the register offset to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bits</em>&nbsp;</td><td>is the Bits to be set in the register</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits(u32 BaseAddress, u32 RegOffset, u32 Bits)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1ce53cae0c030e39b619345bbaef1a0"></a><!-- doxytag: member="xusbps.h::XUsbPs_SetIntrThreshold" ref="ab1ce53cae0c030e39b619345bbaef1a0" args="(InstancePtr, Threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_SetIntrThreshold</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Threshold&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps__hw_8h.html#aefd4e31b2628602507b5df0f7d9c934f">XUsbPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,      \
                                        <a class="code" href="xusbps__hw_8h.html#af4e60df9453b2ca88e075768c80eb362">XUSBPS_CMD_OFFSET</a>, (Threshold))\
</pre></div><p>This macro sets the Interrupt Threshold value in the control register</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Threshold</em>&nbsp;</td><td>is the Interrupt threshold to be set. Allowed values:</p>
<ul>
<li>XUSBPS_CMD_ITHRESHOLD_0 - Immediate interrupt</li>
<li>XUSBPS_CMD_ITHRESHOLD_1 - 1 Frame</li>
<li>XUSBPS_CMD_ITHRESHOLD_2 - 2 Frames</li>
<li>XUSBPS_CMD_ITHRESHOLD_4 - 4 Frames</li>
<li>XUSBPS_CMD_ITHRESHOLD_8 - 8 Frames</li>
<li>XUSBPS_CMD_ITHRESHOLD_16 - 16 Frames</li>
<li>XUSBPS_CMD_ITHRESHOLD_32 - 32 Frames</li>
<li>XUSBPS_CMD_ITHRESHOLD_64 - 64 Frames</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#ab1ce53cae0c030e39b619345bbaef1a0">XUsbPs_SetIntrThreshold(XUsbPs *InstancePtr, u8 Threshold)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a232724ca8e31333747d5eb0e7c144695"></a><!-- doxytag: member="xusbps.h::XUsbPs_SetSetupTripwire" ref="a232724ca8e31333747d5eb0e7c144695" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_SetSetupTripwire</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af4e60df9453b2ca88e075768c80eb362">XUSBPS_CMD_OFFSET</a>,  \
                                <a class="code" href="xusbps__hw_8h.html#a28d755f3ecc320aea1c7f5d524c6ce04">XUSBPS_CMD_SUTW_MASK</a>)
</pre></div><p>This macro sets the Tripwire bit in the USB command register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void XUsbPs_SetTripwire(XUsbPs *InstancePtr) </dd></dl>

</div>
</div>
<a class="anchor" id="ad9cfbb6b0afe50174fb8fb126e5ba120"></a><!-- doxytag: member="xusbps.h::XUsbPs_SetupTripwireIsSet" ref="ad9cfbb6b0afe50174fb8fb126e5ba120" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_SetupTripwireIsSet</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xusbps__hw_8h.html#ae013de4110ae5cd348830c36a365fb14">XUsbPs_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,      \
                                <a class="code" href="xusbps__hw_8h.html#af4e60df9453b2ca88e075768c80eb362">XUSBPS_CMD_OFFSET</a>) &amp;                    \
                                <a class="code" href="xusbps__hw_8h.html#a28d755f3ecc320aea1c7f5d524c6ce04">XUSBPS_CMD_SUTW_MASK</a> ? TRUE : FALSE)
</pre></div><p>This macro checks if the Tripwire bit in the USB command register is set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE: The tripwire bit is still set.</li>
<li>FALSE: The tripwire bit has been cleared.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: int XUsbPs_TripwireIsSet(XUsbPs *InstancePtr) </dd></dl>

</div>
</div>
<a class="anchor" id="af222df779ee9f9dc1d681701a979f3d1"></a><!-- doxytag: member="xusbps.h::XUsbPs_Start" ref="af222df779ee9f9dc1d681701a979f3d1" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_Start</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_SetBits(InstancePtr, XUSBPS_CMD_OFFSET, XUSBPS_CMD_RS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro starts the USB engine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#af222df779ee9f9dc1d681701a979f3d1">XUsbPs_Start(XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6a63a477b73705c87fc4e4392ab1872"></a><!-- doxytag: member="xusbps.h::XUsbPs_StartTimer0" ref="af6a63a477b73705c87fc4e4392ab1872" args="(InstancePtr, Interval)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_StartTimer0</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Interval&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                       \
        <a class="code" href="xusbps__hw_8h.html#aefd4e31b2628602507b5df0f7d9c934f">XUsbPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,              \
                        <a class="code" href="xusbps__hw_8h.html#ac6316b1c386abf7f7523cfdfc8dc54ea">XUSBPS_TIMER0_LD_OFFSET</a>, (Interval));           \
        <a class="code" href="xusbps_8h.html#ab3136c0894811be3b4406dff0d7634f8">XUsbPs_SetBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af7c6b9afa93b84998286417434bff9bc">XUSBPS_TIMER0_CTL_OFFSET</a>,           \
                        <a class="code" href="xusbps__hw_8h.html#a87e12fac25dadaf4481a4a7140c1bcc0">XUSBPS_TIMER_RUN_MASK</a> |                 \
                        <a class="code" href="xusbps__hw_8h.html#acb0fddd0cf1f6147d0fb07d8b6b01fd8">XUSBPS_TIMER_RESET_MASK</a> |                       \
                        <a class="code" href="xusbps__hw_8h.html#ade6aa6ac5fe9946a1e985067e8c5f6fc">XUSBPS_TIMER_REPEAT_MASK</a>);                      \
}                                                                       \
</pre></div><p>This macro starts the USB Timer 0, with repeat option for period of one second.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Interval</em>&nbsp;</td><td>is the interval for Timer0 to generate an interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#af6a63a477b73705c87fc4e4392ab1872">XUsbPs_StartTimer0(XUsbPs *InstancePtr, u32 Interval)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a14248be9e30d77cb8f65ecedf8bfbdf0"></a><!-- doxytag: member="xusbps.h::XUsbPs_Stop" ref="a14248be9e30d77cb8f65ecedf8bfbdf0" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_Stop</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XUsbPs_ClrBits(InstancePtr, XUSBPS_CMD_OFFSET, XUSBPS_CMD_RS_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro stops the USB engine.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#a14248be9e30d77cb8f65ecedf8bfbdf0">XUsbPs_Stop(XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aec886a5a612b352fecd24d60259ebb5b"></a><!-- doxytag: member="xusbps.h::XUsbPs_StopTimer0" ref="aec886a5a612b352fecd24d60259ebb5b" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUsbPs_StopTimer0</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xusbps_8h.html#a27d356b912141651e96cfef9b100c5f1">XUsbPs_ClrBits</a>(InstancePtr, <a class="code" href="xusbps__hw_8h.html#af7c6b9afa93b84998286417434bff9bc">XUSBPS_TIMER0_CTL_OFFSET</a>,           \
                <a class="code" href="xusbps__hw_8h.html#a87e12fac25dadaf4481a4a7140c1bcc0">XUSBPS_TIMER_RUN_MASK</a>)
</pre></div><p>This macro stops Timer 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xusbps_8h.html#aec886a5a612b352fecd24d60259ebb5b">XUsbPs_StopTimer0(XUsbPs *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a57f0ece484636153f47b87cfd7eeaa75"></a><!-- doxytag: member="xusbps.h::XUSBPS_TIMEOUT_COUNTER" ref="a57f0ece484636153f47b87cfd7eeaa75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSBPS_TIMEOUT_COUNTER&nbsp;&nbsp;&nbsp;1000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a5c6f9d3b7850e3256d48c037bdd713fd"></a><!-- doxytag: member="xusbps.h::XUsbPs_dQH" ref="a5c6f9d3b7850e3256d48c037bdd713fd" args="[XUSBPS_dQH_ALIGN]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u8 <a class="el" href="xusbps_8h.html#a5c6f9d3b7850e3256d48c037bdd713fd">XUsbPs_dQH</a>[XUSBPS_dQH_ALIGN]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c5399f5d7978baf54eed460d1099d48"></a><!-- doxytag: member="xusbps.h::XUsbPs_dTD" ref="a7c5399f5d7978baf54eed460d1099d48" args="[XUSBPS_dTD_ALIGN]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef u8 <a class="el" href="xusbps_8h.html#a7c5399f5d7978baf54eed460d1099d48">XUsbPs_dTD</a>[XUSBPS_dTD_ALIGN]</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae8ddd7172b8cd5bb0059d6f3c42707d9"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpHandlerFunc" ref="ae8ddd7172b8cd5bb0059d6f3c42707d9" args=")(void *CallBackRef, u8 EpNum, u8 EventType, void *Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xusbps_8h.html#ae8ddd7172b8cd5bb0059d6f3c42707d9">XUsbPs_EpHandlerFunc</a>)(void *CallBackRef, u8 EpNum, u8 EventType, void *Data)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a874b9f224a6f0b430a95ec2d143173b4"></a><!-- doxytag: member="xusbps.h::XUsbPs_IntrHandlerFunc" ref="a874b9f224a6f0b430a95ec2d143173b4" args=")(void *CallBackRef, u32 IrqMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xusbps_8h.html#a874b9f224a6f0b430a95ec2d143173b4">XUsbPs_IntrHandlerFunc</a>)(void *CallBackRef, u32 IrqMask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa47418bedd29f6bc36e075b124227eb0"></a><!-- doxytag: member="xusbps.h::XUsbPs_BusReset" ref="aa47418bedd29f6bc36e075b124227eb0" args="(XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_BusReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>DEVICE mode specific functions. </p>

</div>
</div>
<a class="anchor" id="a6bca90ee01163af1b154966082b91a92"></a><!-- doxytag: member="xusbps.h::XUsbPs_CfgInitialize" ref="a6bca90ee01163af1b154966082b91a92" args="(XUsbPs *InstancePtr, const XUsbPs_Config *ConfigPtr, u32 BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>VirtBaseAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup / Initialize functions.</p>
<p>Implemented in file <a class="el" href="xusbps_8c.html">xusbps.c</a></p>
<p>This function initializes a <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance/driver.</p>
<p>The initialization entails:</p>
<ul>
<li>Initialize all members of the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> structure.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> configuration structure. This structure will contain the requested configuration for the device. Typically, this is a local structure and the content of which will be copied into the configuration structure within <a class="el" href="struct_x_usb_ps.html">XUsbPs</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtBaseAddress</em>&nbsp;</td><td>is the base address of the device. For systems with virtual memory, this address must be the virtual address of the device. For systems that do not support virtual memory this address should be the physical address of the device. For backwards compatibilty NULL may be passed in systems that do not support virtual memory (deprecated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS no errors occured.</li>
<li>XST_FAILURE an error occured during initialization.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After calling <a class="el" href="xusbps_8c.html#a1a3417695facf9eff86ce6a1e14a9bbc">XUsbPs_CfgInitialize()</a> the controller IS NOT READY for use. Before the controller can be used its DEVICE parameters must be configured. See <a class="el" href="xusbps_8h.html">xusbps.h</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="a6daace32113a806a6822a6d5943a93f4"></a><!-- doxytag: member="xusbps.h::XUsbPs_ConfigureDevice" ref="a6daace32113a806a6822a6d5943a93f4" args="(XUsbPs *InstancePtr, const XUsbPs_DeviceConfig *CfgPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_ConfigureDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function configures the DEVICE side of the controller. The caller needs to pass in the desired configuration (e.g. number of endpoints) and a DMAable buffer that will hold the Queue Head List and the Transfer Descriptors. The required size for this buffer can be obtained by the caller using the: XUsbPs_DeviceMemRequired() macro.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is a pointer to the configuration structure that contains the desired DEVICE side configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The caller may configure the controller for both, DEVICE and HOST side. </dd></dl>

</div>
</div>
<a class="anchor" id="a69b214c21727c4b1f641d84414f397df"></a><!-- doxytag: member="xusbps.h::XUsbPs_DeviceReset" ref="a69b214c21727c4b1f641d84414f397df" args="(XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsbPs_DeviceReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function performs device reset, device is stopped at the end.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac27a9d64ddf33a2400d7493e301a7192"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpBufferReceive" ref="ac27a9d64ddf33a2400d7493e301a7192" args="(XUsbPs *InstancePtr, u8 EpNum, u8 **BufferPtr, u32 *BufferLenPtr, u32 *Handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpBufferReceive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>BufferLenPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>Handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives a data buffer from the endpoint of the given endpoint number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>(OUT param) is a pointer to the buffer pointer to hold the reference of the data buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLenPtr</em>&nbsp;</td><td>(OUT param) is a pointer to the integer that will hold the buffer length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>is the opaque handle to be used when the buffer is released.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_USB_NO_BUF: No buffer available.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After handling the data in the buffer, the user MUST release the buffer using the Handle by calling the <a class="el" href="xusbps_8h.html#aa01a009151d133f07249d7f932e22f11">XUsbPs_EpBufferRelease()</a> function. </dd></dl>

</div>
</div>
<a class="anchor" id="aa01a009151d133f07249d7f932e22f11"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpBufferRelease" ref="aa01a009151d133f07249d7f932e22f11" args="(u32 Handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsbPs_EpBufferRelease </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns a previously received data buffer to the driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Handle</em>&nbsp;</td><td>is a pointer to the buffer that is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6bfe53ec45a998d5673b80e11ab4d292"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpBufferSend" ref="a6bfe53ec45a998d5673b80e11ab4d292" args="(XUsbPs *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpBufferSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a given data buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is a pointer to the buffer to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLen</em>&nbsp;</td><td>is the Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_USB_BUF_TOO_BIG: Provided buffer is too big (&gt;16kB).</li>
<li>XST_USB_NO_DESC_AVAILABLE: No TX descriptor is available. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a1e4c0735be24ea24b73404db8d18133e"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpBufferSendWithZLT" ref="a1e4c0735be24ea24b73404db8d18133e" args="(XUsbPs *InstancePtr, u8 EpNum, const u8 *BufferPtr, u32 BufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpBufferSendWithZLT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a given data buffer and also zero length packet if the Bufferlen is in multiples of endpoint max packet size.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is a pointer to the buffer to send. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLen</em>&nbsp;</td><td>is the Buffer length.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_USB_BUF_TOO_BIG: Provided buffer is too big (&gt;16kB).</li>
<li>XST_USB_NO_DESC_AVAILABLE: No TX descriptor is available. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a91c44ff9dcae2e47ed8112c8a0779fa1"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpGetSetupData" ref="a91c44ff9dcae2e47ed8112c8a0779fa1" args="(XUsbPs *InstancePtr, int EpNum, XUsbPs_SetupData *SetupDataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpGetSetupData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps___setup_data.html">XUsbPs_SetupData</a> *&nbsp;</td>
          <td class="paramname"> <em>SetupDataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function extracts the Setup Data from a given endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SetupDataPtr</em>&nbsp;</td><td>is a pointer to the setup data structure to be filled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aba0ae2eac9c6b402e32e401333a5b105"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpPrime" ref="aba0ae2eac9c6b402e32e401333a5b105" args="(XUsbPs *InstancePtr, u8 EpNum, u8 Direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function primes an endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a04fb0b564bcd01cdf33e29ca2732656a"></a><!-- doxytag: member="xusbps.h::XUsbPs_EpSetHandler" ref="a04fb0b564bcd01cdf33e29ca2732656a" args="(XUsbPs *InstancePtr, u8 EpNum, u8 Direction, XUsbPs_EpHandlerFunc CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_EpSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xusbps_8h.html#ae8ddd7172b8cd5bb0059d6f3c42707d9">XUsbPs_EpHandlerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler for endpoint events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the number of the endpoint to receive data from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is the direction of the endpoint (bitfield):</p>
<ul>
<li>XUSBPS_EP_DIRECTION_OUT</li>
<li>XUSBPS_EP_DIRECTION_IN </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the Handler callback function. Can be NULL if the user wants to disable the handler entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the user definable data pointer that will be passed back if the handler is called. May be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: The operation completed successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fa8bf48bf7488cebb101c888489efc2"></a><!-- doxytag: member="xusbps.h::XUsbPs_IntrHandler" ref="a1fa8bf48bf7488cebb101c888489efc2" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsbPs_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>HandlerRef</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the first-level interrupt handler for the USB core. All USB interrupts will be handled here. Depending on the type of the interrupt, second level interrupt handler may be called. Second level interrupt handlers will be registered by the user using the: <a class="el" href="xusbps_8h.html#a521c050d3b146bb58862f5fadf7f6ba6">XUsbPs_IntrSetHandler()</a> and/or <a class="el" href="xusbps_8h.html#a04fb0b564bcd01cdf33e29ca2732656a">XUsbPs_EpSetHandler()</a> functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>HandlerRef</em>&nbsp;</td><td>is a Reference passed to the interrupt register function. In our case this will be a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a521c050d3b146bb58862f5fadf7f6ba6"></a><!-- doxytag: member="xusbps.h::XUsbPs_IntrSetHandler" ref="a521c050d3b146bb58862f5fadf7f6ba6" args="(XUsbPs *InstancePtr, XUsbPs_IntrHandlerFunc CallBackFunc, void *CallBackRef, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_IntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xusbps_8h.html#a874b9f224a6f0b430a95ec2d143173b4">XUsbPs_IntrHandlerFunc</a>&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function registers the user callback handler for controller (non-endpoint) interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the Callback function to register. CallBackFunc may be NULL to clear the entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the user data reference passed to the callback function. CallBackRef may be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the User interrupt mask. Defines which interrupts will cause the callback to be called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Callback registered successfully.</li>
<li>XST_FAILURE: Callback could not be registered.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0fc08318389471729fc392623e001ce"></a><!-- doxytag: member="xusbps.h::XUsbPs_LookupConfig" ref="ad0fc08318389471729fc392623e001ce" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a>* XUsbPs_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the controller configuration based on the unique controller ID. A table contains the configuration info for each controller in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceID</em>&nbsp;</td><td>is the ID of the controller to look up the configuration for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the configuration found or NULL if the specified controller ID was not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a90aab040f015299b2064124bed882896"></a><!-- doxytag: member="xusbps.h::XUsbPs_ReconfigureEp" ref="a90aab040f015299b2064124bed882896" args="(XUsbPs *InstancePtr, XUsbPs_DeviceConfig *CfgPtr, int EpNum, unsigned short NewDirection, int DirectionChanged)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_ReconfigureEp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps___device_config.html">XUsbPs_DeviceConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>NewDirection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>DirectionChanged</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reconfigures one Ep corresponding to host's request of setting alternate interface. The endpoint has been disabled before this call.</p>
<p>Both QH and dTDs are updated for the new configuration.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>Pointer to the updated <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> DEVICE configuration structure.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>The endpoint to be reconfigured.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewDirection</em>&nbsp;</td><td>The new transfer direction the endpoint.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DirectionChanged</em>&nbsp;</td><td>A boolean value indicate whether the transfer direction has changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS upon success, XST_FAILURE otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc88831ee2823e24d7024e585704772"></a><!-- doxytag: member="xusbps.h::XUsbPs_RequestHostResume" ref="a5dc88831ee2823e24d7024e585704772" args="(const XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_RequestHostResume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Assert Resume</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the USB device has Resumed successfully</li>
<li>XST_FAILURE on any error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c583a4c515653fd70c111fe0d2ddb37"></a><!-- doxytag: member="xusbps.h::XUsbPs_Reset" ref="a2c583a4c515653fd70c111fe0d2ddb37" args="(XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Common functions used for DEVICE/HOST mode.</p>
<p>This function resets the USB device. All the configuration registers are reset to their default values. The function waits until the reset operation is complete or for a certain duration within which the reset operation is expected to be completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS Reset operation completed successfully.</li>
<li>XST_FAILURE Reset operation timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa71f906531330b2f05ede2f17ab54c69"></a><!-- doxytag: member="xusbps.h::XUsbPs_Resume" ref="aa71f906531330b2f05ede2f17ab54c69" args="(const XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_Resume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Resume</p>
<p>If the USB controller is suspended, its operation is resumed when any non-idle signaling is received on its upstream facing port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the USB device has Resumed successfully</li>
<li>XST_FAILURE on any error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c700bcf9ba08271914145803776d265"></a><!-- doxytag: member="xusbps.h::XUsbPs_SetDeviceAddress" ref="a8c700bcf9ba08271914145803776d265" args="(XUsbPs *InstancePtr, u8 Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_SetDeviceAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sets the controller's DEVICE address. It also sets the advance bit so the controller will wait for the next IN-ACK before the new address takes effect.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the Address of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Address set successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed, e.g. address value too big.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f25904ea86f189b6597c0dff795f61f"></a><!-- doxytag: member="xusbps.h::XUsbPs_Suspend" ref="a0f25904ea86f189b6597c0dff795f61f" args="(const XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_Suspend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handling Suspend and Resume.</p>
<p>Implemented in <a class="el" href="xusbps_8c.html">xusbps.c</a></p>
<p>USB Suspend</p>
<p>In order to conserve power, USB devices automatically enter the suspended state when the device has observed no bus traffic for a specified period. When suspended, the USB device maintains any internal status, including its address and configuration. Attached devices must be prepared to suspend at any time they are powered, regardless of if they have been assigned a non-default address, are configured, or neither. Bus activity may cease due to the host entering a suspend mode of its own. In addition, a USB device shall also enter the suspended state when the hub port it is attached to is disabled.</p>
<p>A USB device exits suspend mode when there is bus activity. A USB device may also request the host to exit suspend mode or selective suspend by using electrical signaling to indicate remote wakeup. The ability of a device to signal remote wakeup is optional. If the USB device is capable of remote wakeup signaling, the device must support the ability of the host to enable and disable this capability. When the device is reset, remote wakeup signaling must be disabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the USB device has entered Suspend mode successfully</li>
<li>XST_FAILURE on any error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
