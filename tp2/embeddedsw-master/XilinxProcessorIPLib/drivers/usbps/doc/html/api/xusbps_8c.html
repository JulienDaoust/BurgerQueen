<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver usbps v2_2: xusbps.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xusbps.c File Reference</h1><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="xusbps_8h.html">xusbps.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#a1a3417695facf9eff86ce6a1e14a9bbc">XUsbPs_CfgInitialize</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, const <a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> *ConfigPtr, u32 VirtBaseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#a69b214c21727c4b1f641d84414f397df">XUsbPs_DeviceReset</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#a2c583a4c515653fd70c111fe0d2ddb37">XUsbPs_Reset</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#a0f25904ea86f189b6597c0dff795f61f">XUsbPs_Suspend</a> (const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#aa71f906531330b2f05ede2f17ab54c69">XUsbPs_Resume</a> (const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#a5dc88831ee2823e24d7024e585704772">XUsbPs_RequestHostResume</a> (const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusbps_8c.html#a8c700bcf9ba08271914145803776d265">XUsbPs_SetDeviceAddress</a> (<a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *InstancePtr, u8 Address)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> driver. Functions in this file are the minimum required functions for this driver. See <a class="el" href="xusbps_8h.html">xusbps.h</a> for a detailed description of the driver.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None.</dd></dl>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -------- --------------------------------------------------------
 1.00a jz  10/10/10 First release
 2.1   kpc 04/28/14 Removed ununsed functions
 </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1a3417695facf9eff86ce6a1e14a9bbc"></a><!-- doxytag: member="xusbps.c::XUsbPs_CfgInitialize" ref="a1a3417695facf9eff86ce6a1e14a9bbc" args="(XUsbPs *InstancePtr, const XUsbPs_Config *ConfigPtr, u32 VirtBaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>VirtBaseAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes a <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance/driver.</p>
<p>The initialization entails:</p>
<ul>
<li>Initialize all members of the <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> structure.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_usb_ps___config.html">XUsbPs_Config</a> configuration structure. This structure will contain the requested configuration for the device. Typically, this is a local structure and the content of which will be copied into the configuration structure within <a class="el" href="struct_x_usb_ps.html">XUsbPs</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtBaseAddress</em>&nbsp;</td><td>is the base address of the device. For systems with virtual memory, this address must be the virtual address of the device. For systems that do not support virtual memory this address should be the physical address of the device. For backwards compatibilty NULL may be passed in systems that do not support virtual memory (deprecated).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS no errors occured.</li>
<li>XST_FAILURE an error occured during initialization.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After calling <a class="el" href="xusbps_8c.html#a1a3417695facf9eff86ce6a1e14a9bbc">XUsbPs_CfgInitialize()</a> the controller IS NOT READY for use. Before the controller can be used its DEVICE parameters must be configured. See <a class="el" href="xusbps_8h.html">xusbps.h</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="a69b214c21727c4b1f641d84414f397df"></a><!-- doxytag: member="xusbps.c::XUsbPs_DeviceReset" ref="a69b214c21727c4b1f641d84414f397df" args="(XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsbPs_DeviceReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function performs device reset, device is stopped at the end.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dc88831ee2823e24d7024e585704772"></a><!-- doxytag: member="xusbps.c::XUsbPs_RequestHostResume" ref="a5dc88831ee2823e24d7024e585704772" args="(const XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_RequestHostResume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Assert Resume</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the USB device has Resumed successfully</li>
<li>XST_FAILURE on any error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c583a4c515653fd70c111fe0d2ddb37"></a><!-- doxytag: member="xusbps.c::XUsbPs_Reset" ref="a2c583a4c515653fd70c111fe0d2ddb37" args="(XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the USB device. All the configuration registers are reset to their default values. The function waits until the reset operation is complete or for a certain duration within which the reset operation is expected to be completed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS Reset operation completed successfully.</li>
<li>XST_FAILURE Reset operation timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa71f906531330b2f05ede2f17ab54c69"></a><!-- doxytag: member="xusbps.c::XUsbPs_Resume" ref="aa71f906531330b2f05ede2f17ab54c69" args="(const XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_Resume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Resume</p>
<p>If the USB controller is suspended, its operation is resumed when any non-idle signaling is received on its upstream facing port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the USB device has Resumed successfully</li>
<li>XST_FAILURE on any error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c700bcf9ba08271914145803776d265"></a><!-- doxytag: member="xusbps.c::XUsbPs_SetDeviceAddress" ref="a8c700bcf9ba08271914145803776d265" args="(XUsbPs *InstancePtr, u8 Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_SetDeviceAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sets the controller's DEVICE address. It also sets the advance bit so the controller will wait for the next IN-ACK before the new address takes effect.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the Address of the device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Address set successfully.</li>
<li>XST_FAILURE: An error occured.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed, e.g. address value too big.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f25904ea86f189b6597c0dff795f61f"></a><!-- doxytag: member="xusbps.c::XUsbPs_Suspend" ref="a0f25904ea86f189b6597c0dff795f61f" args="(const XUsbPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsbPs_Suspend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>USB Suspend</p>
<p>In order to conserve power, USB devices automatically enter the suspended state when the device has observed no bus traffic for a specified period. When suspended, the USB device maintains any internal status, including its address and configuration. Attached devices must be prepared to suspend at any time they are powered, regardless of if they have been assigned a non-default address, are configured, or neither. Bus activity may cease due to the host entering a suspend mode of its own. In addition, a USB device shall also enter the suspended state when the hub port it is attached to is disabled.</p>
<p>A USB device exits suspend mode when there is bus activity. A USB device may also request the host to exit suspend mode or selective suspend by using electrical signaling to indicate remote wakeup. The ability of a device to signal remote wakeup is optional. If the USB device is capable of remote wakeup signaling, the device must support the ability of the host to enable and disable this capability. When the device is reset, remote wakeup signaling must be disabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to <a class="el" href="struct_x_usb_ps.html">XUsbPs</a> instance of the controller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the USB device has entered Suspend mode successfully</li>
<li>XST_FAILURE on any error</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
