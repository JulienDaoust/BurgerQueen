<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver gpio v4_0: xgpio.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xgpio.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_gpio.html">XGpio</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a00bfede0e6dcb1bac3e63d0e35d993f0">XGPIO_H</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a080482882d1f60cbd84b8e4ea856560c">XGpio_Initialize</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a41a28089e4c737cc4b08d35e5b142606">XGpio_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a0e136b38b58ea4e7f299484b0d0beddc">XGpio_CfgInitialize</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, <a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#abee6bcad28382ef5ecd336887647c238">XGpio_SetDataDirection</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 DirectionMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a77090853c15dc3d72e2bfbc66e635ada">XGpio_GetDataDirection</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#aed95c58f21d567fca624f9f51cb25e20">XGpio_DiscreteRead</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#ae188a28725318c991ac45afb2452ad9b">XGpio_DiscreteWrite</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a8f2cea7ef78412c03c7ebdba87b7cdd4">XGpio_DiscreteSet</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#ae430718af9f347c91be42aad580b216c">XGpio_DiscreteClear</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#af01e2f4d8e75fa4922a5d92798be7b25">XGpio_SelfTest</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a6241d0ae28815c258bb89a61ce0a6366">XGpio_InterruptGlobalDisable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a21c295f935fdc4e37c9f958b3652fbf6">XGpio_InterruptDisable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a5138b55159f8b2387f5cf16079b40bbe">XGpio_InterruptClear</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a1e5e23001aa3d35febe4859270ede71e">XGpio_InterruptGetEnabled</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio_8h.html#a95b0fa50ff962243ea284a4a767fe01e">XGpio_InterruptGetStatus</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a00bfede0e6dcb1bac3e63d0e35d993f0"></a><!-- doxytag: member="xgpio.h::XGPIO_H" ref="a00bfede0e6dcb1bac3e63d0e35d993f0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPIO_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0e136b38b58ea4e7f299484b0d0beddc"></a><!-- doxytag: member="xgpio.h::XGpio_CfgInitialize" ref="a0e136b38b58ea4e7f299484b0d0beddc" args="(XGpio *InstancePtr, XGpio_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XGpio_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="struct_x_gpio.html">XGpio</a> instance provided by the caller based on the given configuration data.</p>
<p>Nothing is done except to initialize the InstancePtr.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance. The memory the pointer references must be pre-allocated by the caller. Further calls to manipulate the driver through the <a class="el" href="struct_x_gpio.html">XGpio</a> API must be made with this pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific GPIO device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS Initialization was successfull.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae430718af9f347c91be42aad580b216c"></a><!-- doxytag: member="xgpio.h::XGpio_DiscreteClear" ref="ae430718af9f347c91be42aad580b216c" args="(XGpio *InstancePtr, unsigned Channel, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_DiscreteClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set output discrete(s) to logic 0 for the specified GPIO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the set of bits that will be set to 0 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert.</p>
<p>This API can only be used if the GPIO_IO ports in the IP are used for connecting to the external output ports. </p>

</div>
</div>
<a class="anchor" id="aed95c58f21d567fca624f9f51cb25e20"></a><!-- doxytag: member="xgpio.h::XGpio_DiscreteRead" ref="aed95c58f21d567fca624f9f51cb25e20" args="(XGpio *InstancePtr, unsigned Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_DiscreteRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read state of discretes for the specified GPIO channnel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1 or 2) to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current copy of the discretes register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2cea7ef78412c03c7ebdba87b7cdd4"></a><!-- doxytag: member="xgpio.h::XGpio_DiscreteSet" ref="a8f2cea7ef78412c03c7ebdba87b7cdd4" args="(XGpio *InstancePtr, unsigned Channel, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_DiscreteSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set output discrete(s) to logic 1 for the specified GPIO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the set of bits that will be set to 1 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert.</p>
<p>This API can only be used if the GPIO_IO ports in the IP are used for connecting to the external output ports. </p>

</div>
</div>
<a class="anchor" id="ae188a28725318c991ac45afb2452ad9b"></a><!-- doxytag: member="xgpio.h::XGpio_DiscreteWrite" ref="ae188a28725318c991ac45afb2452ad9b" args="(XGpio *InstancePtr, unsigned Channel, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_DiscreteWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to discretes register for the specified GPIO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the value to be written to the discretes register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. See also <a class="el" href="xgpio_8h.html#a8f2cea7ef78412c03c7ebdba87b7cdd4">XGpio_DiscreteSet()</a> and <a class="el" href="xgpio_8h.html#ae430718af9f347c91be42aad580b216c">XGpio_DiscreteClear()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a77090853c15dc3d72e2bfbc66e635ada"></a><!-- doxytag: member="xgpio.h::XGpio_GetDataDirection" ref="a77090853c15dc3d72e2bfbc66e635ada" args="(XGpio *InstancePtr, unsigned Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_GetDataDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the input/output direction of all discrete signals for the specified GPIO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1 or 2) to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Bitmask specifying which discretes are input and which are output. Bits set to 0 are output and bits set to 1 are input.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. </p>

</div>
</div>
<a class="anchor" id="a080482882d1f60cbd84b8e4ea856560c"></a><!-- doxytag: member="xgpio.h::XGpio_Initialize" ref="a080482882d1f60cbd84b8e4ea856560c" args="(XGpio *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XGpio_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="struct_x_gpio.html">XGpio</a> instance provided by the caller based on the given DeviceID.</p>
<p>Nothing is done except to initialize the InstancePtr.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance. The memory the pointer references must be pre-allocated by the caller. Further calls to manipulate the instance/driver through the <a class="el" href="struct_x_gpio.html">XGpio</a> API must be made with this pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_gpio.html">XGpio</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_gpio.html">XGpio</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the initialization was successfull.</li>
<li>XST_DEVICE_NOT_FOUND if the device configuration data was not found for a device with the supplied device ID.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5138b55159f8b2387f5cf16079b40bbe"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptClear" ref="a5138b55159f8b2387f5cf16079b40bbe" args="(XGpio *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear pending interrupts with the provided mask. This function should be called after the software has serviced the interrupts that are pending. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to clear pending interrupts for. Bit positions of 1 are cleared. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a21c295f935fdc4e37c9f958b3652fbf6"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptDisable" ref="a21c295f935fdc4e37c9f958b3652fbf6" args="(XGpio *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable interrupts. This function allows specific interrupts for each channel to be disabled. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to disable. Bits set to 1 are disabled. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b62394f65ecbb6566d91412616509c"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptEnable" ref="aa5b62394f65ecbb6566d91412616509c" args="(XGpio *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable interrupts. The global interrupt must also be enabled by calling <a class="el" href="xgpio_8h.html#a116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable()</a> for interrupts to occur. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to enable. Bit positions of 1 are enabled. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5e23001aa3d35febe4859270ede71e"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptGetEnabled" ref="a1e5e23001aa3d35febe4859270ede71e" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_InterruptGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the interrupt enable mask. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mask of bits made from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</dd>
<dd>
None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a95b0fa50ff962243ea284a4a767fe01e"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptGetStatus" ref="a95b0fa50ff962243ea284a4a767fe01e" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_InterruptGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the status of interrupt signals. Any bit in the mask set to 1 indicates that the channel associated with the bit has asserted an interrupt condition. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a mask of bits made from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The interrupt status indicates the status of the device irregardless if the interrupts from the devices have been enabled or not through <a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a>. </p>

</div>
</div>
<a class="anchor" id="a6241d0ae28815c258bb89a61ce0a6366"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptGlobalDisable" ref="a6241d0ae28815c258bb89a61ce0a6366" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptGlobalDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable the interrupt output signal. Interrupts enabled through <a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a> will no longer be passed through until the global enable bit is set by <a class="el" href="xgpio_8h.html#a116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable()</a>. This function is designed to allow all interrupts (both channels) to be disabled easily for entering a critical section. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a116bf1509220aa688f76f80501eb0d9e"></a><!-- doxytag: member="xgpio.h::XGpio_InterruptGlobalEnable" ref="a116bf1509220aa688f76f80501eb0d9e" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptGlobalEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the interrupt output signal. Interrupts enabled through <a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a> will not be passed through until the global enable bit is set by this function. This function is designed to allow all interrupts (both channels) to be enabled easily for exiting a critical section. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a41a28089e4c737cc4b08d35e5b142606"></a><!-- doxytag: member="xgpio.h::XGpio_LookupConfig" ref="a41a28089e4c737cc4b08d35e5b142606" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_gpio___config.html">XGpio_Config</a>* XGpio_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lookup the device configuration based on the unique device ID. The table ConfigTable contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the device identifier to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>A pointer of data type <a class="el" href="struct_x_gpio___config.html">XGpio_Config</a> which points to the device configuration if DeviceID is found.</li>
</ul>
</dd></dl>
<ul>
<li>NULL if DeviceID is not found.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af01e2f4d8e75fa4922a5d92798be7b25"></a><!-- doxytag: member="xgpio.h::XGpio_SelfTest" ref="af01e2f4d8e75fa4922a5d92798be7b25" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XGpio_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run a self-test on the driver/device. This function does a minimal test in which the data register is read. It only does a read without any kind of test because the hardware has been parameterized such that it may be only an input such that the state of the inputs won't be known.</p>
<p>All other hardware features of the device are not guaranteed to be in the hardware since they are parameterizable.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. This parameter must have been previously initialized with <a class="el" href="xgpio_8h.html#a080482882d1f60cbd84b8e4ea856560c">XGpio_Initialize()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS always. If the GPIO device was not present in the hardware a bus error could be generated. Other indicators of a bus error, such as registers in bridges or buses, may be necessary to determine if this function caused a bus error.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abee6bcad28382ef5ecd336887647c238"></a><!-- doxytag: member="xgpio.h::XGpio_SetDataDirection" ref="abee6bcad28382ef5ecd336887647c238" args="(XGpio *InstancePtr, unsigned Channel, u32 DirectionMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_SetDataDirection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DirectionMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the input/output direction of all discrete signals for the specified GPIO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_gpio.html">XGpio</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1 or 2) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DirectionMask</em>&nbsp;</td><td>is a bitmask specifying which discretes are input and which are output. Bits set to 0 are output and bits set to 1 are input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The hardware must be built for dual channels if this function is used with any channel other than 1. If it is not, this function will assert. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
