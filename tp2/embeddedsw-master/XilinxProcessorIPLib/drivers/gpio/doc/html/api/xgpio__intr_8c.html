<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver gpio v4_0: xgpio_intr.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xgpio_intr.c File Reference</h1><code>#include &quot;<a class="el" href="xgpio_8h.html">xgpio.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#a116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#a6241d0ae28815c258bb89a61ce0a6366">XGpio_InterruptGlobalDisable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#a21c295f935fdc4e37c9f958b3652fbf6">XGpio_InterruptDisable</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#a5138b55159f8b2387f5cf16079b40bbe">XGpio_InterruptClear</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#a1e5e23001aa3d35febe4859270ede71e">XGpio_InterruptGetEnabled</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xgpio__intr_8c.html#a95b0fa50ff962243ea284a4a767fe01e">XGpio_InterruptGetStatus</a> (<a class="el" href="struct_x_gpio.html">XGpio</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implements GPIO interrupt processing functions for the <a class="el" href="struct_x_gpio.html">XGpio</a> driver. See <a class="el" href="xgpio_8h.html">xgpio.h</a> for more information about the driver.</p>
<p>The functions in this file require the hardware device to be built with interrupt capabilities. The functions will assert if called using hardware that does not have interrupt capabilities.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 2.00a jhl  11/26/03 Initial release
 2.11a mta  03/21/07 Updated to new coding style
 2.12a sv   06/05/08 Updated driver to fix the XGpio_InterruptDisable function
		      to properly update the Interrupt Enable register
 3.00a sv   11/21/09 Updated to use HAL Processor APIs. Renamed the macros
		      XGpio_mWriteReg to XGpio_WriteReg, and XGpio_mReadReg
		      to XGpio_ReadReg.</pre><pre> </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5138b55159f8b2387f5cf16079b40bbe"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptClear" ref="a5138b55159f8b2387f5cf16079b40bbe" args="(XGpio *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear pending interrupts with the provided mask. This function should be called after the software has serviced the interrupts that are pending. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to clear pending interrupts for. Bit positions of 1 are cleared. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a21c295f935fdc4e37c9f958b3652fbf6"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptDisable" ref="a21c295f935fdc4e37c9f958b3652fbf6" args="(XGpio *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable interrupts. This function allows specific interrupts for each channel to be disabled. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to disable. Bits set to 1 are disabled. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5b62394f65ecbb6566d91412616509c"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptEnable" ref="aa5b62394f65ecbb6566d91412616509c" args="(XGpio *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable interrupts. The global interrupt must also be enabled by calling <a class="el" href="xgpio_8h.html#a116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable()</a> for interrupts to occur. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to enable. Bit positions of 1 are enabled. This mask is formed by OR'ing bits from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e5e23001aa3d35febe4859270ede71e"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptGetEnabled" ref="a1e5e23001aa3d35febe4859270ede71e" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_InterruptGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the interrupt enable mask. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mask of bits made from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</dd>
<dd>
None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a95b0fa50ff962243ea284a4a767fe01e"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptGetStatus" ref="a95b0fa50ff962243ea284a4a767fe01e" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XGpio_InterruptGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the status of interrupt signals. Any bit in the mask set to 1 indicates that the channel associated with the bit has asserted an interrupt condition. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a mask of bits made from XGPIO_IR* bits which are contained in <a class="el" href="xgpio__l_8h.html">xgpio_l.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The interrupt status indicates the status of the device irregardless if the interrupts from the devices have been enabled or not through <a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a>. </p>

</div>
</div>
<a class="anchor" id="a6241d0ae28815c258bb89a61ce0a6366"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptGlobalDisable" ref="a6241d0ae28815c258bb89a61ce0a6366" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptGlobalDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable the interrupt output signal. Interrupts enabled through <a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a> will no longer be passed through until the global enable bit is set by <a class="el" href="xgpio_8h.html#a116bf1509220aa688f76f80501eb0d9e">XGpio_InterruptGlobalEnable()</a>. This function is designed to allow all interrupts (both channels) to be disabled easily for entering a critical section. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a116bf1509220aa688f76f80501eb0d9e"></a><!-- doxytag: member="xgpio_intr.c::XGpio_InterruptGlobalEnable" ref="a116bf1509220aa688f76f80501eb0d9e" args="(XGpio *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XGpio_InterruptGlobalEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_gpio.html">XGpio</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable the interrupt output signal. Interrupts enabled through <a class="el" href="xgpio_8h.html#aa5b62394f65ecbb6566d91412616509c">XGpio_InterruptEnable()</a> will not be passed through until the global enable bit is set by this function. This function is designed to allow all interrupts (both channels) to be enabled easily for exiting a critical section. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the GPIO instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
