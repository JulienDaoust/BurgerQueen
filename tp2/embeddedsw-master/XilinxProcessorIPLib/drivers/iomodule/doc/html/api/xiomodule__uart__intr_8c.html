<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver iomodule v2_1: xiomodule_uart_intr.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xiomodule_uart_intr.c File Reference</h1><code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiomodule_8h.html">xiomodule.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiomodule__i_8h.html">xiomodule_i.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiomodule__l_8h.html">xiomodule_l.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a7c7eb802878944c1e915ea06e07679a2">Handler</a> )(<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a6db3efbd9634e6f58b9fb6a67f82b8c2">XIOModule_Send</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#ae9e27102d95385e1557fd488da7b2936">XIOModule_Recv</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#adabb5f2e09817afb284173f31f3d7265">XIOModule_ResetFifos</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#aa582b33e2d93e0f0072b3235ed6fb741">XIOModule_IsSending</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a1fc16de9c0cbaad1d3022d19a0d883cd">XIOModule_SendBuffer</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a70b12729029fff571ad8915dc30897d6">XIOModule_ReceiveBuffer</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a5ece62521d0d34bd420888ecc876750c">XIOModule_SetRecvHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a07b376ebf11fee3ff027445eaa096261">XIOModule_SetSendHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#acf2a67095f9797403f5c269fdcd7a6b2">XIOModule_Uart_InterruptHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#a5ec72d0dd352ad42de494821220e3185">XIOModule_Uart_DisableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__uart__intr_8c.html#aa805a7f9982d9acc5b3b16849c5d2dfd">XIOModule_Uart_EnableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains required functions for the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> UART driver interrupt mode. See the <a class="el" href="xiomodule_8h.html">xiomodule.h</a> header file for more details on this driver.</p>
<p>This file also contains interrupt-related functions for the UART.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------
 1.03a sa   10/16/12 First release
 </pre> <hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a7c7eb802878944c1e915ea06e07679a2"></a><!-- doxytag: member="xiomodule_uart_intr.c::Handler" ref="a7c7eb802878944c1e915ea06e07679a2" args=")(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiomodule__uart__intr_8c.html#a7c7eb802878944c1e915ea06e07679a2">Handler</a>)(<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="aa582b33e2d93e0f0072b3235ed6fb741"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_IsSending" ref="aa582b33e2d93e0f0072b3235ed6fb741" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_IsSending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function determines if the specified UART is sending data. If the transmitter register is not empty, it is sending data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value of TRUE if the UART is sending data, otherwise FALSE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a70b12729029fff571ad8915dc30897d6"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_ReceiveBuffer" ref="a70b12729029fff571ad8915dc30897d6" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_ReceiveBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives a buffer that has been previously specified by setting up the instance variables of the instance. This function is designed to be an internal function for the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.</p>
<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if there is no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer, either in the receiver or in the FIFO if present and enabled. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9e27102d95385e1557fd488da7b2936"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Recv" ref="ae9e27102d95385e1557fd488da7b2936" args="(XIOModule *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_Recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer in the receiver. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue receiving data until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBufferPtr</em>&nbsp;</td><td>is pointer to buffer for data to be received into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to be received. A value of zero will stop a previous receive operation that is in progress in interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="adabb5f2e09817afb284173f31f3d7265"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_ResetFifos" ref="adabb5f2e09817afb284173f31f3d7265" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_ResetFifos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function does nothing, since the UART doesn't have any FIFOs. It is included for compatibility with the UART Lite driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6db3efbd9634e6f58b9fb6a67f82b8c2"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Send" ref="a6db3efbd9634e6f58b9fb6a67f82b8c2" args="(XIOModule *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART. If the UART is busy sending data, it will return and indicate zero bytes were sent.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue sending data until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBufferPtr</em>&nbsp;</td><td>is pointer to a buffer of data to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>contains the number of bytes to be sent. A value of zero will stop a previous send operation that is in progress in interrupt mode. Any data that was already put into the transmit FIFO will be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually sent.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fc16de9c0cbaad1d3022d19a0d883cd"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_SendBuffer" ref="a1fc16de9c0cbaad1d3022d19a0d883cd" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_SendBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a buffer that has been previously specified by setting up the instance variables of the instance. This function is designed to be an internal function for the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> component such that it may be called from a shell function that sets up the buffer or from an interrupt handler.</p>
<p>This function sends the specified buffer of data to the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>NumBytes is the number of bytes actually sent (put into the UART transmitter and/or FIFO).</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ece62521d0d34bd420888ecc876750c"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_SetRecvHandler" ref="a5ece62521d0d34bd420888ecc876750c" args="(XIOModule *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetRecvHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. The purpose of the handler is to allow application specific processing to be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

</div>
</div>
<a class="anchor" id="a07b376ebf11fee3ff027445eaa096261"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_SetSendHandler" ref="a07b376ebf11fee3ff027445eaa096261" args="(XIOModule *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetSendHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. The purpose of the handler is to allow application specific processing to be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

</div>
</div>
<a class="anchor" id="a5ec72d0dd352ad42de494821220e3185"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Uart_DisableInterrupt" ref="a5ec72d0dd352ad42de494821220e3185" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_DisableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the UART interrupt. After calling this function, data may still be received by the UART but no interrupt will be generated since the hardware device has no way to disable the receiver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa805a7f9982d9acc5b3b16849c5d2dfd"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Uart_EnableInterrupt" ref="aa805a7f9982d9acc5b3b16849c5d2dfd" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_EnableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the UART interrupts such that an interrupt will occur when data is received or data has been transmitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="acf2a67095f9797403f5c269fdcd7a6b2"></a><!-- doxytag: member="xiomodule_uart_intr.c::XIOModule_Uart_InterruptHandler" ref="acf2a67095f9797403f5c269fdcd7a6b2" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the UART. It must be connected to an interrupt system by the user such that it is called when an interrupt for any UART lite occurs. This function does not save or restore the processor context such that the user must ensure this occurs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>contains a pointer to the instance of the IOModule that the interrupt is for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
