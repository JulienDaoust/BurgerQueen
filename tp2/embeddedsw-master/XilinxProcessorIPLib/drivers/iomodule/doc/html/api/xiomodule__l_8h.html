<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver iomodule v2_1: xiomodule_l.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xiomodule_l.h File Reference</h1><code>#include &quot;xparameters.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiomodule__io_8h.html">xiomodule_io.h</a>&quot;</code><br/>
<code>#include &quot;xio.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___vector_table_entry.html">XIOModule_VectorTableEntry</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a74193c76002b6f0b67f1e34f2147d872">XIOMODULE_L_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aba99b973ef1f13bf0a2716cf52ca5319">XTC_DEVICE_TIMER_COUNT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a22c78277a54b31ec738e72eca0662e35">XTC_TIMER_COUNTER_OFFSET</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a00c47cf9cd8ee813a05416adba5cd8ba">XTC_TIMER_COUNTER_SHIFT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ad3154a9fc1e2fd70c0cc37772e15b907">XUL_RX_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a0a78233dc7306487ebb9c5adebacac00">XUL_TX_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a13cc5a4dd0ee4939136579f2e8dc9ce5">XUL_STATUS_REG_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aa2bc39bbb18ba649d4afbe729ee246c0">XUL_BAUDRATE_OFFSET</a>&nbsp;&nbsp;&nbsp;0x0000004C</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a2dc06911d25b46e1ddad8e2938f95b4c">XIN_IMR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x0000000C</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a3c685bb29e51f4564a7aea4d2d7fce34">XGO_OUT_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a7602eedbe37417de638a1f7825f80132">XGI_IN_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a4c1ce88ba61c2e42054faaef40539556">XIN_ISR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000030</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a35c8f39e63012c1745df6faa39fc7335">XIN_IPR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000034</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a12fbacf76cabd206d17acefd187fa7b4">XIN_IER_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000038</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#af12b5f9e19d0d544e8df96699db615bd">XIN_IAR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x0000003C</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a38a380fdcb3114c3db51524a8182c4ad">XTC_TLR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ad054cd3c12bc686f9be366e093c2f97a">XTC_TCR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000044</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a81c9a818cb57cf5f106cf5a3b7c3c59f">XTC_TCSR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000048</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ab675a4446c4ab809551ea73ad2ca962d">XIN_IVAR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a33cf5a2b5ddc5ae960235ce37cd6c32f">XUL_SR_PARITY_ERROR</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aa52948dba7418fd7d4a68b47e3770dc1">XUL_SR_FRAMING_ERROR</a>&nbsp;&nbsp;&nbsp;0x40</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a5614aae83f54065f4ca0aa7cdfc7f737">XUL_SR_OVERRUN_ERROR</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aef49f4399d015532ee90cda2c0045324">XUL_SR_INTR_ENABLED</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a76bf6a9a14882e45364a21693be7e920">XUL_SR_TX_FIFO_FULL</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a7a1722c4c799b50641831e1d092d9893">XUL_SR_RX_FIFO_VALID_DATA</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#af9a9355e4872a6de8340af575c2aec72">XUL_STOP_BITS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a3b04347e664ae6d55ebd9d2609191767">XUL_PARITY_NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a12cf047d972692d6f36a88527fc1423e">XUL_PARITY_ODD</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a0e3df7cb0f5abb04b6d391faa34c9098">XUL_PARITY_EVEN</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a230620599fe987b03b47e6d04a442e60">XIOModule_EnableIntr</a>(BaseAddress, EnableMask)&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aaf77d72d553f17c2696ce54e3149f0d0">XIOModule_DisableIntr</a>(BaseAddress, DisableMask)&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ac3f5aa29d205f6221a017a04712c65f0">XIOModule_AckIntr</a>(BaseAddress, AckMask)&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a128f261df0c50d6e1b090e2a9e9d1874">XIOModule_GetIntrStatus</a>(BaseAddress)&nbsp;&nbsp;&nbsp;(XIomodule_In32((BaseAddress) + XIN_IPR_OFFSET))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>(BaseAddress)&nbsp;&nbsp;&nbsp;XIomodule_In32((BaseAddress) + XUL_STATUS_REG_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ad9c5e48a02c0aba03cb1d8d7583b37f6">XIOModule_IsReceiveEmpty</a>(BaseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a93c23372164e627f79da9488ea43161a">XIOModule_IsTransmitFull</a>(BaseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a829c77e3efe996211599f9a2a6bb4890">XIOModule_WriteReg</a>(BaseAddress, RegOffset, Data)&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg</a>(BaseAddress, RegOffset)&nbsp;&nbsp;&nbsp;XIomodule_In32((BaseAddress) + (RegOffset))</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#afb21e053e2c12734dfadd0affbbbc313">XGPI_DEVICE_COUNT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aceeeea01636f70826ad24d82fc75448e">XGPO_DEVICE_COUNT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a9569489084c770e95974e4592e425b66">XGPI_CHAN_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a974d22f8d4af7aa177280efeb78a73f2">XGPI_DATA_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00020</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a17f8dbd54fab445a85c85af18f847049">XGPO_CHAN_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a4e809d2193d7e62366afad472869ea82">XGPO_DATA_OFFSET</a>&nbsp;&nbsp;&nbsp;0x00010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a77dbab318178a69596d6cab5c3971dc9">XIN_IOMODULE_GPI_4_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;14</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a8cb6a48a26f2c9ca43e9d551b29eb3f9">XIN_IOMODULE_GPI_3_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;13</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aeb59d6931cdd71d2272d94da0c849d63">XIN_IOMODULE_GPI_2_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;12</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aa9dd8e7332e3a08d57d1d2f2b250ed9b">XIN_IOMODULE_GPI_1_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;11</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a23989d98b257c17de75a89c7e2fcf3a6">XIN_IOMODULE_FIT_4_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#af92f1cc054c2ae7860feade42b401b14">XIN_IOMODULE_FIT_3_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a17aa65bf1c4d8840162d0c7a7a802a8f">XIN_IOMODULE_FIT_2_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a5259a0a273407770999d48f1c8a59ffe">XIN_IOMODULE_FIT_1_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a5ed96d6e12cc93dccc1f1769854b273c">XIN_IOMODULE_PIT_4_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#acdbb05f5603a36e5e08777b26717cc70">XIN_IOMODULE_PIT_3_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a7ee2a68fc1eece64980870c54c3d0ea5">XIN_IOMODULE_PIT_2_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a81a5045e6a373c91918083c7c37dcb4b">XIN_IOMODULE_PIT_1_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ac80b2d02a20d8813c02659e392695e65">XIN_IOMODULE_UART_RX_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a9cfff2fde145343217879bb2b1637427">XIN_IOMODULE_UART_TX_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a41b98b0520a4712e400178a16cac1128">XIN_IOMODULE_UART_ERROR_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ac279b35b1b56563078139deb18f83729">XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td colspan="2"><div class="groupHeader">Control Status Register Bit Definitions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp77718337863d9bf57fe00a0d3574ed3d"></a> Control Status Register bit masks Used to configure the timer counter device. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aa7cbbacf96f3f51bcd12d5826b03e620">XTC_CSR_ENABLE_TMR_MASK</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ab06d844c7a245c7be88a63f3559bbd46">XTC_CSR_AUTO_RELOAD_MASK</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#ab333e5826535071fe60f13b70b6e56dd">XFastInterruptHandler</a> )(void)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a77e0649e78c817c27b628b6713c12451">XIOModule_SendByte</a> (u32 BaseAddress, u8 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#af1784b245813307028ba028246e39606">XIOModule_RecvByte</a> (u32 BaseAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a6be7aa174efc75d9cff5d72c63fa542c">XIOModule_LowLevelInterruptHandler</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler</a> (void *DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#aaf27e1820d586ec1c487078d03854944">XIOModule_SetIntrSvcOption</a> (u32 BaseAddress, int Option)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule__l_8h.html#a3985a47858bc59f526d475536811a393">XIOModule_RegisterHandler</a> (u32 BaseAddress, int InterruptId, XInterruptHandler <a class="el" href="xiomodule__uart__intr_8c.html#a7c7eb802878944c1e915ea06e07679a2">Handler</a>, void *CallBackRef)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This header file contains identifiers and low-level driver functions (or macros) that can be used to access the device. The user should refer to the hardware device specification for more details of the device operation.</p>
<p>Note that users of the driver interface given in this file can register an interrupt handler dynamically (at run-time) using the XIntc_RegisterHandler() function. User of the driver interface given in <a class="el" href="xiomodule_8h.html">xiomodule.h</a> should still use XIntc_Connect(), as always. Also see the discussion of the interrupt vector tables in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</p>
<p>There are currently two interrupt handlers specified in this interface.</p>
<ul>
<li><a class="el" href="xiomodule__l_8h.html#a6be7aa174efc75d9cff5d72c63fa542c">XIOModule_LowLevelInterruptHandler()</a> is a handler without any arguments that is used in cases where there is a single interrupt controller device in the system and the handler cannot be passed an argument. This function is provided mostly for backward compatibility.</li>
</ul>
<ul>
<li><a class="el" href="xiomodule__l_8c.html#a2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a> is a handler that takes a device ID as an argument, indicating which interrupt controller device in the system is causing the interrupt - thereby supporting multiple interrupt controllers.</li>
</ul>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------------
 1.00a sa   07/15/11 First release
 1.01a sa   04/10/12 Updated with fast interrupt
 1.02a sa   07/25/12 Updated with GPI interrupt support
 </pre> <hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7602eedbe37417de638a1f7825f80132"></a><!-- doxytag: member="xiomodule_l.h::XGI_IN_OFFSET" ref="a7602eedbe37417de638a1f7825f80132" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGI_IN_OFFSET&nbsp;&nbsp;&nbsp;0x00000020</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>General Purpose Input - R </p>

</div>
</div>
<a class="anchor" id="a3c685bb29e51f4564a7aea4d2d7fce34"></a><!-- doxytag: member="xiomodule_l.h::XGO_OUT_OFFSET" ref="a3c685bb29e51f4564a7aea4d2d7fce34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGO_OUT_OFFSET&nbsp;&nbsp;&nbsp;0x00000010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>General Purpose Output - W </p>

</div>
</div>
<a class="anchor" id="a9569489084c770e95974e4592e425b66"></a><!-- doxytag: member="xiomodule_l.h::XGPI_CHAN_OFFSET" ref="a9569489084c770e95974e4592e425b66" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPI_CHAN_OFFSET&nbsp;&nbsp;&nbsp;0x00004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The following constants describe the offset of each GPI and GPO channel's data from the base address. </p>

</div>
</div>
<a class="anchor" id="a974d22f8d4af7aa177280efeb78a73f2"></a><!-- doxytag: member="xiomodule_l.h::XGPI_DATA_OFFSET" ref="a974d22f8d4af7aa177280efeb78a73f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPI_DATA_OFFSET&nbsp;&nbsp;&nbsp;0x00020</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afb21e053e2c12734dfadd0affbbbc313"></a><!-- doxytag: member="xiomodule_l.h::XGPI_DEVICE_COUNT" ref="afb21e053e2c12734dfadd0affbbbc313" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPI_DEVICE_COUNT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the number of GPI and GPO within a single hardware device. This number is not currently parameterized in the hardware but may be in the future. </p>

</div>
</div>
<a class="anchor" id="a17f8dbd54fab445a85c85af18f847049"></a><!-- doxytag: member="xiomodule_l.h::XGPO_CHAN_OFFSET" ref="a17f8dbd54fab445a85c85af18f847049" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPO_CHAN_OFFSET&nbsp;&nbsp;&nbsp;0x00004</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e809d2193d7e62366afad472869ea82"></a><!-- doxytag: member="xiomodule_l.h::XGPO_DATA_OFFSET" ref="a4e809d2193d7e62366afad472869ea82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPO_DATA_OFFSET&nbsp;&nbsp;&nbsp;0x00010</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aceeeea01636f70826ad24d82fc75448e"></a><!-- doxytag: member="xiomodule_l.h::XGPO_DEVICE_COUNT" ref="aceeeea01636f70826ad24d82fc75448e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XGPO_DEVICE_COUNT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af12b5f9e19d0d544e8df96699db615bd"></a><!-- doxytag: member="xiomodule_l.h::XIN_IAR_OFFSET" ref="af12b5f9e19d0d544e8df96699db615bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IAR_OFFSET&nbsp;&nbsp;&nbsp;0x0000003C</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intr Acknowledge Register - W </p>

</div>
</div>
<a class="anchor" id="a12fbacf76cabd206d17acefd187fa7b4"></a><!-- doxytag: member="xiomodule_l.h::XIN_IER_OFFSET" ref="a12fbacf76cabd206d17acefd187fa7b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IER_OFFSET&nbsp;&nbsp;&nbsp;0x00000038</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intr Enable Register - W </p>

</div>
</div>
<a class="anchor" id="a2dc06911d25b46e1ddad8e2938f95b4c"></a><!-- doxytag: member="xiomodule_l.h::XIN_IMR_OFFSET" ref="a2dc06911d25b46e1ddad8e2938f95b4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IMR_OFFSET&nbsp;&nbsp;&nbsp;0x0000000C</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intr Mode Register - W </p>

</div>
</div>
<a class="anchor" id="ac279b35b1b56563078139deb18f83729"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR" ref="ac279b35b1b56563078139deb18f83729" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_EXTERNAL_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5259a0a273407770999d48f1c8a59ffe"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_FIT_1_INTERRUPT_INTR" ref="a5259a0a273407770999d48f1c8a59ffe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_FIT_1_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a17aa65bf1c4d8840162d0c7a7a802a8f"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_FIT_2_INTERRUPT_INTR" ref="a17aa65bf1c4d8840162d0c7a7a802a8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_FIT_2_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af92f1cc054c2ae7860feade42b401b14"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_FIT_3_INTERRUPT_INTR" ref="af92f1cc054c2ae7860feade42b401b14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_FIT_3_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23989d98b257c17de75a89c7e2fcf3a6"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_FIT_4_INTERRUPT_INTR" ref="a23989d98b257c17de75a89c7e2fcf3a6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_FIT_4_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa9dd8e7332e3a08d57d1d2f2b250ed9b"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_GPI_1_INTERRUPT_INTR" ref="aa9dd8e7332e3a08d57d1d2f2b250ed9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_GPI_1_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;11</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb59d6931cdd71d2272d94da0c849d63"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_GPI_2_INTERRUPT_INTR" ref="aeb59d6931cdd71d2272d94da0c849d63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_GPI_2_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;12</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8cb6a48a26f2c9ca43e9d551b29eb3f9"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_GPI_3_INTERRUPT_INTR" ref="a8cb6a48a26f2c9ca43e9d551b29eb3f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_GPI_3_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;13</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a77dbab318178a69596d6cab5c3971dc9"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_GPI_4_INTERRUPT_INTR" ref="a77dbab318178a69596d6cab5c3971dc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_GPI_4_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;14</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Interrupt register bit position masks. </p>

</div>
</div>
<a class="anchor" id="a81a5045e6a373c91918083c7c37dcb4b"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_PIT_1_INTERRUPT_INTR" ref="a81a5045e6a373c91918083c7c37dcb4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_PIT_1_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7ee2a68fc1eece64980870c54c3d0ea5"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_PIT_2_INTERRUPT_INTR" ref="a7ee2a68fc1eece64980870c54c3d0ea5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_PIT_2_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acdbb05f5603a36e5e08777b26717cc70"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_PIT_3_INTERRUPT_INTR" ref="acdbb05f5603a36e5e08777b26717cc70" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_PIT_3_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ed96d6e12cc93dccc1f1769854b273c"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_PIT_4_INTERRUPT_INTR" ref="a5ed96d6e12cc93dccc1f1769854b273c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_PIT_4_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41b98b0520a4712e400178a16cac1128"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_UART_ERROR_INTERRUPT_INTR" ref="a41b98b0520a4712e400178a16cac1128" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_UART_ERROR_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac80b2d02a20d8813c02659e392695e65"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_UART_RX_INTERRUPT_INTR" ref="ac80b2d02a20d8813c02659e392695e65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_UART_RX_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9cfff2fde145343217879bb2b1637427"></a><!-- doxytag: member="xiomodule_l.h::XIN_IOMODULE_UART_TX_INTERRUPT_INTR" ref="a9cfff2fde145343217879bb2b1637427" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IOMODULE_UART_TX_INTERRUPT_INTR&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a35c8f39e63012c1745df6faa39fc7335"></a><!-- doxytag: member="xiomodule_l.h::XIN_IPR_OFFSET" ref="a35c8f39e63012c1745df6faa39fc7335" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IPR_OFFSET&nbsp;&nbsp;&nbsp;0x00000034</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intr Pending Register - R </p>

</div>
</div>
<a class="anchor" id="a4c1ce88ba61c2e42054faaef40539556"></a><!-- doxytag: member="xiomodule_l.h::XIN_ISR_OFFSET" ref="a4c1ce88ba61c2e42054faaef40539556" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_ISR_OFFSET&nbsp;&nbsp;&nbsp;0x00000030</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intr Status Register - R </p>

</div>
</div>
<a class="anchor" id="ab675a4446c4ab809551ea73ad2ca962d"></a><!-- doxytag: member="xiomodule_l.h::XIN_IVAR_OFFSET" ref="ab675a4446c4ab809551ea73ad2ca962d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IVAR_OFFSET&nbsp;&nbsp;&nbsp;0x00000080</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Intr Vector Address Register, Interrupt 0 offset, present only for Fast Interrupt - W </p>

</div>
</div>
<a class="anchor" id="ac3f5aa29d205f6221a017a04712c65f0"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_AckIntr" ref="ac3f5aa29d205f6221a017a04712c65f0" args="(BaseAddress, AckMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_AckIntr</td>
          <td>(</td>
          <td class="paramtype">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AckMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acknowledge specific interrupt(s) in the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AckMask</em>&nbsp;</td><td>is the 32-bit value to write to the acknowledge register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will acknowledge interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xiomodule__l_8h.html#ac3f5aa29d205f6221a017a04712c65f0">XIOModule_AckIntr(u32 BaseAddress, u32 AckMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="aaf77d72d553f17c2696ce54e3149f0d0"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_DisableIntr" ref="aaf77d72d553f17c2696ce54e3149f0d0" args="(BaseAddress, DisableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_DisableIntr</td>
          <td>(</td>
          <td class="paramtype">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DisableMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable specific interrupt(s) in the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DisableMask</em>&nbsp;</td><td>is the 32-bit value to write to enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only bits which are set in the mask will disable interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xiomodule__l_8h.html#aaf77d72d553f17c2696ce54e3149f0d0">XIOModule_DisableIntr(u32 BaseAddress, u32 DisableMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a230620599fe987b03b47e6d04a442e60"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_EnableIntr" ref="a230620599fe987b03b47e6d04a442e60" args="(BaseAddress, EnableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_EnableIntr</td>
          <td>(</td>
          <td class="paramtype">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnableMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable specific interrupt(s) in the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EnableMask</em>&nbsp;</td><td>is the 32-bit value to write to the enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will enable interrupts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xiomodule__l_8h.html#a230620599fe987b03b47e6d04a442e60">XIOModule_EnableIntr(u32 BaseAddress, u32 EnableMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a128f261df0c50d6e1b090e2a9e9d1874"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_GetIntrStatus" ref="a128f261df0c50d6e1b090e2a9e9d1874" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_GetIntrStatus</td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(XIomodule_In32((BaseAddress) + XIN_IPR_OFFSET))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the interrupt status from the interrupt controller which indicates which interrupts are active and enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 32-bit contents of the interrupt status register. Each bit corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Bits which are set indicate an active interrupt which is also enabled.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xiomodule__l_8h.html#a128f261df0c50d6e1b090e2a9e9d1874">XIOModule_GetIntrStatus(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a313c2576e159fd472cb0b25b7a395837"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_GetStatusReg" ref="a313c2576e159fd472cb0b25b7a395837" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_GetStatusReg</td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XIomodule_In32((BaseAddress) + XUL_STATUS_REG_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the contents of the UART status register. Use the XUL_SR_* constants defined above to interpret the bit-mask returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the status register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style Signature: u32 <a class="el" href="xiomodule__l_8h.html#a313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ad9c5e48a02c0aba03cb1d8d7583b37f6"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_IsReceiveEmpty" ref="ad9c5e48a02c0aba03cb1d8d7583b37f6" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_IsReceiveEmpty</td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xiomodule__l_8h.html#a313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>((BaseAddress)) &amp; <a class="code" href="xiomodule__l_8h.html#a7a1722c4c799b50641831e1d092d9893">XUL_SR_RX_FIFO_VALID_DATA</a>) != \
        <a class="code" href="xiomodule__l_8h.html#a7a1722c4c799b50641831e1d092d9893">XUL_SR_RX_FIFO_VALID_DATA</a>)
</pre></div><p>Check to see if the UART receiver has data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the receiver is empty, FALSE if there is data present.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style Signature: int <a class="el" href="xiomodule__l_8h.html#ad9c5e48a02c0aba03cb1d8d7583b37f6">XIOModule_IsReceiveEmpty(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a93c23372164e627f79da9488ea43161a"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_IsTransmitFull" ref="a93c23372164e627f79da9488ea43161a" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_IsTransmitFull</td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xiomodule__l_8h.html#a313c2576e159fd472cb0b25b7a395837">XIOModule_GetStatusReg</a>((BaseAddress)) &amp; <a class="code" href="xiomodule__l_8h.html#a76bf6a9a14882e45364a21693be7e920">XUL_SR_TX_FIFO_FULL</a>) == \
          <a class="code" href="xiomodule__l_8h.html#a76bf6a9a14882e45364a21693be7e920">XUL_SR_TX_FIFO_FULL</a>)
</pre></div><p>Check to see if the transmitter is full.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the transmitter is full, FALSE otherwise.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style Signature: int <a class="el" href="xiomodule__l_8h.html#a93c23372164e627f79da9488ea43161a">XIOModule_IsTransmitFull(u32 BaseAddress)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a74193c76002b6f0b67f1e34f2147d872"></a><!-- doxytag: member="xiomodule_l.h::XIOMODULE_L_H" ref="a74193c76002b6f0b67f1e34f2147d872" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOMODULE_L_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4eaff234e65f369a870fca3b92215df4"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_ReadReg" ref="a4eaff234e65f369a870fca3b92215df4" args="(BaseAddress, RegOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_ReadReg</td>
          <td>(</td>
          <td class="paramtype">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegOffset&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XIomodule_In32((BaseAddress) + (RegOffset))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read a value from a GPI register. A 32 bit read is performed. If the GPI component is implemented in a smaller width, only the least significant data is read from the register. The most significant data will be read as 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the GPI device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegOffset</em>&nbsp;</td><td>is the register offset from the base to read from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Data read from the register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xiomodule__l_8h.html#a4eaff234e65f369a870fca3b92215df4">XIOModule_ReadReg(u32 BaseAddress, unsigned RegOffset)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a829c77e3efe996211599f9a2a6bb4890"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_WriteReg" ref="a829c77e3efe996211599f9a2a6bb4890" args="(BaseAddress, RegOffset, Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIOModule_WriteReg</td>
          <td>(</td>
          <td class="paramtype">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RegOffset, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XIomodule_Out32((BaseAddress) + (RegOffset), (u32)(Data))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write a value to a GPO register. A 32 bit write is performed. If the GPO component is implemented in a smaller width, only the least significant data is written.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the GPO device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegOffset</em>&nbsp;</td><td>is the register offset from the base to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the data written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-style signature: void XIOModule_WriteReg(u32 BaseAddress, unsigned RegOffset, u32 Data) </dd></dl>

</div>
</div>
<a class="anchor" id="ab06d844c7a245c7be88a63f3559bbd46"></a><!-- doxytag: member="xiomodule_l.h::XTC_CSR_AUTO_RELOAD_MASK" ref="ab06d844c7a245c7be88a63f3559bbd46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_CSR_AUTO_RELOAD_MASK&nbsp;&nbsp;&nbsp;0x00000002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>In compare mode, configures the timer reload from the Load Register. The default mode causes the timer counter to hold when it rolls under. </p>

</div>
</div>
<a class="anchor" id="aa7cbbacf96f3f51bcd12d5826b03e620"></a><!-- doxytag: member="xiomodule_l.h::XTC_CSR_ENABLE_TMR_MASK" ref="aa7cbbacf96f3f51bcd12d5826b03e620" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_CSR_ENABLE_TMR_MASK&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the timer </p>

</div>
</div>
<a class="anchor" id="aba99b973ef1f13bf0a2716cf52ca5319"></a><!-- doxytag: member="xiomodule_l.h::XTC_DEVICE_TIMER_COUNT" ref="aba99b973ef1f13bf0a2716cf52ca5319" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_DEVICE_TIMER_COUNT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines the number of timer counters within a single hardware device. This number is not currently parameterized in the hardware but may be in the future. </p>

</div>
</div>
<a class="anchor" id="ad054cd3c12bc686f9be366e093c2f97a"></a><!-- doxytag: member="xiomodule_l.h::XTC_TCR_OFFSET" ref="ad054cd3c12bc686f9be366e093c2f97a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_TCR_OFFSET&nbsp;&nbsp;&nbsp;0x00000044</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer counter register - R </p>

</div>
</div>
<a class="anchor" id="a81c9a818cb57cf5f106cf5a3b7c3c59f"></a><!-- doxytag: member="xiomodule_l.h::XTC_TCSR_OFFSET" ref="a81c9a818cb57cf5f106cf5a3b7c3c59f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_TCSR_OFFSET&nbsp;&nbsp;&nbsp;0x00000048</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer Control register - W </p>

</div>
</div>
<a class="anchor" id="a22c78277a54b31ec738e72eca0662e35"></a><!-- doxytag: member="xiomodule_l.h::XTC_TIMER_COUNTER_OFFSET" ref="a22c78277a54b31ec738e72eca0662e35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_TIMER_COUNTER_OFFSET&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Each timer counter consumes 16 bytes of address space. </p>

</div>
</div>
<a class="anchor" id="a00c47cf9cd8ee813a05416adba5cd8ba"></a><!-- doxytag: member="xiomodule_l.h::XTC_TIMER_COUNTER_SHIFT" ref="a00c47cf9cd8ee813a05416adba5cd8ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_TIMER_COUNTER_SHIFT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a38a380fdcb3114c3db51524a8182c4ad"></a><!-- doxytag: member="xiomodule_l.h::XTC_TLR_OFFSET" ref="a38a380fdcb3114c3db51524a8182c4ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_TLR_OFFSET&nbsp;&nbsp;&nbsp;0x00000040</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Timer Load register - W </p>

</div>
</div>
<a class="anchor" id="aa2bc39bbb18ba649d4afbe729ee246c0"></a><!-- doxytag: member="xiomodule_l.h::XUL_BAUDRATE_OFFSET" ref="aa2bc39bbb18ba649d4afbe729ee246c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_BAUDRATE_OFFSET&nbsp;&nbsp;&nbsp;0x0000004C</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Baud Rate Register - W </p>

</div>
</div>
<a class="anchor" id="a0e3df7cb0f5abb04b6d391faa34c9098"></a><!-- doxytag: member="xiomodule_l.h::XUL_PARITY_EVEN" ref="a0e3df7cb0f5abb04b6d391faa34c9098" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_PARITY_EVEN&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b04347e664ae6d55ebd9d2609191767"></a><!-- doxytag: member="xiomodule_l.h::XUL_PARITY_NONE" ref="a3b04347e664ae6d55ebd9d2609191767" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_PARITY_NONE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Parity definitions. </p>

</div>
</div>
<a class="anchor" id="a12cf047d972692d6f36a88527fc1423e"></a><!-- doxytag: member="xiomodule_l.h::XUL_PARITY_ODD" ref="a12cf047d972692d6f36a88527fc1423e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_PARITY_ODD&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad3154a9fc1e2fd70c0cc37772e15b907"></a><!-- doxytag: member="xiomodule_l.h::XUL_RX_OFFSET" ref="ad3154a9fc1e2fd70c0cc37772e15b907" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_RX_OFFSET&nbsp;&nbsp;&nbsp;0x00000000</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Define the offsets from the base address for all the registers of the IO module, some registers may be optional in the hardware device. UART Receive Register - R </p>

</div>
</div>
<a class="anchor" id="aa52948dba7418fd7d4a68b47e3770dc1"></a><!-- doxytag: member="xiomodule_l.h::XUL_SR_FRAMING_ERROR" ref="aa52948dba7418fd7d4a68b47e3770dc1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_SR_FRAMING_ERROR&nbsp;&nbsp;&nbsp;0x40</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aef49f4399d015532ee90cda2c0045324"></a><!-- doxytag: member="xiomodule_l.h::XUL_SR_INTR_ENABLED" ref="aef49f4399d015532ee90cda2c0045324" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_SR_INTR_ENABLED&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Interrupt enabled </p>

</div>
</div>
<a class="anchor" id="a5614aae83f54065f4ca0aa7cdfc7f737"></a><!-- doxytag: member="xiomodule_l.h::XUL_SR_OVERRUN_ERROR" ref="a5614aae83f54065f4ca0aa7cdfc7f737" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_SR_OVERRUN_ERROR&nbsp;&nbsp;&nbsp;0x20</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a33cf5a2b5ddc5ae960235ce37cd6c32f"></a><!-- doxytag: member="xiomodule_l.h::XUL_SR_PARITY_ERROR" ref="a33cf5a2b5ddc5ae960235ce37cd6c32f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_SR_PARITY_ERROR&nbsp;&nbsp;&nbsp;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART status register bit position masks </p>

</div>
</div>
<a class="anchor" id="a7a1722c4c799b50641831e1d092d9893"></a><!-- doxytag: member="xiomodule_l.h::XUL_SR_RX_FIFO_VALID_DATA" ref="a7a1722c4c799b50641831e1d092d9893" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_SR_RX_FIFO_VALID_DATA&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Data Register valid </p>

</div>
</div>
<a class="anchor" id="a76bf6a9a14882e45364a21693be7e920"></a><!-- doxytag: member="xiomodule_l.h::XUL_SR_TX_FIFO_FULL" ref="a76bf6a9a14882e45364a21693be7e920" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_SR_TX_FIFO_FULL&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Transmit FIFO full </p>

</div>
</div>
<a class="anchor" id="a13cc5a4dd0ee4939136579f2e8dc9ce5"></a><!-- doxytag: member="xiomodule_l.h::XUL_STATUS_REG_OFFSET" ref="a13cc5a4dd0ee4939136579f2e8dc9ce5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_STATUS_REG_OFFSET&nbsp;&nbsp;&nbsp;0x00000008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Status Register - R </p>

</div>
</div>
<a class="anchor" id="af9a9355e4872a6de8340af575c2aec72"></a><!-- doxytag: member="xiomodule_l.h::XUL_STOP_BITS" ref="af9a9355e4872a6de8340af575c2aec72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_STOP_BITS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART stop bits are fixed at 1. Baud, parity, and data bits are fixed on a per instance basis. </p>

</div>
</div>
<a class="anchor" id="a0a78233dc7306487ebb9c5adebacac00"></a><!-- doxytag: member="xiomodule_l.h::XUL_TX_OFFSET" ref="a0a78233dc7306487ebb9c5adebacac00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUL_TX_OFFSET&nbsp;&nbsp;&nbsp;0x00000004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>UART Transmit Register - W </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ab333e5826535071fe60f13b70b6e56dd"></a><!-- doxytag: member="xiomodule_l.h::XFastInterruptHandler" ref="ab333e5826535071fe60f13b70b6e56dd" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiomodule__l_8h.html#ab333e5826535071fe60f13b70b6e56dd">XFastInterruptHandler</a>)(void)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2e47bfda481c3ceab60d758f049758ef"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_DeviceInterruptHandler" ref="a2e47bfda481c3ceab60d758f049758ef" args="(void *DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DeviceInterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is the interrupt handler for the driver interface provided in this file when there can be no argument passed to the handler. In this case, we just use the globally defined device ID for the interrupt controller. This function is provided mostly for backward compatibility. The user should use <a class="el" href="xiomodule__l_8c.html#a2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a> if possible.</p>
<p>This function does not support multiple interrupt controller instances to be handled.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The constant XPAR_IOMODULE_SINGLE_DEVICE_ID must be defined for this handler to be included in the driver compilation.</p>
<p>This function is the primary interrupt handler for the driver. It must be connected to the interrupt source such that is called when an interrupt of the interrupt controller is active. It will resolve which interrupts are active and enabled and call the appropriate interrupt handler. It uses the AckBeforeService flag in the configuration data to determine when to acknowledge the interrupt. Highest priority interrupts are serviced first. The driver can be configured to service only the highest priority interrupt or all pending interrupts using the {<a class="el" href="xiomodule_8h.html#a1c71be14079487aef1623f8427ba39bb">XIOModule_SetOptions()</a>} function or the {XIOModule_SetIntrSrvOption()} function.</p>
<p>This function assumes that an interrupt vector table has been previously initialized. It does not verify that entries in the table are valid before calling an interrupt handler, except skipping null handlers that indicate use of fast interrupts where the hardware directly jumps to the handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the zero-based device ID defined in xparameters.h of the interrupting interrupt controller. It is used as a direct index into the configuration data, which contains the vector table for the interrupt controller. Note that even though the argument is a void pointer, the value is not a pointer but the actual device ID. The void pointer type is necessary to meet the XInterruptHandler typedef for interrupt handlers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The constant XPAR_IOMODULE_MAX_INTR_SIZE must be setup for this to compile. Interrupt IDs range from 0 - 31 and correspond to the interrupt input signals for the interrupt controller. XPAR_IOMODULE_MAX_INTR_SIZE specifies the highest numbered interrupt input signal that is used. </p>

</div>
</div>
<a class="anchor" id="a6be7aa174efc75d9cff5d72c63fa542c"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_LowLevelInterruptHandler" ref="a6be7aa174efc75d9cff5d72c63fa542c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_LowLevelInterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af1784b245813307028ba028246e39606"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_RecvByte" ref="af1784b245813307028ba028246e39606" args="(u32 BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XIOModule_RecvByte </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions receives a single byte using the UART. It is blocking in that it waits for the receiver to become non-empty before it reads from the receive register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The byte of data received.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3985a47858bc59f526d475536811a393"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_RegisterHandler" ref="a3985a47858bc59f526d475536811a393" args="(u32 BaseAddress, int InterruptId, XInterruptHandler Handler, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_RegisterHandler </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>InterruptId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&nbsp;</td>
          <td class="paramname"> <em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a handler function for a specific interrupt ID. The vector table of the interrupt controller is updated, overwriting any previous handler. The handler function will be called when an interrupt occurs for the given interrupt ID.</p>
<p>This function can also be used to remove a handler from the vector table by passing in the XIOModule_DefaultHandler() as the handler and NULL as the callback reference.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptId</em>&nbsp;</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>is the function pointer that will be added to the vector table for the given interrupt ID. It adheres to the XInterruptHandler signature found in xbasic_types.h. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the argument that will be passed to the new handler function when it is called. This is user-specific.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only used with normal interrupt mode. Does not restore normal interrupt mode.</dd></dl>
<p>Note that this function has no effect if the input base address is invalid. </p>

</div>
</div>
<a class="anchor" id="a77e0649e78c817c27b628b6713c12451"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_SendByte" ref="a77e0649e78c817c27b628b6713c12451" args="(u32 BaseAddress, u8 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SendByte </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sends a single byte using the UART. It is blocking in that it waits for the transmitter to become non-full before it writes the byte to the transmit register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the byte of data to send</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf27e1820d586ec1c487078d03854944"></a><!-- doxytag: member="xiomodule_l.h::XIOModule_SetIntrSvcOption" ref="aaf27e1820d586ec1c487078d03854944" args="(u32 BaseAddress, int Option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetIntrSvcOption </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs. The default behavior when using the driver interface given in xintc.h file is to service only a single interrupt, whereas the default behavior when using the driver interface given in this file is to service all outstanding interrupts when an interrupt occurs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the unique identifier for a device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Option</em>&nbsp;</td><td>is XIN_SVC_SGL_ISR_OPTION if you want only a single interrupt serviced when an interrupt occurs, or XIN_SVC_ALL_ISRS_OPTION if you want all pending interrupts serviced when an interrupt occurs.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>Note that this function has no effect if the input base address is invalid. </p>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
