<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver iomodule v2_1: xiomodule.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xiomodule.h File Reference</h1><code>#include &quot;xparameters.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiomodule__l_8h.html">xiomodule_l.h</a>&quot;</code><br/>
<code>#include &quot;xil_types.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___buffer.html">XIOModule_Buffer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module___timer___stats.html">XIOModule_Timer_Stats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_i_o_module.html">XIOModule</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a56e8040d6245809b174a77f596525b17">IOMODULE_H</a></td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a> These options are used in <a class="el" href="xiomodule_8h.html#a1c71be14079487aef1623f8427ba39bb">XIOModule_SetOptions()</a> to configure the device. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#aad72f141ec429ad4b782868c33b32c1b">XTC_INT_MODE_OPTION</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ace3deb2a423d72960864a46eacd11fdc">XTC_AUTO_RELOAD_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000002UL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#af4bce8e2035f391b702686e49c66c839">XIN_SVC_SGL_ISR_OPTION</a>&nbsp;&nbsp;&nbsp;1UL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ad043237f658e83b2e8718ddddab12545">XIN_SVC_ALL_ISRS_OPTION</a>&nbsp;&nbsp;&nbsp;2UL</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hardware configuration mnemonics</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp1cbd7e0f5168e7805ccf17a080f4ea53"></a> These mnemonics are used when accessing hardware configuration parameters. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#af20fd1c0a59c98120a71fca59e4ebaee">XTC_PRESCALER_NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a6fee1f1e43ab3025089a614513488d4c">XTC_PRESCALER_FIT1</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a57d48bbd152bcf35da786ee49edf2d3c">XTC_PRESCALER_FIT2</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ab0c2d9fa35adf3aa2e5f488c302d90fc">XTC_PRESCALER_FIT3</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a376745b2a28fc58bbe75917ba440e0ac">XTC_PRESCALER_FIT4</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a69fb65358307ad1cef06d7a4dfb73c3f">XTC_PRESCALER_PIT1</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ad496accb87e9314a74855d99a5a52fb8">XTC_PRESCALER_PIT2</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a759f687540386496d6632197d27d005c">XTC_PRESCALER_PIT3</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#addd67d12327373c3cea486e648c1ddc9">XTC_PRESCALER_PIT4</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ad9e6ed90a6153f53eddf23e553d98dfd">XTC_PRESCALER_EXTERNAL</a>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> )(void *CallBackRef, unsigned int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a> )(void *CallBackRef, u8 TimerNumber)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a67914ab7abde581aa2214b997923938d">XIOModule_Initialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ad0dad0abc10925039a42855110f8256f">XIOModule_Timer_Initialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a7e2fb72f58ec51dd632b89a67beb515d">XIOModule_Start</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a4cd1ece524eb5fd3d5d255027ad6a01a">XIOModule_Stop</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a65efd62e9193f589aa82dfa26fc90142">XIOModule_Connect</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id, XInterruptHandler <a class="el" href="xiomodule__uart__intr_8c.html#a7c7eb802878944c1e915ea06e07679a2">Handler</a>, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a241c2c08f867ee4d03e96248c4a133da">XIOModule_Disconnect</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a0c2fe0ab1367af43b603cd896e306737">XIOModule_Enable</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a2ab631d859f9fc7b00f3c8367d763c49">XIOModule_Disable</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a036018140fd9f14af05eec37b3cb2e93">XIOModule_Acknowledge</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ad4112b2d6d28300c5c687e9a8d80e22d">XIOModule_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a41e9fc5bdcbf29ff8675104fdef91697">XIOModule_ConnectFastHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id, <a class="el" href="xiomodule__l_8h.html#ab333e5826535071fe60f13b70b6e56dd">XFastInterruptHandler</a> <a class="el" href="xiomodule__uart__intr_8c.html#a7c7eb802878944c1e915ea06e07679a2">Handler</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ab4ddcaf38d655ca70d916c1d5ba96240">XIOModule_SetNormalIntrMode</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 Id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a9f2d50c168791e08aaf44d16ca5b26a9">XIOModule_DiscreteRead</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, unsigned Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ae539ae69bfe0918f64499707514746fd">XIOModule_DiscreteWrite</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ae7a0598ebcbf832927168c532c82c469">XIOModule_DiscreteSet</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#af518b504d005044d00b5b9b1e6cd7b33">XIOModule_DiscreteClear</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, unsigned Channel, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a99ce16ec0f081059b1971bce386b6f50">XIOModule_CfgInitialize</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#adabb5f2e09817afb284173f31f3d7265">XIOModule_ResetFifos</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a6db3efbd9634e6f58b9fb6a67f82b8c2">XIOModule_Send</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ae9e27102d95385e1557fd488da7b2936">XIOModule_Recv</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#aa582b33e2d93e0f0072b3235ed6fb741">XIOModule_IsSending</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a5f9f252854955d1f41a3412077c1bc93">XIOModule_SetBaudRate</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 BaudRate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a42ada8bd0fb0d16976254c228a8924a2">XIOModule_GetStats</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a> *StatsPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a61a582e9785291f7c6e0b91c19c46bd8">XIOModule_ClearStats</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a8509fa9bc3ea2a65931d6de142af1900">XIOModule_VoidInterruptHandler</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a848da9f83ad1188caca777cd324cec10">XIOModule_InterruptHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#aa805a7f9982d9acc5b3b16849c5d2dfd">XIOModule_Uart_EnableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a5ec72d0dd352ad42de494821220e3185">XIOModule_Uart_DisableInterrupt</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a5ece62521d0d34bd420888ecc876750c">XIOModule_SetRecvHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a07b376ebf11fee3ff027445eaa096261">XIOModule_SetSendHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#acf2a67095f9797403f5c269fdcd7a6b2">XIOModule_Uart_InterruptHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a1c71be14079487aef1623f8427ba39bb">XIOModule_SetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ab24288979ff867f5e8f98372bddda874">XIOModule_GetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a208ab3e1ba68b1fdf48654104ac82b2f">XIOModule_SelfTest</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a622c3a5cd4e43543cfb445071d01e7a9">XIOModule_Timer_Start</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a60bd9ef270b0de7440206326ec1fe710">XIOModule_Timer_Stop</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a826357a58aeda0b2d1bfc42efd6bb94c">XIOModule_GetValue</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#af9ed2111d2f53ac88626030d907f374a">XIOModule_SetResetValue</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber, u32 ResetValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#af4281a3f3f5e5620d4e78dc904ab04cf">XIOModule_GetCaptureValue</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a65c77543ddff932f4b07da1100af984f">XIOModule_IsExpired</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ae5d1cb85ee2100003b7e2dcc160c47c0">XIOModule_Reset</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a719529740fbb19c3ce7d44078a2edcc1">XIOModule_Timer_SetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ab094dd3b23b9eeddc1337e49f9c62bd3">XIOModule_Timer_GetOptions</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 TimerNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a1def2e9c05d44d65be41969c2c8d1065">XIOModule_Timer_GetStats</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="struct_x_i_o_module___timer___stats.html">XIOModule_Timer_Stats</a> *StatsPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a360e43dbb0bfd91728c9782dad526634">XIOModule_Timer_ClearStats</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a38a44ea48fa70c6a6cd40b87f4ffc21e">XIOModule_Timer_SelfTest</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u8 IOModuleNumber)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ab2e5ac3f9e5a286fd376120cb27f545d">XIOModule_SetHandler</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, <a class="el" href="xiomodule_8h.html#a3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a> FuncPtr, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a431eb19a0f6aeab9bab0cdb09fdc30ce">XIOModule_Timer_InterruptHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a9939789b5819d1561bebc0eacac28b84">XIOModule_IoReadWord</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a7ff8a4fabcb27bc42957503761602439">XIOModule_IoReadHalfword</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#ab5ec0ed139e0e9629ec1b542dfec3989">XIOModule_IoReadByte</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#af20cdadbf9d5197fd91076a76b7049f8">XIOModule_IoWriteWord</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#a3c9d9b8fc1d9accc3502b24db3770664">XIOModule_IoWriteHalfword</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset, u16 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiomodule_8h.html#aae3b81b7f7e0ebf69c951b2fcf438e85">XIOModule_IoWriteByte</a> (<a class="el" href="struct_x_i_o_module.html">XIOModule</a> *InstancePtr, u32 ByteOffset, u8 Data)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a56e8040d6245809b174a77f596525b17"></a><!-- doxytag: member="xiomodule.h::IOMODULE_H" ref="a56e8040d6245809b174a77f596525b17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IOMODULE_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad043237f658e83b2e8718ddddab12545"></a><!-- doxytag: member="xiomodule.h::XIN_SVC_ALL_ISRS_OPTION" ref="ad043237f658e83b2e8718ddddab12545" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SVC_ALL_ISRS_OPTION&nbsp;&nbsp;&nbsp;2UL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4bce8e2035f391b702686e49c66c839"></a><!-- doxytag: member="xiomodule.h::XIN_SVC_SGL_ISR_OPTION" ref="af4bce8e2035f391b702686e49c66c839" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SVC_SGL_ISR_OPTION&nbsp;&nbsp;&nbsp;1UL</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to configure the Interrupt Controller. </p>
<pre>
 XIN_SVC_SGL_ISR_OPTION	Service the highest priority pending interrupt
				and then return.
 XIN_SVC_ALL_ISRS_OPTION	Service all of the pending interrupts and then
				return.
 </pre>
</div>
</div>
<a class="anchor" id="ace3deb2a423d72960864a46eacd11fdc"></a><!-- doxytag: member="xiomodule.h::XTC_AUTO_RELOAD_OPTION" ref="ace3deb2a423d72960864a46eacd11fdc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_AUTO_RELOAD_OPTION&nbsp;&nbsp;&nbsp;0x00000002UL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aad72f141ec429ad4b782868c33b32c1b"></a><!-- doxytag: member="xiomodule.h::XTC_INT_MODE_OPTION" ref="aad72f141ec429ad4b782868c33b32c1b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_INT_MODE_OPTION&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Used to configure the Programmable Interval Timer. </p>
<pre>
 XTC_INT_MODE_OPTION		Dummy compatibility option. Enable interrupt
                              output.
 XTC_AUTO_RELOAD_OPTION	In compare mode, configures the timer to reload
                              from the load value. The default mode causes
                              the timer to hold after it rolls under.
 </pre>
</div>
</div>
<a class="anchor" id="ad9e6ed90a6153f53eddf23e553d98dfd"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_EXTERNAL" ref="ad9e6ed90a6153f53eddf23e553d98dfd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_EXTERNAL&nbsp;&nbsp;&nbsp;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6fee1f1e43ab3025089a614513488d4c"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_FIT1" ref="a6fee1f1e43ab3025089a614513488d4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_FIT1&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a57d48bbd152bcf35da786ee49edf2d3c"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_FIT2" ref="a57d48bbd152bcf35da786ee49edf2d3c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_FIT2&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0c2d9fa35adf3aa2e5f488c302d90fc"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_FIT3" ref="ab0c2d9fa35adf3aa2e5f488c302d90fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_FIT3&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a376745b2a28fc58bbe75917ba440e0ac"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_FIT4" ref="a376745b2a28fc58bbe75917ba440e0ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_FIT4&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af20fd1c0a59c98120a71fca59e4ebaee"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_NONE" ref="af20fd1c0a59c98120a71fca59e4ebaee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_NONE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mnemonics for the Programmable Interval Timer hardware configuration. </p>
<pre>
 XTC_PRESCALER_*	Define the prescaler configured in hardware.
 </pre>
</div>
</div>
<a class="anchor" id="a69fb65358307ad1cef06d7a4dfb73c3f"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_PIT1" ref="a69fb65358307ad1cef06d7a4dfb73c3f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_PIT1&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad496accb87e9314a74855d99a5a52fb8"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_PIT2" ref="ad496accb87e9314a74855d99a5a52fb8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_PIT2&nbsp;&nbsp;&nbsp;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a759f687540386496d6632197d27d005c"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_PIT3" ref="a759f687540386496d6632197d27d005c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_PIT3&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="addd67d12327373c3cea486e648c1ddc9"></a><!-- doxytag: member="xiomodule.h::XTC_PRESCALER_PIT4" ref="addd67d12327373c3cea486e648c1ddc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XTC_PRESCALER_PIT4&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a40a7295554b9483f28c0f004b0c53302"></a><!-- doxytag: member="xiomodule.h::XIOModule_Handler" ref="a40a7295554b9483f28c0f004b0c53302" args=")(void *CallBackRef, unsigned int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>)(void *CallBackRef, unsigned int ByteCount)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback function. The first argument is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. The second argument is the ByteCount which is the number of bytes that actually moved from/to the buffer provided in the _Send/_Receive call. </p>

</div>
</div>
<a class="anchor" id="a3a95e8a205259686d85802168e10cdb3"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_Handler" ref="a3a95e8a205259686d85802168e10cdb3" args=")(void *CallBackRef, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiomodule_8h.html#a3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a>)(void *CallBackRef, u8 TimerNumber)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Signature for the timer callback function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the number of the timer within the device. The device typically contains from one to four timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a036018140fd9f14af05eec37b3cb2e93"></a><!-- doxytag: member="xiomodule.h::XIOModule_Acknowledge" ref="a036018140fd9f14af05eec37b3cb2e93" args="(XIOModule *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Acknowledge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Acknowledges the interrupt source provided as the argument Id. When the interrupt is acknowledged, it causes the interrupt controller to clear its interrupt condition.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a99ce16ec0f081059b1971bce386b6f50"></a><!-- doxytag: member="xiomodule.h::XIOModule_CfgInitialize" ref="a99ce16ec0f081059b1971bce386b6f50" args="(XIOModule *InstancePtr, XIOModule_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. This function disables the UART interrupts. The baud rate and format of the data are fixed in the hardware at hardware build time, except if programmable baud rate is selected.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific IO Module device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device register base address. Use Config-&gt;BaseAddress for this parameters, passing the physical address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything starts up as expected.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The Config and EffectiveAddress arguments are not used by this function, but are provided to keep the function signature consistent with other drivers. </dd></dl>

</div>
</div>
<a class="anchor" id="a61a582e9785291f7c6e0b91c19c46bd8"></a><!-- doxytag: member="xiomodule.h::XIOModule_ClearStats" ref="a61a582e9785291f7c6e0b91c19c46bd8" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function zeros the statistics for the given instance.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a65efd62e9193f589aa82dfa26fc90142"></a><!-- doxytag: member="xiomodule.h::XIOModule_Connect" ref="a65efd62e9193f589aa82dfa26fc90142" args="(XIOModule *InstancePtr, u8 Id, XInterruptHandler Handler, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_Connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&nbsp;</td>
          <td class="paramname"> <em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized. The argument provided in this call as the Callbackref is used as the argument for the handler when it is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>to the handler for that interrupt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the callback reference, usually the instance pointer of the connecting driver.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the handler was connected correctly.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only used with normal interrupt mode. Does not restore normal interrupt mode.</dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

</div>
</div>
<a class="anchor" id="a41e9fc5bdcbf29ff8675104fdef91697"></a><!-- doxytag: member="xiomodule.h::XIOModule_ConnectFastHandler" ref="a41e9fc5bdcbf29ff8675104fdef91697" args="(XIOModule *InstancePtr, u8 Id, XFastInterruptHandler Handler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_ConnectFastHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiomodule__l_8h.html#ab333e5826535071fe60f13b70b6e56dd">XFastInterruptHandler</a>&nbsp;</td>
          <td class="paramname"> <em>Handler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Makes the connection between the Id of the interrupt source and the associated handler that is to run when the interrupt is recognized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>to the handler for that interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the handler was connected correctly.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only used with fast interrupt mode.</dd></dl>
<p>WARNING: The handler provided as an argument will overwrite any handler that was previously connected. </p>

</div>
</div>
<a class="anchor" id="a2ab631d859f9fc7b00f3c8367d763c49"></a><!-- doxytag: member="xiomodule.h::XIOModule_Disable" ref="a2ab631d859f9fc7b00f3c8367d763c49" args="(XIOModule *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disables the interrupt source provided as the argument Id such that the interrupt controller will not cause interrupts for the specified Id. The interrupt controller will continue to hold an interrupt condition for the Id, but will not cause an interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a241c2c08f867ee4d03e96248c4a133da"></a><!-- doxytag: member="xiomodule.h::XIOModule_Disconnect" ref="a241c2c08f867ee4d03e96248c4a133da" args="(XIOModule *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Disconnect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Updates the interrupt table with the Null Handler and NULL arguments at the location pointed at by the Id. This effectively disconnects that interrupt source from any handler. The interrupt is disabled also.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af518b504d005044d00b5b9b1e6cd7b33"></a><!-- doxytag: member="xiomodule.h::XIOModule_DiscreteClear" ref="af518b504d005044d00b5b9b1e6cd7b33" args="(XIOModule *InstancePtr, unsigned Channel, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DiscreteClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set output discrete(s) to logic 0 for the specified GPO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1, 2, 3 or 4) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the set of bits that will be set to 0 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f2d50c168791e08aaf44d16ca5b26a9"></a><!-- doxytag: member="xiomodule.h::XIOModule_DiscreteRead" ref="a9f2d50c168791e08aaf44d16ca5b26a9" args="(XIOModule *InstancePtr, unsigned Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_DiscreteRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read state of discretes for the specified GPI channnel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPI (1, 2, 3 or 4) to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current copy of the discretes register. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7a0598ebcbf832927168c532c82c469"></a><!-- doxytag: member="xiomodule.h::XIOModule_DiscreteSet" ref="ae7a0598ebcbf832927168c532c82c469" args="(XIOModule *InstancePtr, unsigned Channel, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DiscreteSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set output discrete(s) to logic 1 for the specified GPO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPIO (1, 2, 3 or 4) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the set of bits that will be set to 1 in the discrete data register. All other bits in the data register are unaffected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae539ae69bfe0918f64499707514746fd"></a><!-- doxytag: member="xiomodule.h::XIOModule_DiscreteWrite" ref="ae539ae69bfe0918f64499707514746fd" args="(XIOModule *InstancePtr, unsigned Channel, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_DiscreteWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to discretes register for the specified GPO channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>contains the channel of the GPO (1, 2, 3 or 4) to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the value to be written to the discretes register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c2fe0ab1367af43b603cd896e306737"></a><!-- doxytag: member="xiomodule.h::XIOModule_Enable" ref="a0c2fe0ab1367af43b603cd896e306737" args="(XIOModule *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the interrupt source provided as the argument Id. Any pending interrupt condition for the specified Id will occur after this function is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_IOMODULE_INTC_MAX_INTR_SIZE - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af4281a3f3f5e5620d4e78dc904ab04cf"></a><!-- doxytag: member="xiomodule.h::XIOModule_GetCaptureValue" ref="af4281a3f3f5e5620d4e78dc904ab04cf" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_GetCaptureValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the timer counter value that was captured the last time the external capture input was asserted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current capture value for the indicated timer counter.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab24288979ff867f5e8f98372bddda874"></a><!-- doxytag: member="xiomodule.h::XIOModule_GetOptions" ref="ab24288979ff867f5e8f98372bddda874" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the currently set options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The currently set options. The options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a42ada8bd0fb0d16976254c228a8924a2"></a><!-- doxytag: member="xiomodule.h::XIOModule_GetStats" ref="a42ada8bd0fb0d16976254c228a8924a2" args="(XIOModule *InstancePtr, XIOModule_Uart_Stats *StatsPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a> *&nbsp;</td>
          <td class="paramname"> <em>StatsPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a snapshot of the current statistics in the structure specified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatsPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_i_o_module___uart___stats.html">XIOModule_Uart_Stats</a> structure to where the statistics are to be copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a826357a58aeda0b2d1bfc42efd6bb94c"></a><!-- doxytag: member="xiomodule.h::XIOModule_GetValue" ref="a826357a58aeda0b2d1bfc42efd6bb94c" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_GetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current value of the specified timer counter. The timer counter may be either incrementing or decrementing based upon the current mode of operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current value for the timer counter.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a67914ab7abde581aa2214b997923938d"></a><!-- doxytag: member="xiomodule.h::XIOModule_Initialize" ref="a67914ab7abde581aa2214b997923938d" args="(XIOModule *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize a specific interrupt controller instance/driver. The initialization entails:</p>
<ul>
<li>Initialize fields of the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> structure</li>
<li>Initial vector table with stub function calls</li>
<li>All interrupt sources are disabled</li>
<li>Interrupt output is disabled</li>
<li>All timers are initialized</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started</li>
<li>XST_DEVICE_NOT_FOUND if device configuration information was not found for a device with the supplied device ID.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a848da9f83ad1188caca777cd324cec10"></a><!-- doxytag: member="xiomodule.h::XIOModule_InterruptHandler" ref="a848da9f83ad1188caca777cd324cec10" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Interrupt handler for the driver used when there can be no argument passed to the handler. This function is provided mostly for backward compatibility. The user should use <a class="el" href="xiomodule__l_8c.html#a2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>, defined in <a class="el" href="xiomodule__l_8c.html">xiomodule_l.c</a>, if possible.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The constant XPAR_IOMODULE_SINGLE_DEVICE_ID must be defined for this handler to be included in the driver compilation.</p>
<p>The interrupt handler for the driver. This function is provided mostly for backward compatibility. The user should use <a class="el" href="xiomodule__l_8c.html#a2e47bfda481c3ceab60d758f049758ef">XIOModule_DeviceInterruptHandler()</a>, defined in <a class="el" href="xiomodule__l_8c.html">xiomodule_l.c</a> when possible and pass the device ID of the interrupt controller device as its argument.</p>
<p>The user must connect this function to the interrupt system such that it is called whenever the devices which are connected to it cause an interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5ec0ed139e0e9629ec1b542dfec3989"></a><!-- doxytag: member="xiomodule.h::XIOModule_IoReadByte" ref="ab5ec0ed139e0e9629ec1b542dfec3989" args="(XIOModule *InstancePtr, u32 ByteOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XIOModule_IoReadByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ByteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read byte from the IO Bus memory mapped IO</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteOffset</em>&nbsp;</td><td>is a byte offset from the beginning of the IO Bus address area</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value read from the IO Bus - 8-bit byte </dd></dl>

</div>
</div>
<a class="anchor" id="a7ff8a4fabcb27bc42957503761602439"></a><!-- doxytag: member="xiomodule.h::XIOModule_IoReadHalfword" ref="a7ff8a4fabcb27bc42957503761602439" args="(XIOModule *InstancePtr, u32 ByteOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XIOModule_IoReadHalfword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ByteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 16-bit halfword from the IO Bus memory mapped IO</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteOffset</em>&nbsp;</td><td>is a byte offset from the beginning of the IO Bus address area</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value read from the IO Bus - 16-bit halfword </dd></dl>

</div>
</div>
<a class="anchor" id="a9939789b5819d1561bebc0eacac28b84"></a><!-- doxytag: member="xiomodule.h::XIOModule_IoReadWord" ref="a9939789b5819d1561bebc0eacac28b84" args="(XIOModule *InstancePtr, u32 ByteOffset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_IoReadWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ByteOffset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 32-bit word from the IO Bus memory mapped IO</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteOffset</em>&nbsp;</td><td>is a byte offset from the beginning of the IO Bus address area</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value read from the IO Bus - 32-bit word </dd></dl>

</div>
</div>
<a class="anchor" id="aae3b81b7f7e0ebf69c951b2fcf438e85"></a><!-- doxytag: member="xiomodule.h::XIOModule_IoWriteByte" ref="aae3b81b7f7e0ebf69c951b2fcf438e85" args="(XIOModule *InstancePtr, u32 ByteOffset, u8 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_IoWriteByte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 8-bit word to the IO Bus memory mapped IO</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteOffset</em>&nbsp;</td><td>is a byte offset from the beginning of the IO Bus address area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the value to be written to the IO Bus - 8-bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c9d9b8fc1d9accc3502b24db3770664"></a><!-- doxytag: member="xiomodule.h::XIOModule_IoWriteHalfword" ref="a3c9d9b8fc1d9accc3502b24db3770664" args="(XIOModule *InstancePtr, u32 ByteOffset, u16 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_IoWriteHalfword </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 16-bit word to the IO Bus memory mapped IO</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteOffset</em>&nbsp;</td><td>is a byte offset from the beginning of the IO Bus address area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the value to be written to the IO Bus - 16-bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af20cdadbf9d5197fd91076a76b7049f8"></a><!-- doxytag: member="xiomodule.h::XIOModule_IoWriteWord" ref="af20cdadbf9d5197fd91076a76b7049f8" args="(XIOModule *InstancePtr, u32 ByteOffset, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_IoWriteWord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ByteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write 32-bit word to the IO Bus memory mapped IO</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteOffset</em>&nbsp;</td><td>is a byte offset from the beginning of the IO Bus address area </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the value to be written to the IO Bus - 32-bit</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a65c77543ddff932f4b07da1100af984f"></a><!-- doxytag: member="xiomodule.h::XIOModule_IsExpired" ref="a65c77543ddff932f4b07da1100af984f" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_IsExpired </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Checks if the specified timer counter of the device has expired. In capture mode, expired is defined as a capture occurred. In compare mode, expired is defined as the timer counter rolled over/under for up/down counting.</p>
<p>When interrupts are enabled, the expiration causes an interrupt. This function is typically used to poll a timer counter to determine when it has expired.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>TRUE if the timer has expired, and FALSE otherwise.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa582b33e2d93e0f0072b3235ed6fb741"></a><!-- doxytag: member="xiomodule.h::XIOModule_IsSending" ref="aa582b33e2d93e0f0072b3235ed6fb741" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_IsSending </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function determines if the specified UART is sending data. If the transmitter register is not empty, it is sending data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value of TRUE if the UART is sending data, otherwise FALSE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4112b2d6d28300c5c687e9a8d80e22d"></a><!-- doxytag: member="xiomodule.h::XIOModule_LookupConfig" ref="ad4112b2d6d28300c5c687e9a8d80e22d" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_i_o_module___config.html">XIOModule_Config</a>* XIOModule_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique identifier for a device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> configuration structure for the specified device, or NULL if the device was not found.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9e27102d95385e1557fd488da7b2936"></a><!-- doxytag: member="xiomodule.h::XIOModule_Recv" ref="ae9e27102d95385e1557fd488da7b2936" args="(XIOModule *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_Recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will attempt to receive a specified number of bytes of data from the UART and store it into the specified buffer. This function is designed for either polled or interrupt driven modes. It is non-blocking such that it will return if no data has already received by the UART.</p>
<p>In a polled mode, this function will only receive as much data as the UART can buffer in the receiver. The application may need to call it repeatedly to receive a buffer. Polled mode is the default mode of operation for the driver.</p>
<p>In interrupt mode, this function will start receiving and then the interrupt handler of the driver will continue receiving data until the buffer has been received. A callback function, as specified by the application, will be called to indicate the completion of receiving the buffer or when any receive errors or timeouts occur.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBufferPtr</em>&nbsp;</td><td>is pointer to buffer for data to be received into. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>is the number of bytes to be received. A value of zero will stop a previous receive operation that is in progress in interrupt mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes received.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5d1cb85ee2100003b7e2dcc160c47c0"></a><!-- doxytag: member="xiomodule.h::XIOModule_Reset" ref="ae5d1cb85ee2100003b7e2dcc160c47c0" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the specified timer counter of the device. A reset causes the timer counter to set it's value to the reset value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adabb5f2e09817afb284173f31f3d7265"></a><!-- doxytag: member="xiomodule.h::XIOModule_ResetFifos" ref="adabb5f2e09817afb284173f31f3d7265" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_ResetFifos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function does nothing, since the UART doesn't have any FIFOs. It is included for compatibility with the UART Lite driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance .</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a208ab3e1ba68b1fdf48654104ac82b2f"></a><!-- doxytag: member="xiomodule.h::XIOModule_SelfTest" ref="a208ab3e1ba68b1fdf48654104ac82b2f" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6db3efbd9634e6f58b9fb6a67f82b8c2"></a><!-- doxytag: member="xiomodule.h::XIOModule_Send" ref="a6db3efbd9634e6f58b9fb6a67f82b8c2" args="(XIOModule *InstancePtr, u8 *DataBufferPtr, unsigned int NumBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int XIOModule_Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DataBufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>NumBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sends the specified buffer of data using the UART in either polled or interrupt driven modes. This function is non-blocking such that it will return before the data has been sent by the UART. If the UART is busy sending data, it will return and indicate zero bytes were sent.</p>
<p>In a polled mode, this function will only send as much data as the UART can buffer in the transmitter. The application may need to call it repeatedly to send a buffer.</p>
<p>In interrupt mode, this function will start sending the specified buffer and then the interrupt handler of the driver will continue sending data until the buffer has been sent. A callback function, as specified by the application, will be called to indicate the completion of sending the buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBufferPtr</em>&nbsp;</td><td>is pointer to a buffer of data to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBytes</em>&nbsp;</td><td>contains the number of bytes to be sent. A value of zero will stop a previous send operation that is in progress in interrupt mode. Any data that was already put into the transmit FIFO will be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of bytes actually sent.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The number of bytes is not asserted so that this function may be called with a value of zero to stop an operation that is already in progress. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f9f252854955d1f41a3412077c1bc93"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetBaudRate" ref="a5f9f252854955d1f41a3412077c1bc93" args="(XIOModule *InstancePtr, u32 BaudRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_SetBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaudRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab2e5ac3f9e5a286fd376120cb27f545d"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetHandler" ref="ab2e5ac3f9e5a286fd376120cb27f545d" args="(XIOModule *InstancePtr, XIOModule_Timer_Handler FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiomodule_8h.html#a3a95e8a205259686d85802168e10cdb3">XIOModule_Timer_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the timer callback function, which the driver calls when the specified timer times out.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The handler is called within interrupt context so the function that is called should either be short or pass the more extensive processing off to another task to allow the interrupt to return and normal processing to continue.</p>
<p>This function is provided for compatibility, and only allows setting a single handler for all Programmable Interval Timers. </p>

</div>
</div>
<a class="anchor" id="ab4ddcaf38d655ca70d916c1d5ba96240"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetNormalIntrMode" ref="ab4ddcaf38d655ca70d916c1d5ba96240" args="(XIOModule *InstancePtr, u8 Id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetNormalIntrMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the normal interrupt mode for the specified interrupt in the Interrupt Mode Register, by resetting the vector to (BaseVector &amp; 0xFFFFFF80) | 0x10 and selecting normal mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id</em>&nbsp;</td><td>contains the ID of the interrupt source and should be in the range of 0 to XPAR_INTC_MAX_NUM_INTR_INPUTS - 1 with 0 being the highest priority interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only used with fast interrupt mode. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c71be14079487aef1623f8427ba39bb"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetOptions" ref="a1c71be14079487aef1623f8427ba39bb" args="(XIOModule *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the options for the interrupt controller driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>to be set. The available options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li>
<li>XST_INVALID_PARAM if the specified option was not valid</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ece62521d0d34bd420888ecc876750c"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetRecvHandler" ref="a5ece62521d0d34bd420888ecc876750c" args="(XIOModule *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetRecvHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. The purpose of the handler is to allow application specific processing to be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

</div>
</div>
<a class="anchor" id="af9ed2111d2f53ac88626030d907f374a"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetResetValue" ref="af9ed2111d2f53ac88626030d907f374a" args="(XIOModule *InstancePtr, u8 TimerNumber, u32 ResetValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetResetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>ResetValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the reset value for the specified timer counter. This is the value that is loaded into the timer counter when it is reset. This value is also loaded when the timer counter is started.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ResetValue</em>&nbsp;</td><td>contains the value to be used to reset the timer counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a07b376ebf11fee3ff027445eaa096261"></a><!-- doxytag: member="xiomodule.h::XIOModule_SetSendHandler" ref="a07b376ebf11fee3ff027445eaa096261" args="(XIOModule *InstancePtr, XIOModule_Handler FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_SetSendHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiomodule_8h.html#a40a7295554b9483f28c0f004b0c53302">XIOModule_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler that will be called when an event (interrupt) occurs in the driver for the UART. The purpose of the handler is to allow application specific processing to be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance . </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is (nor should it) </dd></dl>

</div>
</div>
<a class="anchor" id="a7e2fb72f58ec51dd632b89a67beb515d"></a><!-- doxytag: member="xiomodule.h::XIOModule_Start" ref="a7e2fb72f58ec51dd632b89a67beb515d" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the IO Module. Interrupts may be generated by the IO Module after this function is called.</p>
<p>It is necessary for the caller to connect the interrupt handler of this component to the proper interrupt source.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device was started successfully</li>
<li>XST_FAILURE if simulation mode was specified and it could not be set because real mode has already been entered.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Must be called after <a class="el" href="struct_x_i_o_module.html">XIOModule</a> initialization is completed. </dd></dl>

</div>
</div>
<a class="anchor" id="a4cd1ece524eb5fd3d5d255027ad6a01a"></a><!-- doxytag: member="xiomodule.h::XIOModule_Stop" ref="a4cd1ece524eb5fd3d5d255027ad6a01a" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops the interrupt controller by disabling the output from the controller so that no interrupts will be caused by the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a360e43dbb0bfd91728c9782dad526634"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_ClearStats" ref="a360e43dbb0bfd91728c9782dad526634" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab094dd3b23b9eeddc1337e49f9c62bd3"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_GetOptions" ref="ab094dd3b23b9eeddc1337e49f9c62bd3" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIOModule_Timer_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1def2e9c05d44d65be41969c2c8d1065"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_GetStats" ref="a1def2e9c05d44d65be41969c2c8d1065" args="(XIOModule *InstancePtr, XIOModule_Timer_Stats *StatsPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module___timer___stats.html">XIOModule_Timer_Stats</a> *&nbsp;</td>
          <td class="paramname"> <em>StatsPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad0dad0abc10925039a42855110f8256f"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_Initialize" ref="ad0dad0abc10925039a42855110f8256f" args="(XIOModule *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_Timer_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific timer instance/driver. Initialize fields of the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> structure, then reset the timer</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_i_o_module.html">XIOModule</a> component. Passing in a device id associates the generic <a class="el" href="struct_x_i_o_module.html">XIOModule</a> component to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started</li>
<li>XST_DEVICE_NOT_FOUND if the device doesn't exist</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a431eb19a0f6aeab9bab0cdb09fdc30ce"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_InterruptHandler" ref="a431eb19a0f6aeab9bab0cdb09fdc30ce" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Interrupt Service Routine (ISR) for the driver. This function only performs processing for the Programmable Interval Timere and does not save and restore the interrupt context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>contains a pointer to the IO Module instance for the interrupt.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a38a44ea48fa70c6a6cd40b87f4ffc21e"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_SelfTest" ref="a38a44ea48fa70c6a6cd40b87f4ffc21e" args="(XIOModule *InstancePtr, u8 IOModuleNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIOModule_Timer_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Runs a self-test on the timer driver/device. This test verifies that the specified programmable interval timer of the device can be enabled and increments.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the XIOMOdule instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer of the device to operate on. Each device may contain multiple timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if self-test was successful</li>
<li>XST_FAILURE if the timer is not incrementing.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This is a destructive test using the provided timer. The current settings of the timer are returned to the initialized values and all settings at the time this function is called are overwritten. </p>

</div>
</div>
<a class="anchor" id="a719529740fbb19c3ce7d44078a2edcc1"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_SetOptions" ref="a719529740fbb19c3ce7d44078a2edcc1" args="(XIOModule *InstancePtr, u8 TimerNumber, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enables the specified options for the specified timer . This function sets the options without regard to the current options of the driver. To prevent a loss of the current options, the user should call <a class="el" href="xiomodule_8h.html#ab094dd3b23b9eeddc1337e49f9c62bd3">XIOModule_Timer_GetOptions()</a> prior to this function and modify the retrieved options to pass into this function to prevent loss of the current options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer of the device to operate on. Each device may contain multiple timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>contains the desired options to be set or cleared. Setting the option to '1' enables the option, clearing the to '0' disables the option. The options are bit masks such that multiple options may be set or cleared. The options are described in <a class="el" href="xiomodule_8h.html">xiomodule.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a622c3a5cd4e43543cfb445071d01e7a9"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_Start" ref="a622c3a5cd4e43543cfb445071d01e7a9" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Starts the specified timer counter of the device such that it starts running. The timer counter is reset before it is started and the reset value is loaded into the timer counter.</p>
<p>If interrupt mode is specified in the options, it is necessary for the caller to connect the interrupt handler of the timer to the interrupt source, typically an interrupt controller, and enable the interrupt within the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer of the device to operate on. Each device may contain multiple timers. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a60bd9ef270b0de7440206326ec1fe710"></a><!-- doxytag: member="xiomodule.h::XIOModule_Timer_Stop" ref="a60bd9ef270b0de7440206326ec1fe710" args="(XIOModule *InstancePtr, u8 TimerNumber)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Timer_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimerNumber</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stops the timer by disabling it.</p>
<p>It is the callers' responsibility to disconnect the interrupt handler of the timer from the interrupt source, typically an interrupt controller, and disable the interrupt within the interrupt controller.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimerNumber</em>&nbsp;</td><td>is the timer counter of the device to operate on. Each device may contain multiple timer counters. The timer number is a zero based number with a range of 0 to (XTC_DEVICE_TIMER_COUNT - 1).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ec72d0dd352ad42de494821220e3185"></a><!-- doxytag: member="xiomodule.h::XIOModule_Uart_DisableInterrupt" ref="a5ec72d0dd352ad42de494821220e3185" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_DisableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the UART interrupt. After calling this function, data may still be received by the UART but no interrupt will be generated since the hardware device has no way to disable the receiver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa805a7f9982d9acc5b3b16849c5d2dfd"></a><!-- doxytag: member="xiomodule.h::XIOModule_Uart_EnableInterrupt" ref="aa805a7f9982d9acc5b3b16849c5d2dfd" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_EnableInterrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the UART interrupts such that an interrupt will occur when data is received or data has been transmitted.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_i_o_module.html">XIOModule</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="acf2a67095f9797403f5c269fdcd7a6b2"></a><!-- doxytag: member="xiomodule.h::XIOModule_Uart_InterruptHandler" ref="acf2a67095f9797403f5c269fdcd7a6b2" args="(XIOModule *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_Uart_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_i_o_module.html">XIOModule</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the UART. It must be connected to an interrupt system by the user such that it is called when an interrupt for any UART lite occurs. This function does not save or restore the processor context such that the user must ensure this occurs.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>contains a pointer to the instance of the IOModule that the interrupt is for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8509fa9bc3ea2a65931d6de142af1900"></a><!-- doxytag: member="xiomodule.h::XIOModule_VoidInterruptHandler" ref="a8509fa9bc3ea2a65931d6de142af1900" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIOModule_VoidInterruptHandler </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
