<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xemacps_control.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xemacps_control.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Functions in this file implement general purpose command and control related functionality. See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a detailed description of the driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a wsy  01/10/10 First release
 1.02a asa  11/05/12 Added a new API for deleting an entry from the HASH
					   register. Added a new API for setting the BURST length
					   in DMACR register.
 </pre>
<p>
<code>#include &quot;<a class="el" href="xemacps_8h.html">xemacps.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#90199e95242edf13a5d83413812ec22d">XEmacPs_SetMacAddress</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr, u8 Index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#c937dc7f20125b0af5b07de435d83df4">XEmacPs_GetMacAddress</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr, u8 Index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#555ba66cf054a569dcdd602ae61d33d1">XEmacPs_SetHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#cfd4b44c01f089ec708d1db73c73d40c">XEmacPs_DeleteHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#198e6a798ce0be3a5ab09e0d102766ef">XEmacPs_ClearHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#4d40aa55e3fbbf2e29379e15d07e3bd8">XEmacPs_GetHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#54f76825f543ad6a85fadb5609b5bd06">XEmacPs_SetTypeIdCheck</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 Id_Check, u8 Index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#ac00eaf66004d2d1d788ca01ed3b512c">XEmacPs_SetOptions</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#2b82f01f4000f8e6a8ce45d8be43255c">XEmacPs_ClearOptions</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#5508f6a12614b8df7369a16a60bc238e">XEmacPs_GetOptions</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#6a3673011fb4882dfcfc8366ecee2e6c">XEmacPs_SendPausePacket</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#0d7ec49a34ff5c1b4592ad6c9830a6b0">XEmacPs_GetOperatingSpeed</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#e1f519684cc62697fd17f49e2658abd6">XEmacPs_SetOperatingSpeed</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u16 Speed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#5d0b4b9258cdead2c0875a0853c087b3">XEmacPs_SetMdioDivisor</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, <a class="el" href="xemacps__hw_8h.html#a367ea42c2214b487cf74951453204ff">XEmacPs_MdcDiv</a> Divisor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#6169714fe8417a642cfdde141f550b3c">XEmacPs_PhyRead</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#2aa3ec40827c175ee46a8fd641ff960c">XEmacPs_PhyWrite</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__control_8c.html#2821b9581e2be4c94990bb98052ce680">XEmacPs_DMABLengthUpdate</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, int BLength)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="198e6a798ce0be3a5ab09e0d102766ef"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_ClearHash" ref="198e6a798ce0be3a5ab09e0d102766ef" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_ClearHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the Hash registers for the mac address pointed by AddressPtr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b82f01f4000f8e6a8ce45d8be43255c"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_ClearOptions" ref="2b82f01f4000f8e6a8ce45d8be43255c" args="(XEmacPs *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_ClearOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear options for the driver/device<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>are the options to clear. Multiple options can be cleared by OR'ing XEMACPS_*_OPTIONS constants together. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cfd4b44c01f089ec708d1db73c73d40c"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_DeleteHash" ref="cfd4b44c01f089ec708d1db73c73d40c" args="(XEmacPs *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_DeleteHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete 48-bit MAC addresses in hash table. The device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to a 6-byte MAC address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the HASH MAC address was deleted successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li><li>XST_INVALID_PARAM if the HASH MAC address passed in does not meet requirement after calculation</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Having Aptr be unsigned type prevents the following operations from sign extending. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2821b9581e2be4c94990bb98052ce680"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_DMABLengthUpdate" ref="2821b9581e2be4c94990bb98052ce680" args="(XEmacPs *InstancePtr, int BLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_DMABLengthUpdate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>BLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API to update the Burst length in the DMACR register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BLength</em>&nbsp;</td><td>is the length in bytes for the dma burst.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d40aa55e3fbbf2e29379e15d07e3bd8"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_GetHash" ref="4d40aa55e3fbbf2e29379e15d07e3bd8" args="(XEmacPs *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_GetHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Hash address for this driver/device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is an output parameter, and is a pointer to a buffer into which the current HASH MAC address will be copied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c937dc7f20125b0af5b07de435d83df4"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_GetMacAddress" ref="c937dc7f20125b0af5b07de435d83df4" args="(XEmacPs *InstancePtr, void *AddressPtr, u8 Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_GetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the MAC address for this driver/device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is an output parameter, and is a pointer to a buffer into which the current MAC address will be copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>is a index to which MAC (1-4) address. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d7ec49a34ff5c1b4592ad6c9830a6b0"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_GetOperatingSpeed" ref="0d7ec49a34ff5c1b4592ad6c9830a6b0" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XEmacPs_GetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XEmacPs_GetOperatingSpeed gets the current operating link speed. This may be the value set by <a class="el" href="xemacps_8h.html#e1f519684cc62697fd17f49e2658abd6">XEmacPs_SetOperatingSpeed()</a> or a hardware default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XEmacPs_GetOperatingSpeed returns the link speed in units of megabits per second.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="5508f6a12614b8df7369a16a60bc238e"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_GetOptions" ref="5508f6a12614b8df7369a16a60bc238e" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XEmacPs_GetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current option settings<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A bitmask of XTE_*_OPTION constants. Any bit set to 1 is to be interpreted as a set opion.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6169714fe8417a642cfdde141f550b3c"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_PhyRead" ref="6169714fe8417a642cfdde141f550b3c" args="(XEmacPs *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_PhyRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>PhyDataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the current value of the PHY register indicated by the PhyAddress and the RegisterNum parameters. The MAC provides the driver with the ability to talk to a PHY that adheres to the Media Independent Interface (MII) as defined in the IEEE 802.3 standard.<p>
Prior to PHY access with this function, the user should have setup the MDIO clock with <a class="el" href="xemacps_8h.html#5d0b4b9258cdead2c0875a0853c087b3">XEmacPs_SetMdioDivisor()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyAddress</em>&nbsp;</td><td>is the address of the PHY to be read (supports multiple PHYs) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegisterNum</em>&nbsp;</td><td>is the register number, 0-31, of the specific PHY register to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyDataPtr</em>&nbsp;</td><td>is an output parameter, and points to a 16-bit buffer into which the current value of the register will be copied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the PHY was read from successfully</li><li>XST_EMAC_MII_BUSY if there is another PHY operation in progress</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function is not thread-safe. The user must provide mutually exclusive access to this function if there are to be multiple threads that can call it.<p>
There is the possibility that this function will not return if the hardware is broken (i.e., it never sets the status bit indicating that the read is done). If this is of concern to the user, the user should provide a mechanism suitable to their needs for recovery.<p>
For the duration of this function, all host interface reads and writes are blocked to the current <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance.
</div>
</div><p>
<a class="anchor" name="2aa3ec40827c175ee46a8fd641ff960c"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_PhyWrite" ref="2aa3ec40827c175ee46a8fd641ff960c" args="(XEmacPs *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_PhyWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>PhyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data to the specified PHY register. The Ethernet driver does not require the device to be stopped before writing to the PHY. Although it is probably a good idea to stop the device, it is the responsibility of the application to deem this necessary. The MAC provides the driver with the ability to talk to a PHY that adheres to the Media Independent Interface (MII) as defined in the IEEE 802.3 standard.<p>
Prior to PHY access with this function, the user should have setup the MDIO clock with <a class="el" href="xemacps_8h.html#5d0b4b9258cdead2c0875a0853c087b3">XEmacPs_SetMdioDivisor()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyAddress</em>&nbsp;</td><td>is the address of the PHY to be written (supports multiple PHYs) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegisterNum</em>&nbsp;</td><td>is the register number, 0-31, of the specific PHY register to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyData</em>&nbsp;</td><td>is the 16-bit value that will be written to the register</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the PHY was written to successfully. Since there is no error status from the MAC on a write, the user should read the PHY to verify the write was successful.</li><li>XST_EMAC_MII_BUSY if there is another PHY operation in progress</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function is not thread-safe. The user must provide mutually exclusive access to this function if there are to be multiple threads that can call it.<p>
There is the possibility that this function will not return if the hardware is broken (i.e., it never sets the status bit indicating that the write is done). If this is of concern to the user, the user should provide a mechanism suitable to their needs for recovery.<p>
For the duration of this function, all host interface reads and writes are blocked to the current <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance.
</div>
</div><p>
<a class="anchor" name="6a3673011fb4882dfcfc8366ecee2e6c"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SendPausePacket" ref="6a3673011fb4882dfcfc8366ecee2e6c" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SendPausePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a pause packet<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if pause frame transmission was initiated</li><li>XST_DEVICE_IS_STOPPED if the device has not been started. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="555ba66cf054a569dcdd602ae61d33d1"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SetHash" ref="555ba66cf054a569dcdd602ae61d33d1" args="(XEmacPs *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set 48-bit MAC addresses in hash table. The device must be stopped before calling this function.<p>
The hash address register is 64 bits long and takes up two locations in the memory map. The least significant bits are stored in hash register bottom and the most significant bits in hash register top.<p>
The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames. The destination address is reduced to a 6 bit index into the 64 bit hash register using the following hash function. The hash function is an XOR of every sixth bit of the destination address.<p>
<pre>
 hash_index[05] = da[05]^da[11]^da[17]^da[23]^da[29]^da[35]^da[41]^da[47]
 hash_index[04] = da[04]^da[10]^da[16]^da[22]^da[28]^da[34]^da[40]^da[46]
 hash_index[03] = da[03]^da[09]^da[15]^da[21]^da[27]^da[33]^da[39]^da[45]
 hash_index[02] = da[02]^da[08]^da[14]^da[20]^da[26]^da[32]^da[38]^da[44]
 hash_index[01] = da[01]^da[07]^da[13]^da[19]^da[25]^da[31]^da[37]^da[43]
 hash_index[00] = da[00]^da[06]^da[12]^da[18]^da[24]^da[30]^da[36]^da[42]
 </pre><p>
da[0] represents the least significant bit of the first byte received, that is, the multicast/unicast indicator, and da[47] represents the most significant bit of the last byte received.<p>
If the hash index points to a bit that is set in the hash register then the frame will be matched according to whether the frame is multicast or unicast.<p>
A multicast match will be signaled if the multicast hash enable bit is set, da[0] is logic 1 and the hash index points to a bit set in the hash register.<p>
A unicast match will be signaled if the unicast hash enable bit is set, da[0] is logic 0 and the hash index points to a bit set in the hash register.<p>
To receive all multicast frames, the hash register should be set with all ones and the multicast hash enable bit should be set in the network configuration register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to a 6-byte MAC address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the HASH MAC address was set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li><li>XST_INVALID_PARAM if the HASH MAC address passed in does not meet requirement after calculation</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Having Aptr be unsigned type prevents the following operations from sign extending. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90199e95242edf13a5d83413812ec22d"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SetMacAddress" ref="90199e95242edf13a5d83413812ec22d" args="(XEmacPs *InstancePtr, void *AddressPtr, u8 Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MAC address for this driver/device. The address is a 48-bit value. The device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to a 6-byte MAC address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>is a index to which MAC (1-4) address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the MAC address was set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="5d0b4b9258cdead2c0875a0853c087b3"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SetMdioDivisor" ref="5d0b4b9258cdead2c0875a0853c087b3" args="(XEmacPs *InstancePtr, XEmacPs_MdcDiv Divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_SetMdioDivisor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__hw_8h.html#a367ea42c2214b487cf74951453204ff">XEmacPs_MdcDiv</a>&nbsp;</td>
          <td class="paramname"> <em>Divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MDIO clock divisor.<p>
Calculating the divisor:<p>
<pre>
              f[HOSTCLK]
   f[MDC] = -----------------
            (1 + Divisor) * 2
 </pre><p>
where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster access. Here is the table to show values to generate MDC,<p>
<pre>
 000 : divide pclk by   8 (pclk up to  20 MHz)
 001 : divide pclk by  16 (pclk up to  40 MHz)
 010 : divide pclk by  32 (pclk up to  80 MHz)
 011 : divide pclk by  48 (pclk up to 120 MHz)
 100 : divide pclk by  64 (pclk up to 160 MHz)
 101 : divide pclk by  96 (pclk up to 240 MHz)
 110 : divide pclk by 128 (pclk up to 320 MHz)
 111 : divide pclk by 224 (pclk up to 540 MHz)
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is the divisor to set. Range is 0b000 to 0b111. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e1f519684cc62697fd17f49e2658abd6"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SetOperatingSpeed" ref="e1f519684cc62697fd17f49e2658abd6" args="(XEmacPs *InstancePtr, u16 Speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_SetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Speed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XEmacPs_SetOperatingSpeed sets the current operating link speed. For any traffic to be passed, this speed must match the current MII/GMII/SGMII/RGMII link speed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Speed</em>&nbsp;</td><td>is the speed to set in units of Mbps. Valid values are 10, 100, or 1000. XEmacPs_SetOperatingSpeed ignores invalid values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="ac00eaf66004d2d1d788ca01ed3b512c"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SetOptions" ref="ac00eaf66004d2d1d788ca01ed3b512c" args="(XEmacPs *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set options for the driver/device. The driver should be stopped with <a class="el" href="xemacps_8c.html#f27b057022a2e97201f6d55d61d4a3da">XEmacPs_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>are the options to set. Multiple options can be set by OR'ing XTE_*_OPTIONS constants together. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54f76825f543ad6a85fadb5609b5bd06"></a><!-- doxytag: member="xemacps_control.c::XEmacPs_SetTypeIdCheck" ref="54f76825f543ad6a85fadb5609b5bd06" args="(XEmacPs *InstancePtr, u32 Id_Check, u8 Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetTypeIdCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Id_Check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the Type ID match for this driver/device. The register is a 32-bit value. The device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id_Check</em>&nbsp;</td><td>is type ID to be configured. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>is a index to which Type ID (1-4).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the MAC address was set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped </li></ul>
</dd></dl>

</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
