<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xemacps.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xemacps.h File Reference</h1>
<p>
<code>#include &quot;xil_types.h&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;xstatus.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xemacps__hw_8h.html">xemacps_hw.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xemacps__bd_8h.html">xemacps_bd.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="xemacps__bdring_8h.html">xemacps_bdring.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a></td></tr>

<tr><td colspan="2"><br><h2>Configuration options</h2></td></tr>
<tr><td colspan="2">Device configuration options. See the <a class="el" href="xemacps_8h.html#ac00eaf66004d2d1d788ca01ed3b512c">XEmacPs_SetOptions()</a>, <a class="el" href="xemacps_8h.html#2b82f01f4000f8e6a8ce45d8be43255c">XEmacPs_ClearOptions()</a> and <a class="el" href="xemacps_8h.html#5508f6a12614b8df7369a16a60bc238e">XEmacPs_GetOptions()</a> for information on how to use options.<p>
The default state of the options are noted and are what the device and driver will be set to after calling <a class="el" href="xemacps_8c.html#dd5f487c873ef70ab8fda69b4ec3938e">XEmacPs_Reset()</a> or XEmacPs_Initialize(). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#4ae3072d0f6da4bc4c9b6c17760abf57">XEMACPS_PROMISC_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#e607121a78f5c93f9800cb71d0d00e57">XEMACPS_FRAME1536_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#c06000e56a82a3c8c529f3e00ddf8ff6">XEMACPS_VLAN_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#c03594b24b59c81bfb19941d260253d6">XEMACPS_FLOW_CONTROL_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#bfeca462e8b7c84ba625565316891f3d">XEMACPS_FCS_STRIP_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#90b5592e1f2c22898ad83c62554f62a0">XEMACPS_FCS_INSERT_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#9039d35febc3f7992f809d868a4da576">XEMACPS_LENTYPE_ERR_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#b5521aa6e9ac40d0d1e168ce5383a7c5">XEMACPS_TRANSMITTER_ENABLE_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#b9205bb0478d2310f3e061e3e9ca3f92">XEMACPS_RECEIVER_ENABLE_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000200</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#b268031c60443dc4d5bca79a3405895e">XEMACPS_BROADCAST_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000400</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#580a6553eed0cf979f07fa53ab68b1f6">XEMACPS_MULTICAST_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000800</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#433f658606ac8cfb01060c7c2d11ba10">XEMACPS_RX_CHKSUM_ENABLE_OPTION</a>&nbsp;&nbsp;&nbsp;0x00001000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#19842c49b79b27a0d3133c1a02cf073c">XEMACPS_TX_CHKSUM_ENABLE_OPTION</a>&nbsp;&nbsp;&nbsp;0x00002000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#a42a956951bd1e28344544a6c8e54373">XEMACPS_DEFAULT_OPTIONS</a></td></tr>

<tr><td colspan="2"><br><h2>Callback identifiers</h2></td></tr>
<tr><td colspan="2">These constants are used as parameters to <a class="el" href="xemacps_8h.html#6ff686c1d27451aa864729d78b9570d6">XEmacPs_SetHandler()</a> <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#8f574a4a19c6fbd3d9c05dfd2a515573">XEMACPS_HANDLER_DMASEND</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#2b46aa9d448fab508d2e35df2a6c1453">XEMACPS_HANDLER_DMARECV</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#80c8856e7d87fcac6e05a2e7f7ba9d5c">XEMACPS_HANDLER_ERROR</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td colspan="2"><br><h2>Typedefs for callback functions</h2></td></tr>
<tr><td colspan="2">These callbacks are invoked in interrupt context. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#b67a80fb3896481b6338a2ac2357ab33">XEmacPs_Handler</a> (void *CallBackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#208a480dc15f02a8119086c652d816bb">XEmacPs_ErrHandler</a> (void *CallBackRef, u8 Direction, u32 ErrorWord)</td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#1f431092c77f6bcc61537d0b846ace9c">XEMACPS_H</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#164404a0a371f895aabed486bbf0669d">XEMACPS_DEVICE_NAME</a>&nbsp;&nbsp;&nbsp;&quot;xemacps&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#c9b8c6a3a7432a011a528b05470e21ef">XEMACPS_DEVICE_DESC</a>&nbsp;&nbsp;&nbsp;&quot;Xilinx PS 10/100/1000 MAC&quot;</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#3c72761c9c96f0831465da8409dd5a6d">XEMACPS_MDIO_DIV_DFT</a>&nbsp;&nbsp;&nbsp;MDC_DIV_32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#998fbeecfa83803b6fc31c70f5f6f383">XEMACPS_MAC_ADDR_SIZE</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#4c44b167e52f6d2ff3965234e933d23a">XEMACPS_MTU</a>&nbsp;&nbsp;&nbsp;1500</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#a3181534297674e3348d337194926673">XEMACPS_HDR_SIZE</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#14c5b7f7027c6906babaf5ee9c790522">XEMACPS_HDR_VLAN_SIZE</a>&nbsp;&nbsp;&nbsp;18</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#9b46761abbc3d28f3742fc23002b532a">XEMACPS_TRL_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#4911fe4122e87fcd4a09b1360712c506">XEMACPS_MAX_FRAME_SIZE</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#85a5f8f5b4b779c2d580e9f5e0e8ba48">XEMACPS_MAX_VLAN_FRAME_SIZE</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#27e7dded122fa828b016fdf6e8b79151">XEMACPS_SINGLE_BURST</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#47ba7fb944bd420799d7cb666337a9c6">XEMACPS_4BYTE_BURST</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#36b4e696c094eed9ef6d0a4150033b9e">XEMACPS_8BYTE_BURST</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#6653884926facb1a2333bfece7ad1b19">XEMACPS_16BYTE_BURST</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#c64d6f46e958baa7230be816b98c2df9">XEmacPs_GetTxRing</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;TxBdRing)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#a0203004a3b96feae1af6239417db4c3">XEmacPs_GetRxRing</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;RxBdRing)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#01db1ce924dddcb6b57e62605b05b820">XEmacPs_IntEnable</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#7b019ea26e976ebda026f06fcf28acac">XEmacPs_IntDisable</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#ea55959275d2be9d140c99364aee6795">XEmacPs_Transmit</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#150a0c0378c94bab0c84e5635915ed3f">XEmacPs_IsRxCsum</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#0a8d99f31e95687498771a6d6b7a1627">XEmacPs_IsTxCsum</a>(InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#500aa2343a5a84ddd80bd52fb184f94f">XEmacPs_CfgInitialize</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, <a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a> *CfgPtr, u32 EffectiveAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#be875d0d136e28a166363d66dd7b7f27">XEmacPs_Start</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#f27b057022a2e97201f6d55d61d4a3da">XEmacPs_Stop</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#dd5f487c873ef70ab8fda69b4ec3938e">XEmacPs_Reset</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#54751572e0cfaf72bce1bf26894291fb">XEmacPs_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#6ff686c1d27451aa864729d78b9570d6">XEmacPs_SetHandler</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 HandlerType, void *FuncPtr, void *CallBackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#59b9d4bbcb0a5e22d95f7363426b3267">XEmacPs_IntrHandler</a> (void *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#ac00eaf66004d2d1d788ca01ed3b512c">XEmacPs_SetOptions</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#2b82f01f4000f8e6a8ce45d8be43255c">XEmacPs_ClearOptions</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#5508f6a12614b8df7369a16a60bc238e">XEmacPs_GetOptions</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#90199e95242edf13a5d83413812ec22d">XEmacPs_SetMacAddress</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr, u8 Index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#c937dc7f20125b0af5b07de435d83df4">XEmacPs_GetMacAddress</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr, u8 Index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#555ba66cf054a569dcdd602ae61d33d1">XEmacPs_SetHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#198e6a798ce0be3a5ab09e0d102766ef">XEmacPs_ClearHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#4d40aa55e3fbbf2e29379e15d07e3bd8">XEmacPs_GetHash</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#5d0b4b9258cdead2c0875a0853c087b3">XEmacPs_SetMdioDivisor</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, <a class="el" href="xemacps__hw_8h.html#a367ea42c2214b487cf74951453204ff">XEmacPs_MdcDiv</a> Divisor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#e1f519684cc62697fd17f49e2658abd6">XEmacPs_SetOperatingSpeed</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u16 Speed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#0d7ec49a34ff5c1b4592ad6c9830a6b0">XEmacPs_GetOperatingSpeed</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#6169714fe8417a642cfdde141f550b3c">XEmacPs_PhyRead</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#2aa3ec40827c175ee46a8fd641ff960c">XEmacPs_PhyWrite</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#54f76825f543ad6a85fadb5609b5bd06">XEmacPs_SetTypeIdCheck</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, u32 Id_Check, u8 Index)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#6a3673011fb4882dfcfc8366ecee2e6c">XEmacPs_SendPausePacket</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps_8h.html#2821b9581e2be4c94990bb98052ce680">XEmacPs_DMABLengthUpdate</a> (<a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *InstancePtr, int BLength)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="6653884926facb1a2333bfece7ad1b19"></a><!-- doxytag: member="xemacps.h::XEMACPS_16BYTE_BURST" ref="6653884926facb1a2333bfece7ad1b19" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_16BYTE_BURST&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="47ba7fb944bd420799d7cb666337a9c6"></a><!-- doxytag: member="xemacps.h::XEMACPS_4BYTE_BURST" ref="47ba7fb944bd420799d7cb666337a9c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_4BYTE_BURST&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="36b4e696c094eed9ef6d0a4150033b9e"></a><!-- doxytag: member="xemacps.h::XEMACPS_8BYTE_BURST" ref="36b4e696c094eed9ef6d0a4150033b9e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_8BYTE_BURST&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b268031c60443dc4d5bca79a3405895e"></a><!-- doxytag: member="xemacps.h::XEMACPS_BROADCAST_OPTION" ref="b268031c60443dc4d5bca79a3405895e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_BROADCAST_OPTION&nbsp;&nbsp;&nbsp;0x00000400          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow reception of the broadcast address This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="a42a956951bd1e28344544a6c8e54373"></a><!-- doxytag: member="xemacps.h::XEMACPS_DEFAULT_OPTIONS" ref="a42a956951bd1e28344544a6c8e54373" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_DEFAULT_OPTIONS          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xemacps_8h.html#c03594b24b59c81bfb19941d260253d6">XEMACPS_FLOW_CONTROL_OPTION</a> |                  \
     <a class="code" href="xemacps_8h.html#90b5592e1f2c22898ad83c62554f62a0">XEMACPS_FCS_INSERT_OPTION</a> |                    \
     <a class="code" href="xemacps_8h.html#bfeca462e8b7c84ba625565316891f3d">XEMACPS_FCS_STRIP_OPTION</a> |                     \
     <a class="code" href="xemacps_8h.html#b268031c60443dc4d5bca79a3405895e">XEMACPS_BROADCAST_OPTION</a> |                     \
     <a class="code" href="xemacps_8h.html#9039d35febc3f7992f809d868a4da576">XEMACPS_LENTYPE_ERR_OPTION</a> |                   \
     <a class="code" href="xemacps_8h.html#b5521aa6e9ac40d0d1e168ce5383a7c5">XEMACPS_TRANSMITTER_ENABLE_OPTION</a> |            \
     <a class="code" href="xemacps_8h.html#b9205bb0478d2310f3e061e3e9ca3f92">XEMACPS_RECEIVER_ENABLE_OPTION</a> |               \
     <a class="code" href="xemacps_8h.html#433f658606ac8cfb01060c7c2d11ba10">XEMACPS_RX_CHKSUM_ENABLE_OPTION</a> |              \
     <a class="code" href="xemacps_8h.html#19842c49b79b27a0d3133c1a02cf073c">XEMACPS_TX_CHKSUM_ENABLE_OPTION</a>)
</pre></div>Default options set when device is initialized or reset
</div>
</div><p>
<a class="anchor" name="c9b8c6a3a7432a011a528b05470e21ef"></a><!-- doxytag: member="xemacps.h::XEMACPS_DEVICE_DESC" ref="c9b8c6a3a7432a011a528b05470e21ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_DEVICE_DESC&nbsp;&nbsp;&nbsp;&quot;Xilinx PS 10/100/1000 MAC&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="164404a0a371f895aabed486bbf0669d"></a><!-- doxytag: member="xemacps.h::XEMACPS_DEVICE_NAME" ref="164404a0a371f895aabed486bbf0669d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_DEVICE_NAME&nbsp;&nbsp;&nbsp;&quot;xemacps&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="90b5592e1f2c22898ad83c62554f62a0"></a><!-- doxytag: member="xemacps.h::XEMACPS_FCS_INSERT_OPTION" ref="90b5592e1f2c22898ad83c62554f62a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_FCS_INSERT_OPTION&nbsp;&nbsp;&nbsp;0x00000040          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate FCS field and add PAD automatically for outgoing frames. This option defaults to disabled (cleared)
</div>
</div><p>
<a class="anchor" name="bfeca462e8b7c84ba625565316891f3d"></a><!-- doxytag: member="xemacps.h::XEMACPS_FCS_STRIP_OPTION" ref="bfeca462e8b7c84ba625565316891f3d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_FCS_STRIP_OPTION&nbsp;&nbsp;&nbsp;0x00000020          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Strip FCS and PAD from incoming frames. Note: PAD from VLAN frames is not stripped. This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="c03594b24b59c81bfb19941d260253d6"></a><!-- doxytag: member="xemacps.h::XEMACPS_FLOW_CONTROL_OPTION" ref="c03594b24b59c81bfb19941d260253d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_FLOW_CONTROL_OPTION&nbsp;&nbsp;&nbsp;0x00000010          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable recognition of flow control frames on Rx This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="e607121a78f5c93f9800cb71d0d00e57"></a><!-- doxytag: member="xemacps.h::XEMACPS_FRAME1536_OPTION" ref="e607121a78f5c93f9800cb71d0d00e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_FRAME1536_OPTION&nbsp;&nbsp;&nbsp;0x00000002          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frame larger than 1516 support for Tx &amp; Rx. This option defaults to disabled (cleared)
</div>
</div><p>
<a class="anchor" name="a0203004a3b96feae1af6239417db4c3"></a><!-- doxytag: member="xemacps.h::XEmacPs_GetRxRing" ref="a0203004a3b96feae1af6239417db4c3" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_GetRxRing          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;RxBdRing)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the Rx ring object. This object can be used in the various Ring API functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the DMA channel to operate on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>RxBdRing attribute</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: <a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> <a class="el" href="xemacps_8h.html#a0203004a3b96feae1af6239417db4c3">XEmacPs_GetRxRing(XEmacPs *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="c64d6f46e958baa7230be816b98c2df9"></a><!-- doxytag: member="xemacps.h::XEmacPs_GetTxRing" ref="c64d6f46e958baa7230be816b98c2df9" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_GetTxRing          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;TxBdRing)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve the Tx ring object. This object can be used in the various Ring API functions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the DMA channel to operate on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TxBdRing attribute</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: <a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> <a class="el" href="xemacps_8h.html#c64d6f46e958baa7230be816b98c2df9">XEmacPs_GetTxRing(XEmacPs *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="1f431092c77f6bcc61537d0b846ace9c"></a><!-- doxytag: member="xemacps.h::XEMACPS_H" ref="1f431092c77f6bcc61537d0b846ace9c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_H          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2b46aa9d448fab508d2e35df2a6c1453"></a><!-- doxytag: member="xemacps.h::XEMACPS_HANDLER_DMARECV" ref="2b46aa9d448fab508d2e35df2a6c1453" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_HANDLER_DMARECV&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8f574a4a19c6fbd3d9c05dfd2a515573"></a><!-- doxytag: member="xemacps.h::XEMACPS_HANDLER_DMASEND" ref="8f574a4a19c6fbd3d9c05dfd2a515573" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_HANDLER_DMASEND&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="80c8856e7d87fcac6e05a2e7f7ba9d5c"></a><!-- doxytag: member="xemacps.h::XEMACPS_HANDLER_ERROR" ref="80c8856e7d87fcac6e05a2e7f7ba9d5c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_HANDLER_ERROR&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a3181534297674e3348d337194926673"></a><!-- doxytag: member="xemacps.h::XEMACPS_HDR_SIZE" ref="a3181534297674e3348d337194926673" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_HDR_SIZE&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="14c5b7f7027c6906babaf5ee9c790522"></a><!-- doxytag: member="xemacps.h::XEMACPS_HDR_VLAN_SIZE" ref="14c5b7f7027c6906babaf5ee9c790522" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_HDR_VLAN_SIZE&nbsp;&nbsp;&nbsp;18          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7b019ea26e976ebda026f06fcf28acac"></a><!-- doxytag: member="xemacps.h::XEmacPs_IntDisable" ref="7b019ea26e976ebda026f06fcf28acac" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_IntDisable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xemacps__hw_8h.html#372948c9677f6859b62e87504fb2460e">XEmacPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,             \
                <a class="code" href="xemacps__hw_8h.html#f643b24c0bd360fd1d23b917f05bab41">XEMACPS_IDR_OFFSET</a>,                                     \
                (Mask &amp; <a class="code" href="xemacps__hw_8h.html#2434d507b1985653ee1ff288ba3e71b6">XEMACPS_IXR_ALL_MASK</a>));
</pre></div>Disable interrupts specified in <em>Mask</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of interrupts to disable. The mask can be formed using a set of bitwise or'd values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The state of the transmitter and receiver are not modified by this function. C-style signature void <a class="el" href="xemacps_8h.html#7b019ea26e976ebda026f06fcf28acac">XEmacPs_IntDisable(XEmacPs *InstancePtr, u32 Mask)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="01db1ce924dddcb6b57e62605b05b820"></a><!-- doxytag: member="xemacps.h::XEmacPs_IntEnable" ref="01db1ce924dddcb6b57e62605b05b820" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_IntEnable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xemacps__hw_8h.html#372948c9677f6859b62e87504fb2460e">XEmacPs_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,             \
                <a class="code" href="xemacps__hw_8h.html#d3f6cd3bb5192aa87934b251b796ee5f">XEMACPS_IER_OFFSET</a>,                                     \
                (Mask &amp; <a class="code" href="xemacps__hw_8h.html#2434d507b1985653ee1ff288ba3e71b6">XEMACPS_IXR_ALL_MASK</a>));
</pre></div>Enable interrupts specified in <em>Mask</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of interrupts to enable. The mask can be formed using a set of bitwise or'd values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The state of the transmitter and receiver are not modified by this function. C-style signature void <a class="el" href="xemacps_8h.html#01db1ce924dddcb6b57e62605b05b820">XEmacPs_IntEnable(XEmacPs *InstancePtr, u32 Mask)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="150a0c0378c94bab0c84e5635915ed3f"></a><!-- doxytag: member="xemacps.h::XEmacPs_IsRxCsum" ref="150a0c0378c94bab0c84e5635915ed3f" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_IsRxCsum          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xemacps__hw_8h.html#81a4d6db864dea35b8ddd690f7615539">XEmacPs_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,             \
          <a class="code" href="xemacps__hw_8h.html#0b65ac7fc12ffa35e594946e112685ab">XEMACPS_NWCFG_OFFSET</a>) &amp; <a class="code" href="xemacps__hw_8h.html#3c81d635b59f6855908551ec4535b1a3">XEMACPS_NWCFG_RXCHKSUMEN_MASK</a>)         \
          ? TRUE : FALSE)
</pre></div>This macro determines if the device is configured with checksum offloading on the receive channel<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
Boolean TRUE if the device is configured with checksum offloading, or FALSE otherwise.<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xemacps_8h.html#150a0c0378c94bab0c84e5635915ed3f">XEmacPs_IsRxCsum(XEmacPs *InstancePtr)</a>
</div>
</div><p>
<a class="anchor" name="0a8d99f31e95687498771a6d6b7a1627"></a><!-- doxytag: member="xemacps.h::XEmacPs_IsTxCsum" ref="0a8d99f31e95687498771a6d6b7a1627" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_IsTxCsum          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xemacps__hw_8h.html#81a4d6db864dea35b8ddd690f7615539">XEmacPs_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,              \
          <a class="code" href="xemacps__hw_8h.html#cc6ae7a7cd61204c467d3718ec91ef8e">XEMACPS_DMACR_OFFSET</a>) &amp; <a class="code" href="xemacps__hw_8h.html#e643f0d8fe79362256f812eed64f11ad">XEMACPS_DMACR_TCPCKSUM_MASK</a>)           \
          ? TRUE : FALSE)
</pre></div>This macro determines if the device is configured with checksum offloading on the transmit channel<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
Boolean TRUE if the device is configured with checksum offloading, or FALSE otherwise.<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xemacps_8h.html#0a8d99f31e95687498771a6d6b7a1627">XEmacPs_IsTxCsum(XEmacPs *InstancePtr)</a>
</div>
</div><p>
<a class="anchor" name="9039d35febc3f7992f809d868a4da576"></a><!-- doxytag: member="xemacps.h::XEMACPS_LENTYPE_ERR_OPTION" ref="9039d35febc3f7992f809d868a4da576" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_LENTYPE_ERR_OPTION&nbsp;&nbsp;&nbsp;0x00000080          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable Length/Type error checking for incoming frames. When this option is set, the MAC will filter frames that have a mismatched type/length field and if XEMACPS_REPORT_RXERR_OPTION is set, the user is notified when these types of frames are encountered. When this option is cleared, the MAC will allow these types of frames to be received.<p>
This option defaults to disabled (cleared)
</div>
</div><p>
<a class="anchor" name="998fbeecfa83803b6fc31c70f5f6f383"></a><!-- doxytag: member="xemacps.h::XEMACPS_MAC_ADDR_SIZE" ref="998fbeecfa83803b6fc31c70f5f6f383" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_MAC_ADDR_SIZE&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4911fe4122e87fcd4a09b1360712c506"></a><!-- doxytag: member="xemacps.h::XEMACPS_MAX_FRAME_SIZE" ref="4911fe4122e87fcd4a09b1360712c506" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_MAX_FRAME_SIZE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xemacps_8h.html#4c44b167e52f6d2ff3965234e933d23a">XEMACPS_MTU</a> + <a class="code" href="xemacps_8h.html#a3181534297674e3348d337194926673">XEMACPS_HDR_SIZE</a> + \
        <a class="code" href="xemacps_8h.html#9b46761abbc3d28f3742fc23002b532a">XEMACPS_TRL_SIZE</a>)
</pre></div>
</div>
</div><p>
<a class="anchor" name="85a5f8f5b4b779c2d580e9f5e0e8ba48"></a><!-- doxytag: member="xemacps.h::XEMACPS_MAX_VLAN_FRAME_SIZE" ref="85a5f8f5b4b779c2d580e9f5e0e8ba48" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_MAX_VLAN_FRAME_SIZE          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xemacps_8h.html#4c44b167e52f6d2ff3965234e933d23a">XEMACPS_MTU</a> + <a class="code" href="xemacps_8h.html#a3181534297674e3348d337194926673">XEMACPS_HDR_SIZE</a> + \
        <a class="code" href="xemacps_8h.html#14c5b7f7027c6906babaf5ee9c790522">XEMACPS_HDR_VLAN_SIZE</a> + <a class="code" href="xemacps_8h.html#9b46761abbc3d28f3742fc23002b532a">XEMACPS_TRL_SIZE</a>)
</pre></div>
</div>
</div><p>
<a class="anchor" name="3c72761c9c96f0831465da8409dd5a6d"></a><!-- doxytag: member="xemacps.h::XEMACPS_MDIO_DIV_DFT" ref="3c72761c9c96f0831465da8409dd5a6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_MDIO_DIV_DFT&nbsp;&nbsp;&nbsp;MDC_DIV_32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default MDIO clock divisor
</div>
</div><p>
<a class="anchor" name="4c44b167e52f6d2ff3965234e933d23a"></a><!-- doxytag: member="xemacps.h::XEMACPS_MTU" ref="4c44b167e52f6d2ff3965234e933d23a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_MTU&nbsp;&nbsp;&nbsp;1500          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="580a6553eed0cf979f07fa53ab68b1f6"></a><!-- doxytag: member="xemacps.h::XEMACPS_MULTICAST_OPTION" ref="580a6553eed0cf979f07fa53ab68b1f6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_MULTICAST_OPTION&nbsp;&nbsp;&nbsp;0x00000800          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows reception of multicast addresses programmed into hash This option defaults to disabled (clear)
</div>
</div><p>
<a class="anchor" name="4ae3072d0f6da4bc4c9b6c17760abf57"></a><!-- doxytag: member="xemacps.h::XEMACPS_PROMISC_OPTION" ref="4ae3072d0f6da4bc4c9b6c17760abf57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_PROMISC_OPTION&nbsp;&nbsp;&nbsp;0x00000001          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accept all incoming packets. This option defaults to disabled (cleared)
</div>
</div><p>
<a class="anchor" name="b9205bb0478d2310f3e061e3e9ca3f92"></a><!-- doxytag: member="xemacps.h::XEMACPS_RECEIVER_ENABLE_OPTION" ref="b9205bb0478d2310f3e061e3e9ca3f92" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_RECEIVER_ENABLE_OPTION&nbsp;&nbsp;&nbsp;0x00000200          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable the receiver This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="433f658606ac8cfb01060c7c2d11ba10"></a><!-- doxytag: member="xemacps.h::XEMACPS_RX_CHKSUM_ENABLE_OPTION" ref="433f658606ac8cfb01060c7c2d11ba10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_RX_CHKSUM_ENABLE_OPTION&nbsp;&nbsp;&nbsp;0x00001000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable the RX checksum offload This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="27e7dded122fa828b016fdf6e8b79151"></a><!-- doxytag: member="xemacps.h::XEMACPS_SINGLE_BURST" ref="27e7dded122fa828b016fdf6e8b79151" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_SINGLE_BURST&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ea55959275d2be9d140c99364aee6795"></a><!-- doxytag: member="xemacps.h::XEmacPs_Transmit" ref="ea55959275d2be9d140c99364aee6795" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_Transmit          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xemacps__hw_8h.html#372948c9677f6859b62e87504fb2460e">XEmacPs_WriteReg</a>(InstancePtr-&gt;Config.BaseAddress,          \
        <a class="code" href="xemacps__hw_8h.html#e9bc110a6c627eb231938ebd4d89fecc">XEMACPS_NWCTRL_OFFSET</a>,                                     \
        (<a class="code" href="xemacps__hw_8h.html#81a4d6db864dea35b8ddd690f7615539">XEmacPs_ReadReg</a>(InstancePtr-&gt;Config.BaseAddress,          \
        <a class="code" href="xemacps__hw_8h.html#e9bc110a6c627eb231938ebd4d89fecc">XEMACPS_NWCTRL_OFFSET</a>) | <a class="code" href="xemacps__hw_8h.html#4806cbd82ef5923e260438608a4621eb">XEMACPS_NWCTRL_STARTTX_MASK</a>))
</pre></div>This macro triggers trasmit circuit to send data currently in TX buffer(s).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: void <a class="el" href="xemacps_8h.html#ea55959275d2be9d140c99364aee6795">XEmacPs_Transmit(XEmacPs *InstancePtr)</a>
</div>
</div><p>
<a class="anchor" name="b5521aa6e9ac40d0d1e168ce5383a7c5"></a><!-- doxytag: member="xemacps.h::XEMACPS_TRANSMITTER_ENABLE_OPTION" ref="b5521aa6e9ac40d0d1e168ce5383a7c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_TRANSMITTER_ENABLE_OPTION&nbsp;&nbsp;&nbsp;0x00000100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable the transmitter. This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="9b46761abbc3d28f3742fc23002b532a"></a><!-- doxytag: member="xemacps.h::XEMACPS_TRL_SIZE" ref="9b46761abbc3d28f3742fc23002b532a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_TRL_SIZE&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="19842c49b79b27a0d3133c1a02cf073c"></a><!-- doxytag: member="xemacps.h::XEMACPS_TX_CHKSUM_ENABLE_OPTION" ref="19842c49b79b27a0d3133c1a02cf073c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_TX_CHKSUM_ENABLE_OPTION&nbsp;&nbsp;&nbsp;0x00002000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable the TX checksum offload This option defaults to enabled (set)
</div>
</div><p>
<a class="anchor" name="c06000e56a82a3c8c529f3e00ddf8ff6"></a><!-- doxytag: member="xemacps.h::XEMACPS_VLAN_OPTION" ref="c06000e56a82a3c8c529f3e00ddf8ff6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_VLAN_OPTION&nbsp;&nbsp;&nbsp;0x00000004          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VLAN Rx &amp; Tx frame support. This option defaults to disabled (cleared)
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="208a480dc15f02a8119086c652d816bb"></a><!-- doxytag: member="xemacps.h::XEmacPs_ErrHandler" ref="208a480dc15f02a8119086c652d816bb" args="(void *CallBackRef, u8 Direction, u32 ErrorWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xemacps_8h.html#208a480dc15f02a8119086c652d816bb">XEmacPs_ErrHandler</a>(void *CallBackRef, u8 Direction, u32 ErrorWord)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback when an asynchronous error occurs. To set this callback, invoke <a class="el" href="xemacps_8h.html#6ff686c1d27451aa864729d78b9570d6">XEmacPs_SetHandler()</a> with XEMACPS_HANDLER_ERROR in the HandlerType paramter.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is user data assigned when the callback was set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>defines either receive or transmit error(s) has occurred. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ErrorWord</em>&nbsp;</td><td>definition varies with Direction </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b67a80fb3896481b6338a2ac2357ab33"></a><!-- doxytag: member="xemacps.h::XEmacPs_Handler" ref="b67a80fb3896481b6338a2ac2357ab33" args="(void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xemacps_8h.html#b67a80fb3896481b6338a2ac2357ab33">XEmacPs_Handler</a>(void *CallBackRef)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback invoked when frame(s) have been sent or received in interrupt driven DMA mode. To set the send callback, invoke <a class="el" href="xemacps_8h.html#6ff686c1d27451aa864729d78b9570d6">XEmacPs_SetHandler()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is user data assigned when the callback was set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps__hw_8h.html">xemacps_hw.h</a> for bitmasks definitions and the device hardware spec for further information on their meaning. </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="500aa2343a5a84ddd80bd52fb184f94f"></a><!-- doxytag: member="xemacps.h::XEmacPs_CfgInitialize" ref="500aa2343a5a84ddd80bd52fb184f94f" args="(XEmacPs *InstancePtr, XEmacPs_Config *CfgPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize a specific <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance/driver. The initialization entails:<ul>
<li>Initialize fields of the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance structure</li><li>Reset hardware and apply default options</li><li>Configure the DMA channels</li></ul>
<p>
The PHY is setup independently from the device. Use the MII or whatever other interface may be present for setup.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is the device configuration structure containing required hardware build data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the base address of the device. If address translation is not utilized, this parameter can be passed in using CfgPtr-&gt;Config.BaseAddress to specify the physical base address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="198e6a798ce0be3a5ab09e0d102766ef"></a><!-- doxytag: member="xemacps.h::XEmacPs_ClearHash" ref="198e6a798ce0be3a5ab09e0d102766ef" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_ClearHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear the Hash registers for the mac address pointed by AddressPtr.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2b82f01f4000f8e6a8ce45d8be43255c"></a><!-- doxytag: member="xemacps.h::XEmacPs_ClearOptions" ref="2b82f01f4000f8e6a8ce45d8be43255c" args="(XEmacPs *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_ClearOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clear options for the driver/device<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>are the options to clear. Multiple options can be cleared by OR'ing XEMACPS_*_OPTIONS constants together. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2821b9581e2be4c94990bb98052ce680"></a><!-- doxytag: member="xemacps.h::XEmacPs_DMABLengthUpdate" ref="2821b9581e2be4c94990bb98052ce680" args="(XEmacPs *InstancePtr, int BLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_DMABLengthUpdate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>BLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
API to update the Burst length in the DMACR register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BLength</em>&nbsp;</td><td>is the length in bytes for the dma burst.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d40aa55e3fbbf2e29379e15d07e3bd8"></a><!-- doxytag: member="xemacps.h::XEmacPs_GetHash" ref="4d40aa55e3fbbf2e29379e15d07e3bd8" args="(XEmacPs *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_GetHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the Hash address for this driver/device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is an output parameter, and is a pointer to a buffer into which the current HASH MAC address will be copied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c937dc7f20125b0af5b07de435d83df4"></a><!-- doxytag: member="xemacps.h::XEmacPs_GetMacAddress" ref="c937dc7f20125b0af5b07de435d83df4" args="(XEmacPs *InstancePtr, void *AddressPtr, u8 Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_GetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the MAC address for this driver/device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is an output parameter, and is a pointer to a buffer into which the current MAC address will be copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>is a index to which MAC (1-4) address. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0d7ec49a34ff5c1b4592ad6c9830a6b0"></a><!-- doxytag: member="xemacps.h::XEmacPs_GetOperatingSpeed" ref="0d7ec49a34ff5c1b4592ad6c9830a6b0" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XEmacPs_GetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XEmacPs_GetOperatingSpeed gets the current operating link speed. This may be the value set by <a class="el" href="xemacps_8h.html#e1f519684cc62697fd17f49e2658abd6">XEmacPs_SetOperatingSpeed()</a> or a hardware default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XEmacPs_GetOperatingSpeed returns the link speed in units of megabits per second.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="5508f6a12614b8df7369a16a60bc238e"></a><!-- doxytag: member="xemacps.h::XEmacPs_GetOptions" ref="5508f6a12614b8df7369a16a60bc238e" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XEmacPs_GetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get current option settings<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A bitmask of XTE_*_OPTION constants. Any bit set to 1 is to be interpreted as a set opion.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="59b9d4bbcb0a5e22d95f7363426b3267"></a><!-- doxytag: member="xemacps.h::XEmacPs_IntrHandler" ref="59b9d4bbcb0a5e22d95f7363426b3267" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_IntrHandler           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>XEmacPsPtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Master interrupt handler for EMAC driver. This routine will query the status of the device, bump statistics, and invoke user callbacks.<p>
This routine must be connected to an interrupt controller using OS/BSP specific methods.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>XEmacPsPtr</em>&nbsp;</td><td>is a pointer to the XEMACPS instance that has caused the interrupt. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="54751572e0cfaf72bce1bf26894291fb"></a><!-- doxytag: member="xemacps.h::XEmacPs_LookupConfig" ref="54751572e0cfaf72bce1bf26894291fb" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_emac_ps___config.html">XEmacPs_Config</a>* XEmacPs_LookupConfig           </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lookup the device configuration based on the unique device ID. The table contains the configuration info for each device in the system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6169714fe8417a642cfdde141f550b3c"></a><!-- doxytag: member="xemacps.h::XEmacPs_PhyRead" ref="6169714fe8417a642cfdde141f550b3c" args="(XEmacPs *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_PhyRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>PhyDataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read the current value of the PHY register indicated by the PhyAddress and the RegisterNum parameters. The MAC provides the driver with the ability to talk to a PHY that adheres to the Media Independent Interface (MII) as defined in the IEEE 802.3 standard.<p>
Prior to PHY access with this function, the user should have setup the MDIO clock with <a class="el" href="xemacps_8h.html#5d0b4b9258cdead2c0875a0853c087b3">XEmacPs_SetMdioDivisor()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyAddress</em>&nbsp;</td><td>is the address of the PHY to be read (supports multiple PHYs) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegisterNum</em>&nbsp;</td><td>is the register number, 0-31, of the specific PHY register to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyDataPtr</em>&nbsp;</td><td>is an output parameter, and points to a 16-bit buffer into which the current value of the register will be copied.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the PHY was read from successfully</li><li>XST_EMAC_MII_BUSY if there is another PHY operation in progress</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function is not thread-safe. The user must provide mutually exclusive access to this function if there are to be multiple threads that can call it.<p>
There is the possibility that this function will not return if the hardware is broken (i.e., it never sets the status bit indicating that the read is done). If this is of concern to the user, the user should provide a mechanism suitable to their needs for recovery.<p>
For the duration of this function, all host interface reads and writes are blocked to the current <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance.
</div>
</div><p>
<a class="anchor" name="2aa3ec40827c175ee46a8fd641ff960c"></a><!-- doxytag: member="xemacps.h::XEmacPs_PhyWrite" ref="2aa3ec40827c175ee46a8fd641ff960c" args="(XEmacPs *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_PhyWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>PhyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write data to the specified PHY register. The Ethernet driver does not require the device to be stopped before writing to the PHY. Although it is probably a good idea to stop the device, it is the responsibility of the application to deem this necessary. The MAC provides the driver with the ability to talk to a PHY that adheres to the Media Independent Interface (MII) as defined in the IEEE 802.3 standard.<p>
Prior to PHY access with this function, the user should have setup the MDIO clock with <a class="el" href="xemacps_8h.html#5d0b4b9258cdead2c0875a0853c087b3">XEmacPs_SetMdioDivisor()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyAddress</em>&nbsp;</td><td>is the address of the PHY to be written (supports multiple PHYs) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegisterNum</em>&nbsp;</td><td>is the register number, 0-31, of the specific PHY register to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhyData</em>&nbsp;</td><td>is the 16-bit value that will be written to the register</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if the PHY was written to successfully. Since there is no error status from the MAC on a write, the user should read the PHY to verify the write was successful.</li><li>XST_EMAC_MII_BUSY if there is another PHY operation in progress</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function is not thread-safe. The user must provide mutually exclusive access to this function if there are to be multiple threads that can call it.<p>
There is the possibility that this function will not return if the hardware is broken (i.e., it never sets the status bit indicating that the write is done). If this is of concern to the user, the user should provide a mechanism suitable to their needs for recovery.<p>
For the duration of this function, all host interface reads and writes are blocked to the current <a class="el" href="struct_x_emac_ps.html">XEmacPs</a> instance.
</div>
</div><p>
<a class="anchor" name="dd5f487c873ef70ab8fda69b4ec3938e"></a><!-- doxytag: member="xemacps.h::XEmacPs_Reset" ref="dd5f487c873ef70ab8fda69b4ec3938e" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_Reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform a graceful reset of the Ethernet MAC. Resets the DMA channels, the transmitter, and the receiver.<p>
Steps to reset<ul>
<li>Stops transmit and receive channels</li><li>Stops DMA</li><li>Configure transmit and receive buffer size to default</li><li>Clear transmit and receive status register and counters</li><li>Clear all interrupt sources</li><li>Clear phy (if there is any previously detected) address</li><li>Clear MAC addresses (1-4) as well as Type IDs and hash value</li></ul>
<p>
All options are placed in their default state. Any frames in the descriptor lists will remain in the lists. The side effect of doing this is that after a reset and following a restart of the device, frames were in the list before the reset may be transmitted or received.<p>
The upper layer software is responsible for re-configuring (if necessary) and restarting the MAC after the reset. Note also that driver statistics are not cleared on reset. It is up to the upper layer software to clear the statistics if needed.<p>
When a reset is required, the driver notifies the upper layer software of this need through the ErrorHandler callback and specific status codes. The upper layer software is responsible for calling this Reset function and then re-configuring the device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6a3673011fb4882dfcfc8366ecee2e6c"></a><!-- doxytag: member="xemacps.h::XEmacPs_SendPausePacket" ref="6a3673011fb4882dfcfc8366ecee2e6c" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SendPausePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a pause packet<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if pause frame transmission was initiated</li><li>XST_DEVICE_IS_STOPPED if the device has not been started. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="6ff686c1d27451aa864729d78b9570d6"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetHandler" ref="6ff686c1d27451aa864729d78b9570d6" args="(XEmacPs *InstancePtr, u32 HandlerType, void *FuncPtr, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Install an asynchronious handler function for the given HandlerType:<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HandlerType</em>&nbsp;</td><td>indicates what interrupt handler type is. XEMACPS_HANDLER_DMASEND, XEMACPS_HANDLER_DMARECV and XEMACPS_HANDLER_ERROR. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when when the callback function is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
None.<p>
<dl compact><dt><b>Note:</b></dt><dd>There is no assert on the CallBackRef since the driver doesn't know what it is. </dd></dl>

</div>
</div><p>
<a class="anchor" name="555ba66cf054a569dcdd602ae61d33d1"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetHash" ref="555ba66cf054a569dcdd602ae61d33d1" args="(XEmacPs *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetHash           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set 48-bit MAC addresses in hash table. The device must be stopped before calling this function.<p>
The hash address register is 64 bits long and takes up two locations in the memory map. The least significant bits are stored in hash register bottom and the most significant bits in hash register top.<p>
The unicast hash enable and the multicast hash enable bits in the network configuration register enable the reception of hash matched frames. The destination address is reduced to a 6 bit index into the 64 bit hash register using the following hash function. The hash function is an XOR of every sixth bit of the destination address.<p>
<pre>
 hash_index[05] = da[05]^da[11]^da[17]^da[23]^da[29]^da[35]^da[41]^da[47]
 hash_index[04] = da[04]^da[10]^da[16]^da[22]^da[28]^da[34]^da[40]^da[46]
 hash_index[03] = da[03]^da[09]^da[15]^da[21]^da[27]^da[33]^da[39]^da[45]
 hash_index[02] = da[02]^da[08]^da[14]^da[20]^da[26]^da[32]^da[38]^da[44]
 hash_index[01] = da[01]^da[07]^da[13]^da[19]^da[25]^da[31]^da[37]^da[43]
 hash_index[00] = da[00]^da[06]^da[12]^da[18]^da[24]^da[30]^da[36]^da[42]
 </pre><p>
da[0] represents the least significant bit of the first byte received, that is, the multicast/unicast indicator, and da[47] represents the most significant bit of the last byte received.<p>
If the hash index points to a bit that is set in the hash register then the frame will be matched according to whether the frame is multicast or unicast.<p>
A multicast match will be signaled if the multicast hash enable bit is set, da[0] is logic 1 and the hash index points to a bit set in the hash register.<p>
A unicast match will be signaled if the unicast hash enable bit is set, da[0] is logic 0 and the hash index points to a bit set in the hash register.<p>
To receive all multicast frames, the hash register should be set with all ones and the multicast hash enable bit should be set in the network configuration register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to a 6-byte MAC address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the HASH MAC address was set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li><li>XST_INVALID_PARAM if the HASH MAC address passed in does not meet requirement after calculation</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Having Aptr be unsigned type prevents the following operations from sign extending. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90199e95242edf13a5d83413812ec22d"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetMacAddress" ref="90199e95242edf13a5d83413812ec22d" args="(XEmacPs *InstancePtr, void *AddressPtr, u8 Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MAC address for this driver/device. The address is a 48-bit value. The device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to a 6-byte MAC address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>is a index to which MAC (1-4) address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the MAC address was set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="5d0b4b9258cdead2c0875a0853c087b3"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetMdioDivisor" ref="5d0b4b9258cdead2c0875a0853c087b3" args="(XEmacPs *InstancePtr, XEmacPs_MdcDiv Divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_SetMdioDivisor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__hw_8h.html#a367ea42c2214b487cf74951453204ff">XEmacPs_MdcDiv</a>&nbsp;</td>
          <td class="paramname"> <em>Divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the MDIO clock divisor.<p>
Calculating the divisor:<p>
<pre>
              f[HOSTCLK]
   f[MDC] = -----------------
            (1 + Divisor) * 2
 </pre><p>
where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster access. Here is the table to show values to generate MDC,<p>
<pre>
 000 : divide pclk by   8 (pclk up to  20 MHz)
 001 : divide pclk by  16 (pclk up to  40 MHz)
 010 : divide pclk by  32 (pclk up to  80 MHz)
 011 : divide pclk by  48 (pclk up to 120 MHz)
 100 : divide pclk by  64 (pclk up to 160 MHz)
 101 : divide pclk by  96 (pclk up to 240 MHz)
 110 : divide pclk by 128 (pclk up to 320 MHz)
 111 : divide pclk by 224 (pclk up to 540 MHz)
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is the divisor to set. Range is 0b000 to 0b111. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e1f519684cc62697fd17f49e2658abd6"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetOperatingSpeed" ref="e1f519684cc62697fd17f49e2658abd6" args="(XEmacPs *InstancePtr, u16 Speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_SetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Speed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XEmacPs_SetOperatingSpeed sets the current operating link speed. For any traffic to be passed, this speed must match the current MII/GMII/SGMII/RGMII link speed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Speed</em>&nbsp;</td><td>is the speed to set in units of Mbps. Valid values are 10, 100, or 1000. XEmacPs_SetOperatingSpeed ignores invalid values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>

</div>
</div><p>
<a class="anchor" name="ac00eaf66004d2d1d788ca01ed3b512c"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetOptions" ref="ac00eaf66004d2d1d788ca01ed3b512c" args="(XEmacPs *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set options for the driver/device. The driver should be stopped with <a class="el" href="xemacps_8c.html#f27b057022a2e97201f6d55d61d4a3da">XEmacPs_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>are the options to set. Multiple options can be set by OR'ing XTE_*_OPTIONS constants together. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the options were set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xemacps_8h.html">xemacps.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="54f76825f543ad6a85fadb5609b5bd06"></a><!-- doxytag: member="xemacps.h::XEmacPs_SetTypeIdCheck" ref="54f76825f543ad6a85fadb5609b5bd06" args="(XEmacPs *InstancePtr, u32 Id_Check, u8 Index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_SetTypeIdCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Id_Check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the Type ID match for this driver/device. The register is a 32-bit value. The device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Id_Check</em>&nbsp;</td><td>is type ID to be configured. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index</em>&nbsp;</td><td>is a index to which Type ID (1-4).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the MAC address was set successfully</li><li>XST_DEVICE_IS_STARTED if the device has not yet been stopped </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="be875d0d136e28a166363d66dd7b7f27"></a><!-- doxytag: member="xemacps.h::XEmacPs_Start" ref="be875d0d136e28a166363d66dd7b7f27" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_Start           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the Ethernet controller as follows:<ul>
<li>Enable transmitter if XTE_TRANSMIT_ENABLE_OPTION is set</li><li>Enable receiver if XTE_RECEIVER_ENABLE_OPTION is set</li><li>Start the SG DMA send and receive channels and enable the device interrupt</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Hardware is configured with scatter-gather DMA, the driver expects to start the scatter-gather channels and expects that the user has previously set up the buffer descriptor lists.</dd></dl>
This function makes use of internal resources that are shared between the Start, Stop, and Set/ClearOptions functions. So if one task might be setting device options while another is trying to start the device, the user is required to provide protection of this shared data (typically using a semaphore).<p>
This function must not be preempted by an interrupt that may service the device.
</div>
</div><p>
<a class="anchor" name="f27b057022a2e97201f6d55d61d4a3da"></a><!-- doxytag: member="xemacps.h::XEmacPs_Stop" ref="f27b057022a2e97201f6d55d61d4a3da" args="(XEmacPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XEmacPs_Stop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps.html">XEmacPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gracefully stop the Ethernet MAC as follows:<ul>
<li>Disable all interrupts from this device</li><li>Stop DMA channels</li><li>Disable the tansmitter and receiver</li></ul>
<p>
Device options currently in effect are not changed.<p>
This function will disable all interrupts. Default interrupts settings that had been enabled will be restored when <a class="el" href="xemacps_8c.html#be875d0d136e28a166363d66dd7b7f27">XEmacPs_Start()</a> is called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>This function makes use of internal resources that are shared between the Start, Stop, SetOptions, and ClearOptions functions. So if one task might be setting device options while another is trying to start the device, the user is required to provide protection of this shared data (typically using a semaphore).</dd></dl>
Stopping the DMA channels causes this function to block until the DMA operation is complete.
</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
