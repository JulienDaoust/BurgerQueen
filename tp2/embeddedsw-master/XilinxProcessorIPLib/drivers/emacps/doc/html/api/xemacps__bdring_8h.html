<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xemacps_bdring.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xemacps_bdring.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The Xiline EmacPs Buffer Descriptor ring driver. This is part of EmacPs DMA functionalities.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a wsy  01/10/10 First release
 </pre>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#ba0ead5d4e585baf6e3d03209968c413">XEMACPS_BDRING_H</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#f634277466b3d759cf1770ef4e263886">XEmacPs_BdRingCntCalc</a>(Alignment, Bytes)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#f5234fa28a21cd02e35fc3d49b73ff4d">XEmacPs_BdRingMemCalc</a>(Alignment, NumBd)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#668214818403599166ca19be2c2e7a6b">XEmacPs_BdRingGetCnt</a>(RingPtr)&nbsp;&nbsp;&nbsp;((RingPtr)-&gt;AllCnt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#2206d6117c95bb46b85ee4d45dcafb00">XEmacPs_BdRingGetFreeCnt</a>(RingPtr)&nbsp;&nbsp;&nbsp;((RingPtr)-&gt;FreeCnt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#78e691ca1e87aca56ebead6d6b6057a4">XEmacPs_BdRingNext</a>(RingPtr, BdPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#de23035ee29807c56ca61ab241d4ba0c">XEmacPs_BdRingPrev</a>(RingPtr, BdPtr)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#1b6f53633ad6466e00391274d182fc6b">XEmacPs_BdRingCreate</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, unsigned BdCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#270fe8d08e62a06b9a3fd8ed53a72ac5">XEmacPs_BdRingClone</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *SrcBdPtr, u8 Direction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#6d7d4a8a571956b6ddef55307f3b2c7b">XEmacPs_BdRingAlloc</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#21b6448036402f452539e3f17a36e915">XEmacPs_BdRingUnAlloc</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#def8169a514444cbb7e615d6e11b05a3">XEmacPs_BdRingToHw</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#7bb4a77d78a9111d56b6bb8dacf6926d">XEmacPs_BdRingFree</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned NumBd, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#4079f7078273f2f0082992362cb796f4">XEmacPs_BdRingFromHwTx</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned BdLimit, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#48529a85670d455aba4cce4cc7887b6b">XEmacPs_BdRingFromHwRx</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, unsigned BdLimit, <a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> **BdSetPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xemacps__bdring_8h.html#acabf15bb439fc0fd795a5cb8358ce27">XEmacPs_BdRingCheck</a> (<a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *RingPtr, u8 Direction)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ba0ead5d4e585baf6e3d03209968c413"></a><!-- doxytag: member="xemacps_bdring.h::XEMACPS_BDRING_H" ref="ba0ead5d4e585baf6e3d03209968c413" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEMACPS_BDRING_H          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f634277466b3d759cf1770ef4e263886"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingCntCalc" ref="f634277466b3d759cf1770ef4e263886" args="(Alignment, Bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_BdRingCntCalc          </td>
          <td>(</td>
          <td class="paramtype">Alignment,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bytes&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(u32)((Bytes) / ((<span class="keyword">sizeof</span>(<a class="code" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a>) + ((Alignment)-1)) &amp;   \
    ~((Alignment)-1)))
</pre></div>Use this macro at initialization time to determine how many BDs will fit in a BD list within the given memory constraints.<p>
The results of this macro can be provided to <a class="el" href="xemacps__bdring_8c.html#1b6f53633ad6466e00391274d182fc6b">XEmacPs_BdRingCreate()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>specifies what byte alignment the BDs must fall on and must be a power of 2 to get an accurate calculation (32, 64, 128,...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Bytes</em>&nbsp;</td><td>is the number of bytes to be used to store BDs.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of BDs that can fit in the given memory area</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xemacps__bdring_8h.html#f634277466b3d759cf1770ef4e263886">XEmacPs_BdRingCntCalc(u32 Alignment, u32 Bytes)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="668214818403599166ca19be2c2e7a6b"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingGetCnt" ref="668214818403599166ca19be2c2e7a6b" args="(RingPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_BdRingGetCnt          </td>
          <td>(</td>
          <td class="paramtype">RingPtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((RingPtr)-&gt;AllCnt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the total number of BDs allocated by this channel with <a class="el" href="xemacps__bdring_8c.html#1b6f53633ad6466e00391274d182fc6b">XEmacPs_BdRingCreate()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the DMA channel to operate on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The total number of BDs allocated for this channel.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xemacps__bdring_8h.html#668214818403599166ca19be2c2e7a6b">XEmacPs_BdRingGetCnt(XEmacPs_BdRing* RingPtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2206d6117c95bb46b85ee4d45dcafb00"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingGetFreeCnt" ref="2206d6117c95bb46b85ee4d45dcafb00" args="(RingPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_BdRingGetFreeCnt          </td>
          <td>(</td>
          <td class="paramtype">RingPtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((RingPtr)-&gt;FreeCnt)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the number of BDs allocatable with <a class="el" href="xemacps__bdring_8c.html#6d7d4a8a571956b6ddef55307f3b2c7b">XEmacPs_BdRingAlloc()</a> for pre- processing.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the DMA channel to operate on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of BDs currently allocatable.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xemacps__bdring_8h.html#2206d6117c95bb46b85ee4d45dcafb00">XEmacPs_BdRingGetFreeCnt(XEmacPs_BdRing* RingPtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5234fa28a21cd02e35fc3d49b73ff4d"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingMemCalc" ref="f5234fa28a21cd02e35fc3d49b73ff4d" args="(Alignment, NumBd)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_BdRingMemCalc          </td>
          <td>(</td>
          <td class="paramtype">Alignment,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NumBd&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(u32)((<span class="keyword">sizeof</span>(<a class="code" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a>) + ((Alignment)-1)) &amp;              \
    ~((Alignment)-1)) * (NumBd)
</pre></div>Use this macro at initialization time to determine how many bytes of memory is required to contain a given number of BDs at a given alignment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>specifies what byte alignment the BDs must fall on. This parameter must be a power of 2 to get an accurate calculation (32, 64, 128,...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to calculate memory size requirements for</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes of memory required to create a BD list with the given memory constraints.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xemacps__bdring_8h.html#f5234fa28a21cd02e35fc3d49b73ff4d">XEmacPs_BdRingMemCalc(u32 Alignment, u32 NumBd)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="78e691ca1e87aca56ebead6d6b6057a4"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingNext" ref="78e691ca1e87aca56ebead6d6b6057a4" args="(RingPtr, BdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_BdRingNext          </td>
          <td>(</td>
          <td class="paramtype">RingPtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BdPtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(((u32)(BdPtr) &gt;= (RingPtr)-&gt;HighBdAddr) ?                     \
    (<a class="code" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a>*)(RingPtr)-&gt;BaseBdAddr :                              \
    (<a class="code" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a>*)((u32)(BdPtr) + (RingPtr)-&gt;Separation))
</pre></div>Return the next BD from BdPtr in a list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the DMA channel to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdPtr</em>&nbsp;</td><td>is the BD to operate on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The next BD in the list relative to the BdPtr parameter.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: XEmacPs_Bd *XEmacPs_BdRingNext(XEmacPs_BdRing* RingPtr, XEmacPs_Bd *BdPtr) </dd></dl>

</div>
</div><p>
<a class="anchor" name="de23035ee29807c56ca61ab241d4ba0c"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingPrev" ref="de23035ee29807c56ca61ab241d4ba0c" args="(RingPtr, BdPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XEmacPs_BdRingPrev          </td>
          <td>(</td>
          <td class="paramtype">RingPtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BdPtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(((u32)(BdPtr) &lt;= (RingPtr)-&gt;BaseBdAddr) ?                     \
    (<a class="code" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a>*)(RingPtr)-&gt;HighBdAddr :                              \
    (<a class="code" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a>*)((u32)(BdPtr) - (RingPtr)-&gt;Separation))
</pre></div>Return the previous BD from BdPtr in the list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the DMA channel to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdPtr</em>&nbsp;</td><td>is the BD to operate on</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The previous BD in the list relative to the BdPtr parameter.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: XEmacPs_Bd *XEmacPs_BdRingPrev(XEmacPs_BdRing* RingPtr, XEmacPs_Bd *BdPtr) </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="6d7d4a8a571956b6ddef55307f3b2c7b"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingAlloc" ref="6d7d4a8a571956b6ddef55307f3b2c7b" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd **BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingAlloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> **&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reserve locations in the BD list. The set of returned BDs may be modified in preparation for future DMA transaction(s). Once the BDs are ready to be submitted to hardware, the user must call <a class="el" href="xemacps__bdring_8c.html#def8169a514444cbb7e615d6e11b05a3">XEmacPs_BdRingToHw()</a> in the same order which they were allocated here. Example:<p>
<pre>
        NumBd = 2;
        Status = XEmacPs_BdRingAlloc(MyRingPtr, NumBd, &amp;MyBdSet);</pre><p>
<pre>        if (Status != XST_SUCCESS)
        {
            // Not enough BDs available for the request
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
            // Prepare CurBd.....</pre><p>
<pre>            // Onto next BD
            CurBd = <a class="el" href="xemacps__bdring_8h.html#78e691ca1e87aca56ebead6d6b6057a4">XEmacPs_BdRingNext(MyRingPtr, CurBd)</a>;
        }</pre><p>
<pre>        // Give list to hardware
        Status = XEmacPs_BdRingToHw(MyRingPtr, NumBd, MyBdSet);
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be allocated and given to hardware in the correct sequence: <pre>
        // Legal
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd1, MySet1);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingAlloc(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd2, MySet2);
        XEmacPs_BdRingToHw(MyRingPtr, NumBd1, MySet1);
 </pre><p>
Use the API defined in <a class="el" href="xemacps__bd_8h.html">xemacps_bd.h</a> to modify individual BDs. Traversal of the BD set can be done using <a class="el" href="xemacps__bdring_8h.html#78e691ca1e87aca56ebead6d6b6057a4">XEmacPs_BdRingNext()</a> and <a class="el" href="xemacps__bdring_8h.html#de23035ee29807c56ca61ab241d4ba0c">XEmacPs_BdRingPrev()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the BD ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for modification.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the requested number of BDs was returned in the BdSetPtr parameter.</li><li>XST_FAILURE if there were not enough free BDs to satisfy the request.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism.<p>
Do not modify more BDs than the number requested with the NumBd parameter. Doing so will lead to data corruption and system instability. </dd></dl>

</div>
</div><p>
<a class="anchor" name="acabf15bb439fc0fd795a5cb8358ce27"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingCheck" ref="acabf15bb439fc0fd795a5cb8358ce27" args="(XEmacPs_BdRing *RingPtr, u8 Direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check the internal data structures of the BD ring for the provided channel. The following checks are made:<p>
<ul>
<li>Is the BD ring linked correctly in physical address space.</li><li>Do the internal pointers point to BDs in the ring.</li><li>Do the internal counters add up.</li></ul>
<p>
The channel should be stopped prior to calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is either XEMACPS_SEND or XEMACPS_RECV that indicates which direction.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was freed.</li><li>XST_DMA_SG_NO_LIST if the list has not been created.</li><li>XST_IS_STARTED if the channel is not stopped.</li><li>XST_DMA_SG_LIST_ERROR if a problem is found with the internal data structures. If this value is returned, the channel should be reset to avoid data corruption or system instability.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>

</div>
</div><p>
<a class="anchor" name="270fe8d08e62a06b9a3fd8ed53a72ac5"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingClone" ref="270fe8d08e62a06b9a3fd8ed53a72ac5" args="(XEmacPs_BdRing *RingPtr, XEmacPs_Bd *SrcBdPtr, u8 Direction)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingClone           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>SrcBdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Direction</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clone the given BD into every BD in the list. every field of the source BD is replicated in every BD of the list.<p>
This function can be called only when all BDs are in the free group such as they are immediately after initialization with <a class="el" href="xemacps__bdring_8c.html#1b6f53633ad6466e00391274d182fc6b">XEmacPs_BdRingCreate()</a>. This prevents modification of BDs while they are in use by hardware or the user.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the pointer of BD ring instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcBdPtr</em>&nbsp;</td><td>is the source BD template to be cloned into the list. This BD will be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Direction</em>&nbsp;</td><td>is either XEMACPS_SEND or XEMACPS_RECV that indicates which direction.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the list was modified.</li><li>XST_DMA_SG_NO_LIST if a list has not been created.</li><li>XST_DMA_SG_LIST_ERROR if some of the BDs in this channel are under hardware or user control.</li><li>XST_DEVICE_IS_STARTED if the DMA channel has not been stopped. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="1b6f53633ad6466e00391274d182fc6b"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingCreate" ref="1b6f53633ad6466e00391274d182fc6b" args="(XEmacPs_BdRing *RingPtr, u32 PhysAddr, u32 VirtAddr, u32 Alignment, unsigned BdCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingCreate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhysAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>VirtAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>BdCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Using a memory segment allocated by the caller, create and setup the BD list for the given DMA channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PhysAddr</em>&nbsp;</td><td>is the physical base address of user memory region. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VirtAddr</em>&nbsp;</td><td>is the virtual base address of the user memory region. If address translation is not being utilized, then VirtAddr should be equivalent to PhysAddr. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Alignment</em>&nbsp;</td><td>governs the byte alignment of individual BDs. This function will enforce a minimum alignment of 4 bytes with no maximum as long as it is specified as a power of 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdCount</em>&nbsp;</td><td>is the number of BDs to setup in the user memory region. It is assumed the region is large enough to contain the BDs.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if initialization was successful</li><li>XST_NO_FEATURE if the provided instance is a non DMA type channel.</li><li>XST_INVALID_PARAM under any of the following conditions: 1) PhysAddr and/or VirtAddr are not aligned to the given Alignment parameter; 2) Alignment parameter does not meet minimum requirements or is not a power of 2 value; 3) BdCount is 0.</li><li>XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans over address 0x00000000 in virtual address space.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Make sure to pass in the right alignment value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bb4a77d78a9111d56b6bb8dacf6926d"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingFree" ref="7bb4a77d78a9111d56b6bb8dacf6926d" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingFree           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees a set of BDs that had been previously retrieved with XEmacPs_BdRingFromHw().<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to free. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the head of a list of BDs returned by XEmacPs_BdRingFromHw().</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was freed.</li><li>XST_DMA_SG_LIST_ERROR if this function was called out of sequence with XEmacPs_BdRingFromHw().</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>

</div>
</div><p>
<a class="anchor" name="48529a85670d455aba4cce4cc7887b6b"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingFromHwRx" ref="48529a85670d455aba4cce4cc7887b6b" args="(XEmacPs_BdRing *RingPtr, unsigned BdLimit, XEmacPs_Bd **BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned XEmacPs_BdRingFromHwRx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>BdLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> **&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a set of BD(s) that have been processed by hardware. The returned BDs may be examined to determine the outcome of the DMA transaction(s). Once the BDs have been examined, the user must call <a class="el" href="xemacps__bdring_8c.html#7bb4a77d78a9111d56b6bb8dacf6926d">XEmacPs_BdRingFree()</a> in the same order which they were retrieved here. Example:<p>
<pre>
        NumBd = XEmacPs_BdRingFromHwRx(MyRingPtr, MaxBd, &amp;MyBdSet);</pre><p>
<pre>        if (NumBd == 0)
        {
           // hardware has nothing ready for us yet
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
           // Examine CurBd for post processing.....</pre><p>
<pre>           // Onto next BD
           CurBd = <a class="el" href="xemacps__bdring_8h.html#78e691ca1e87aca56ebead6d6b6057a4">XEmacPs_BdRingNext(MyRingPtr, CurBd)</a>;
           }</pre><p>
<pre>           XEmacPs_BdRingFree(MyRingPtr, NumBd, MyBdSet); // Return list
        }
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be retrieved from hardware and freed in the correct sequence: <pre>
        // Legal
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwRx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
 </pre><p>
If hardware has only partially completed a packet spanning multiple BDs, then none of the BDs for that packet will be included in the results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdLimit</em>&nbsp;</td><td>is the maximum number of BDs to return in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for examination.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of BDs processed by hardware. A value of 0 indicates that no data is available. No more than BdLimit BDs will be returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Treat BDs returned by this function as read-only.<p>
This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4079f7078273f2f0082992362cb796f4"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingFromHwTx" ref="4079f7078273f2f0082992362cb796f4" args="(XEmacPs_BdRing *RingPtr, unsigned BdLimit, XEmacPs_Bd **BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned XEmacPs_BdRingFromHwTx           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>BdLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> **&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a set of BD(s) that have been processed by hardware. The returned BDs may be examined to determine the outcome of the DMA transaction(s). Once the BDs have been examined, the user must call <a class="el" href="xemacps__bdring_8c.html#7bb4a77d78a9111d56b6bb8dacf6926d">XEmacPs_BdRingFree()</a> in the same order which they were retrieved here. Example:<p>
<pre>
        NumBd = XEmacPs_BdRingFromHwTx(MyRingPtr, MaxBd, &amp;MyBdSet);</pre><p>
<pre>        if (NumBd == 0)
        {
           // hardware has nothing ready for us yet
        }</pre><p>
<pre>        CurBd = MyBdSet;
        for (i=0; i&lt;NumBd; i++)
        {
           // Examine CurBd for post processing.....</pre><p>
<pre>           // Onto next BD
           CurBd = <a class="el" href="xemacps__bdring_8h.html#78e691ca1e87aca56ebead6d6b6057a4">XEmacPs_BdRingNext(MyRingPtr, CurBd)</a>;
           }</pre><p>
<pre>           XEmacPs_BdRingFree(MyRingPtr, NumBd, MyBdSet); // Return list
        }
 </pre><p>
A more advanced use of this function may allocate multiple sets of BDs. They must be retrieved from hardware and freed in the correct sequence: <pre>
        // Legal
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);</pre><p>
<pre>        // Legal
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);</pre><p>
<pre>        // Not legal
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd1, &amp;MySet1);
        XEmacPs_BdRingFromHwTx(MyRingPtr, NumBd2, &amp;MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd2, MySet2);
        XEmacPs_BdRingFree(MyRingPtr, NumBd1, MySet1);
 </pre><p>
If hardware has only partially completed a packet spanning multiple BDs, then none of the BDs for that packet will be included in the results.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdLimit</em>&nbsp;</td><td>is the maximum number of BDs to return in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for examination.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of BDs processed by hardware. A value of 0 indicates that no data is available. No more than BdLimit BDs will be returned.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Treat BDs returned by this function as read-only.<p>
This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>

</div>
</div><p>
<a class="anchor" name="def8169a514444cbb7e615d6e11b05a3"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingToHw" ref="def8169a514444cbb7e615d6e11b05a3" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingToHw           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enqueue a set of BDs to hardware that were previously allocated by <a class="el" href="xemacps__bdring_8c.html#6d7d4a8a571956b6ddef55307f3b2c7b">XEmacPs_BdRingAlloc()</a>. Once this function returns, the argument BD set goes under hardware control. Any changes made to these BDs after this point will corrupt the BD list leading to data corruption and system instability.<p>
The set will be rejected if the last BD of the set does not mark the end of a packet (see <a class="el" href="xemacps__bd_8h.html#6d15c187fa133cb4b74489d60ad08c39">XEmacPs_BdSetLast()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs in the set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is the first BD of the set to commit to hardware.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the set of BDs was accepted and enqueued to hardware.</li><li>XST_FAILURE if the set of BDs was rejected because the last BD of the set did not have its "last" bit set.</li><li>XST_DMA_SG_LIST_ERROR if this function was called out of sequence with <a class="el" href="xemacps__bdring_8c.html#6d7d4a8a571956b6ddef55307f3b2c7b">XEmacPs_BdRingAlloc()</a>.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>

</div>
</div><p>
<a class="anchor" name="21b6448036402f452539e3f17a36e915"></a><!-- doxytag: member="xemacps_bdring.h::XEmacPs_BdRingUnAlloc" ref="21b6448036402f452539e3f17a36e915" args="(XEmacPs_BdRing *RingPtr, unsigned NumBd, XEmacPs_Bd *BdSetPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XEmacPs_BdRingUnAlloc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_emac_ps___bd_ring.html">XEmacPs_BdRing</a> *&nbsp;</td>
          <td class="paramname"> <em>RingPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>NumBd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xemacps__bd_8h.html#bdac9aa9170655a763bf06bab3aa2a62">XEmacPs_Bd</a> *&nbsp;</td>
          <td class="paramname"> <em>BdSetPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fully or partially undo an <a class="el" href="xemacps__bdring_8c.html#6d7d4a8a571956b6ddef55307f3b2c7b">XEmacPs_BdRingAlloc()</a> operation. Use this function if all the BDs allocated by <a class="el" href="xemacps__bdring_8c.html#6d7d4a8a571956b6ddef55307f3b2c7b">XEmacPs_BdRingAlloc()</a> could not be transferred to hardware with <a class="el" href="xemacps__bdring_8c.html#def8169a514444cbb7e615d6e11b05a3">XEmacPs_BdRingToHw()</a>.<p>
This function helps out in situations when an unrelated error occurs after BDs have been allocated but before they have been given to hardware. An example of this type of error would be an OS running out of resources.<p>
This function is not the same as <a class="el" href="xemacps__bdring_8c.html#7bb4a77d78a9111d56b6bb8dacf6926d">XEmacPs_BdRingFree()</a>. The Free function returns BDs to the free list after they have been processed by hardware, while UnAlloc returns them before being processed by hardware.<p>
There are two scenarios where this function can be used. Full UnAlloc or Partial UnAlloc. A Full UnAlloc means all the BDs Alloc'd will be returned:<p>
<pre>
    Status = XEmacPs_BdRingAlloc(MyRingPtr, 10, &amp;BdPtr);
        ...
    if (Error)
    {
        Status = XEmacPs_BdRingUnAlloc(MyRingPtr, 10, &amp;BdPtr);
    }
 </pre><p>
A partial UnAlloc means some of the BDs Alloc'd will be returned:<p>
<pre>
    Status = XEmacPs_BdRingAlloc(MyRingPtr, 10, &amp;BdPtr);
    BdsLeft = 10;
    CurBdPtr = BdPtr;</pre><p>
<pre>    while (BdsLeft)
    {
       if (Error)
       {
          Status = XEmacPs_BdRingUnAlloc(MyRingPtr, BdsLeft, CurBdPtr);
       }</pre><p>
<pre>       CurBdPtr = <a class="el" href="xemacps__bdring_8h.html#78e691ca1e87aca56ebead6d6b6057a4">XEmacPs_BdRingNext(MyRingPtr, CurBdPtr)</a>;
       BdsLeft--;
    }
 </pre><p>
A partial UnAlloc must include the last BD in the list that was Alloc'd.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>RingPtr</em>&nbsp;</td><td>is a pointer to the instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NumBd</em>&nbsp;</td><td>is the number of BDs to allocate </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BdSetPtr</em>&nbsp;</td><td>is an output parameter, it points to the first BD available for modification.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the BDs were unallocated.</li><li>XST_FAILURE if NumBd parameter was greater that the number of BDs in the preprocessing state.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function should not be preempted by another XEmacPs_Bd function call that modifies the BD space. It is the caller's responsibility to provide a mutual exclusion mechanism. </dd></dl>

</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
