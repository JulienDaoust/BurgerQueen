<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver spips v2_0: xspips.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xspips.c File Reference</h1><code>#include &quot;<a class="el" href="xspips_8h.html">xspips.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a213e0ea6c896e8d8351bfc3a9499345a">XSpiPs_SendByte</a>(BaseAddress, Data)&nbsp;&nbsp;&nbsp;XSpiPs_Out32((BaseAddress) + XSPIPS_TXD_OFFSET, (Data))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#aa16f1269388412a12617f154b7d8b47a">XSpiPs_RecvByte</a>(BaseAddress)&nbsp;&nbsp;&nbsp;(u8)XSpiPs_In32((BaseAddress) + XSPIPS_RXD_OFFSET)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a080d853850655991dc9097367496c224">XSpiPs_CfgInitialize</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, <a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#ad3abd2456cfa67bc8d24dd255ba7de51">XSpiPs_Reset</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a06d3ce216591f69946d2d4822a0dc57f">XSpiPs_Transfer</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a49a95c2c4040817b5c9bd33af1cf54a6">XSpiPs_PolledTransfer</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#aab915aca035d6044f9f3f75e60933f10">XSpiPs_SetSlaveSelect</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, u8 SlaveSel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a4efc98fb1e6b9a927146bd3bcab8ea8b">XSpiPs_GetSlaveSelect</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#ae66d524321dcbd9a81f116d3432463fc">XSpiPs_SetStatusHandler</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr, void *CallBackRef, <a class="el" href="xspips_8h.html#a68b431786f9e933c87472953f831569e">XSpiPs_StatusHandler</a> FuncPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a183b277f174211654db2834597375aa8">XSpiPs_InterruptHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspips_8c.html#a1f40732e67f63579b811af115f2c575c">XSpiPs_Abort</a> (<a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Contains implements the interface functions of the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> driver. See <a class="el" href="xspips_8h.html">xspips.h</a> for a detailed description of the device and driver.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who    Date     Changes
 ----- ------ -------- -----------------------------------------------
 1.00  drg/jz 01/25/10 First release
 1.01	sg     03/07/12 Updated the code to always clear the relevant bits
			before writing to config register.
			Always clear the slave select bits before write and
			clear the bits to no slave at the end of transfer
			Modified the Polled transfer transmit/receive logic.
			Tx should wait on TXOW Interrupt and Rx on RXNEMTY.
 1.03	sg     09/21/12 Added memory barrier dmb in polled transfer and
			interrupt handler to overcome the clock domain
			crossing issue in the controller. For CR #679252.
 1.04a	sg     01/30/13 Changed SPI transfer logic for polled and interrupt
			modes to be based on filled tx fifo count and receive
			based on it. RXNEMPTY interrupt is not used.
			SetSlaveSelect API logic is modified to drive the bit
			position low based on the slave select value
			requested. GetSlaveSelect API will return the value
			based on bit position that is low.
 1.06a hk     08/22/13 Changed GetSlaveSelect function. CR# 727866.
                       Added masking ConfigReg before writing in SetSlaveSel
                       Added extended slave select support - CR#722569.
                       Added check for MODF in polled transfer function.</pre><pre> </pre> <hr/><h2>Define Documentation</h2>
<a class="anchor" id="aa16f1269388412a12617f154b7d8b47a"></a><!-- doxytag: member="xspips.c::XSpiPs_RecvByte" ref="aa16f1269388412a12617f154b7d8b47a" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_RecvByte</td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(u8)XSpiPs_In32((BaseAddress) + XSPIPS_RXD_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a213e0ea6c896e8d8351bfc3a9499345a"></a><!-- doxytag: member="xspips.c::XSpiPs_SendByte" ref="a213e0ea6c896e8d8351bfc3a9499345a" args="(BaseAddress, Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpiPs_SendByte</td>
          <td>(</td>
          <td class="paramtype">BaseAddress, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Data&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpiPs_Out32((BaseAddress) + XSPIPS_TXD_OFFSET, (Data))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1f40732e67f63579b811af115f2c575c"></a><!-- doxytag: member="xspips.c::XSpiPs_Abort" ref="a1f40732e67f63579b811af115f2c575c" args="(XSpiPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Aborts a transfer in progress by disabling the device and resetting the FIFOs if present. The byte counts are cleared, the busy flag is cleared, and mode fault is cleared.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function does a read/modify/write of the Config register. The user of this function needs to take care of critical sections. </p>

</div>
</div>
<a class="anchor" id="a080d853850655991dc9097367496c224"></a><!-- doxytag: member="xspips.c::XSpiPs_CfgInitialize" ref="a080d853850655991dc9097367496c224" args="(XSpiPs *InstancePtr, XSpiPs_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpiPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps___config.html">XSpiPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance such that the driver is ready to use.</p>
<p>The state of the device after initialization is:</p>
<ul>
<li>Device is disabled</li>
<li>Slave mode</li>
<li>Active high clock polarity</li>
<li>Clock phase 0</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a reference to a structure containing information about a specific SPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use ConfigPtr-&gt;Config.BaseAddress for this device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_DEVICE_IS_STARTED if the device is already started. It must be stopped to re-initialize.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4efc98fb1e6b9a927146bd3bcab8ea8b"></a><!-- doxytag: member="xspips.c::XSpiPs_GetSlaveSelect" ref="a4efc98fb1e6b9a927146bd3bcab8ea8b" args="(XSpiPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSpiPs_GetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the current slave select setting for the SPI device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The slave number selected (starting from 0).</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a183b277f174211654db2834597375aa8"></a><!-- doxytag: member="xspips.c::XSpiPs_InterruptHandler" ref="a183b277f174211654db2834597375aa8" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interrupt handler for SPI interrupts. This function must be connected by the user to an interrupt controller.</p>
<p>The interrupts that are handled are:</p>
<ul>
<li>Mode Fault Error. This interrupt is generated if this device is selected as a slave when it is configured as a master. The driver aborts any data transfer that is in progress by resetting FIFOs (if present) and resetting its buffer pointers. The upper layer software is informed of the error.</li>
</ul>
<ul>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until the transfer is done.</li>
</ul>
<ul>
<li>Data Transmit Register (FIFO) Underflow. This interrupt is generated when the SPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Data Receive Register (FIFO) Overflow. This interrupt is generated when the SPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Slave Mode Fault Error. This interrupt is generated if a slave device is selected as a slave while it is disabled. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The slave select register is being set to deselect the slave when a transfer is complete. This is being done regardless of whether it is a slave or a master since the hardware does not drive the slave select as a slave. </p>

</div>
</div>
<a class="anchor" id="a49a95c2c4040817b5c9bd33af1cf54a6"></a><!-- doxytag: member="xspips.c::XSpiPs_PolledTransfer" ref="a49a95c2c4040817b5c9bd33af1cf54a6" args="(XSpiPs *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpiPs_PolledTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfers specified data on the SPI bus in polled mode.</p>
<p>The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: </p>
<pre>
   XSpiPs_PolledTransfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><pre>   XSpiPs_PolledTransfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><pre>   XSpiPs_PolledTransfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><pre>   XSpiPs_PolledTransfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends.  The device must send N bytes of data if it wishes to
	receive N bytes of data.</pre><pre> </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a buffer of data for sending. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer for received data. This argument can be NULL if do not care about receiving. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the buffers are successfully handed off to the device for transfer.</li>
<li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time. </p>

</div>
</div>
<a class="anchor" id="ad3abd2456cfa67bc8d24dd255ba7de51"></a><!-- doxytag: member="xspips.c::XSpiPs_Reset" ref="ad3abd2456cfa67bc8d24dd255ba7de51" args="(XSpiPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the SPI device. Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Any data transfer that is in progress is aborted.</p>
<p>The upper layer software is responsible for re-configuring (if necessary) and restarting the SPI device after the reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aab915aca035d6044f9f3f75e60933f10"></a><!-- doxytag: member="xspips.c::XSpiPs_SetSlaveSelect" ref="aab915aca035d6044f9f3f75e60933f10" args="(XSpiPs *InstancePtr, u8 SlaveSel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpiPs_SetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>SlaveSel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects or deselect the slave with which the master communicates. This setting affects the SPI_ss_outN signals. The behavior depends on the setting of the CR_SSDECEN bit. If CR_SSDECEN is 0, the SPI_ss_outN bits will be output with a single signal low. If CR_SSDECEN is 1, the SPI_ss_outN bits will reflect the value set.</p>
<p>The user is not allowed to deselect the slave while a transfer is in progress. If no transfer is in progress, the user can select a new slave, which implicitly deselects the current slave. In order to explicitly deselect the current slave, a value of all 1's, 0x0F can be passed in as the argument to the function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveSel</em>&nbsp;</td><td>is the slave number to be selected. Normally, 3 slaves can be selected with values 0-2. In case, 3-8 decode option is set, then upto 8 slaves can be selected. Only one slave can be selected at a time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li>
<li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the SPI is idle. The slave select has no affect when the device is configured as a slave. </p>

</div>
</div>
<a class="anchor" id="ae66d524321dcbd9a81f116d3432463fc"></a><!-- doxytag: member="xspips.c::XSpiPs_SetStatusHandler" ref="ae66d524321dcbd9a81f116d3432463fc" args="(XSpiPs *InstancePtr, void *CallBackRef, XSpiPs_StatusHandler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpiPs_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xspips_8h.html#a68b431786f9e933c87472953f831569e">XSpiPs_StatusHandler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to upper layer software. The handler executes in an interrupt context, so it must minimize the amount of processing performed. One of the following status events is passed to the status handler.</p>
<pre>
 XST_SPI_MODE_FAULT		A mode fault error occurred, meaning the device
				is selected as slave while being a master.</pre><pre> XST_SPI_TRANSFER_DONE		The requested data transfer is done</pre><pre> XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked data
				but there were none available in the transmit
				register/FIFO. This typically means the slave
				application did not issue a transfer request
				fast enough, or the processor/driver could not
				fill the transmit register/FIFO fast enough.</pre><pre> XST_SPI_RECEIVE_OVERRUN	The SPI device lost data. Data was received
				but the receive data register/FIFO was full.</pre><pre> XST_SPI_SLAVE_MODE_FAULT	A slave SPI device was selected as a slave
				while it was disabled. This indicates the
				master is already transferring data (which is
				being dropped until the slave application
				issues a transfer).
 </pre> <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The handler is called within interrupt context, so it should do its work quickly and queue potentially time-consuming work to a task-level thread. </p>

</div>
</div>
<a class="anchor" id="a06d3ce216591f69946d2d4822a0dc57f"></a><!-- doxytag: member="xspips.c::XSpiPs_Transfer" ref="a06d3ce216591f69946d2d4822a0dc57f" args="(XSpiPs *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpiPs_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi_ps.html">XSpiPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfers specified data on the SPI bus. If the SPI device is configured as a master, this function initiates bus communication and sends/receives the data to/from the selected SPI slave. If the SPI device is configured as a slave, this function prepares the buffers to be sent/received when selected by a master. For every byte sent, a byte is received. This function should be used to perform interrupt based transfers.</p>
<p>The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: </p>
<pre>
   XSpiPs_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><pre>   XSpiPs_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><pre>   XSpiPs_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><pre>   XSpiPs_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends.  The device must send N bytes of data if it wishes to
	receive N bytes of data.
 </pre><p> Although this function takes entire buffers as arguments, the driver can only transfer a limited number of bytes at a time, limited by the size of the FIFO. A call to this function only starts the transfer, then subsequent transfers of the data is performed by the interrupt service routine until the entire buffer has been transferred. The status callback function is called when the entire buffer has been sent/received.</p>
<p>This function is non-blocking. As a master, the SetSlaveSelect function must be called prior to this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi_ps.html">XSpiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a buffer of data for sending. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer for received data. This argument can be NULL if do not care about receiving. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the buffers are successfully handed off to the device for transfer.</li>
<li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time. </p>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
