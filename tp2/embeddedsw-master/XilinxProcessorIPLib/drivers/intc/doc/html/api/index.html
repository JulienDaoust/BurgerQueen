<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   intc v3_3
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>intc v3_3</h1>
<p>
The Xilinx interrupt controller driver component. This component supports the Xilinx interrupt controller.<p>
The interrupt controller driver uses the idea of priority for the various handlers. Priority is an integer within the range of 0 and 31 inclusive with 0 being the highest priority interrupt source.<p>
The Xilinx interrupt controller supports the following features:<p>
<ul>
<li>specific individual interrupt enabling/disabling</li><li>specific individual interrupt acknowledging</li><li>attaching specific callback function to handle interrupt source</li><li>master enable/disable</li><li>single callback per interrupt or all pending interrupts handled for each interrupt of the processor</li></ul>
<p>
The acknowledgement of the interrupt within the interrupt controller is selectable, either prior to the device's handler being called or after the handler is called. This is necessary to support interrupt signal inputs which are either edge or level signals. Edge driven interrupt signals require that the interrupt is acknowledged prior to the interrupt being serviced in order to prevent the loss of interrupts which are occurring extremely close together. A level driven interrupt input signal requires the interrupt to acknowledged after servicing the interrupt to ensure that the interrupt only generates a single interrupt condition.<p>
Details about connecting the interrupt handler of the driver are contained in the source file specific to interrupt processing, <a class="el" href="xintc__intr_8c.html">xintc_intr.c</a>.<p>
This driver is intended to be RTOS and processor independent. It works with physical addresses only. Any needs for dynamic memory management, threads or thread mutual exclusion, virtual memory, or cache control must be satisfied by the layer above this driver.<p>
<b>Interrupt Vector Tables</b><p>
The interrupt vector table for each interrupt controller device is declared statically in <a class="el" href="xintc__g_8c.html">xintc_g.c</a> within the configuration data for each instance. The device ID of the interrupt controller device is used by the driver as a direct index into the configuration data table - to retrieve the vector table for an instance of the interrupt controller. The user should populate the vector table with handlers and callbacks at run-time using the <a class="el" href="xintc_8c.html#ee9ec5873a764994d64b4da35a110084">XIntc_Connect()</a> and <a class="el" href="xintc_8c.html#8f7caaeb26b6b264fffefbd32f90f855">XIntc_Disconnect()</a> functions.<p>
Each vector table entry corresponds to a device that can generate an interrupt. Each entry contains an interrupt handler function and an argument to be passed to the handler when an interrupt occurs. The tools default this argument to the base address of the interrupting device. Note that the device driver interrupt handlers given in this file do not take a base address as an argument, but instead take a pointer to the driver instance. This means that although the table is created statically, the user must still use <a class="el" href="xintc_8c.html#ee9ec5873a764994d64b4da35a110084">XIntc_Connect()</a> when the interrupt handler takes an argument other than the base address. This is only to say that the existence of the static vector tables should not mislead the user into thinking they no longer need to register/connect interrupt handlers with this driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a ecm  08/16/01 First release
 1.00a rpm  01/09/02 Removed the AckLocation argument from <a class="el" href="xintc_8c.html#ee9ec5873a764994d64b4da35a110084">XIntc_Connect()</a>.
                     This information is now internal in <a class="el" href="xintc__g_8c.html">xintc_g.c</a>.
 1.00b jhl  02/13/02 Repartitioned the driver for smaller files
 1.00b jhl  04/24/02 Made LookupConfig function global and relocated config
                     data type
 1.00c rpm  10/17/03 New release. Support the static vector table created
                     in the <a class="el" href="xintc__g_8c.html">xintc_g.c</a> configuration table. Moved vector
                     table and options out of instance structure and into
                     the configuration table.
 1.10c mta  03/21/07 Updated to new coding style
 1.11a sv   11/21/07 Updated driver to support access through a DCR bridge
 2.00a ktn  10/20/09 Updated to use HAL Processor APIs and _m is removed from
		      all the macro names/definitions.
 2.01a sdm  04/27/10 Updated the tcl so that the defintions are generated in
		      the xparameters.h to know whether the optional registers
		      SIE, CIE and IVR are enabled in the HW - Refer CR 555392.
		      This driver doesnot make use of these definitions and does
		      not use the optional registers.
 2.03a hvm  05/24/11 Updated the tcl to generate vector Ids for external
		      interrupts. CR565336
 2.04a bss  01/13/12 Added XIntc_ConnectFastHandler API for Fast Interrupt
		      and XIntc_SetNormalIntrMode for setting to normal
		      interrupt mode.
 2.04a asa  03/19/12 Changed the <a class="el" href="struct_x_intc___config.html">XIntc_Config</a> struct. The order of entries
		      declared in the structure now matches with the
		      XIntc_ConfigTable generated by the driver tcl.
 2.05a bss  08/16/12 Updated to support relocatable vectors in Microblaze,
		      added IntVectorAddr to <a class="el" href="struct_x_intc___config.html">XIntc_Config</a> for this.
		      Added XIntc_RegisterFastHandler API to register fast
		      interrupt handlers using base address.
 2.06a bss  01/28/13 To support Cascade mode:
 		      Added XIN_INTC_NOCASCADE,XIN_INTC_PRIMARY,
		      XIN_INTC_SECONDARY,XIN_INTC_LAST and
		      XIN_CONTROLLER_MAX_INTRS  macros
		      Added NumberofIntrs and IntcType fields in <a class="el" href="struct_x_intc___config.html">XIntc_Config</a>
		      structure.
		      Modified XIntc_Initialize,XIntc_Start,XIntc_Connect
		      XIntc_Disconnect,XIntc_Enable,XIntc_Disable,
		      XIntc_Acknowledge,XIntc_ConnectFastHandler and
		      XIntc_SetNormalIntrMode APIs.Added XIntc_InitializeSlaves
		      API in <a class="el" href="xintc_8c.html">xintc.c</a>
  		      Modified XIntc_DeviceInterruptHandler,
  		      XIntc_SetIntrSvcOption,XIntc_RegisterHandler and
		      XIntc_RegisterFastHandler APIs.Added XIntc_CascadeHandler
		      API in <a class="el" href="xintc__l_8c.html">xintc_l.c</a>.
		      Modified XIntc_SetOptions API in <a class="el" href="xintc__options_8c.html">xintc_options.c</a>.
		      Modified XIntc_SimulateIntr API in <a class="el" href="xintc__selftest_8c.html">xintc_selftest.c</a>.
		      Modified driver tcl:
			to check for Cascade mode and generate XPAR_INTC_TYPE
			for each controller.
			Generate XPAR_INTC_MAX_NUM_INTR_INPUTS by adding all
			interrupt sources of all Controllers in Cascade mode.
 2.07a bss  10/18/13 To support Nested interrupts:
		      Modified XIntc_DeviceInterruptHandler API.
		      Added XIN_ILR_OFFSET macro in <a class="el" href="xintc__l_8h.html">xintc_l.h</a>.
		      Modified driver tcl to generate HAS_ILR parameter in
		      xparameters.h
 3.0   bss  01/28/13 Modified <a class="el" href="xintc_8c.html">xintc.c</a> to initialize IVAR register with
		      XPAR_MICROBLAZE_BASE_VECTORS + 0x10 to fix
		      CR#765931.
		      Modified driver tcl to generate XPAR_AXI_INTC_0_TYPE
		      correctly(CR#764865).</pre><p>
<pre><dl compact><dt><b>Note:</b></dt><dd>For Cascade mode, Interrupt IDs are generated in xparameters.h
		as shown below:</dd></dl>
Master/Primary INTC
		 ______
		|      |-0      Secondary INTC
		|      |-.         ______
		|      |-.        |      |-32        Last INTC
		|      |-.        |      |-.          ______
		|______|&lt;-31------|      |-.         |      |-64
			          |      |-.         |      |-.
			          |______|&lt;-63-------|      |-.
                                                    |      |-.
                                                    |______|-95</pre><p>
<pre>		All driver functions has to be called using DeviceId/
		InstancePtr/BaseAddress of Primary/Master Controller and
		Interrupts IDs generated in xparameters.h only.
		Driver functions takes care of Slave Controllers based on
		Interrupt ID passed. User must not use Interrupt source/ID
		31 of Primary and Secondary controllers to call driver
		functions.</pre><p>
<pre>		For nested interrupts, XIntc_DeviceInterruptHandler saves
		microblaze r14 register on entry and restores on exit. This is
		required since compiler does not support nesting. It enables
		Microblaze interrupts after blocking further interrupts from
		the current interrupt number and interrupts below current
		interrupt proirity by writing to Interrupt Level Register of
		INTC on entry. On exit, it disables microblaze interrupts and
		restores ILR register default value(0xFFFFFFFF)back. It is
		recommended to increase STACK_SIZE in linker script for nested
		interrupts.
 3.0     adk    12/10/13  Updated as per the New Tcl API's
 3.0 	  adk 	 17/02/14  Fixed the CR:771287 Changes are made in the intc
 		           driver tcl.
 3.1     adk    8/4/14    Fixed the CR:783248 Changes are made in
			   the test-app tcl
 3.2     bss    4/8/14    Fixed driver tcl to handle external interrupt pins
			   correctly (CR#799609).
 3.3     adk    11/3/14   added generation of C_HAS_ILR parameter to
			   xparameters.h.Changes are made in the driver tcl file
			   (CR#828046).</pre><p>
<pre> </pre> Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
