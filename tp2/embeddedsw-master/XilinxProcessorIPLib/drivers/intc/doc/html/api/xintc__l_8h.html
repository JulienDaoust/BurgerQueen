<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xintc_l.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xintc_l.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This header file contains identifiers and low-level driver functions (or macros) that can be used to access the device. The user should refer to the hardware device specification for more details of the device operation.<p>
Note that users of the driver interface given in this file can register an interrupt handler dynamically (at run-time) using the <a class="el" href="xintc__l_8c.html#d1f8540fa2171b00a3af03329677f684">XIntc_RegisterHandler()</a> function. User of the driver interface given in <a class="el" href="xintc_8h.html">xintc.h</a> should still use <a class="el" href="xintc_8c.html#ee9ec5873a764994d64b4da35a110084">XIntc_Connect()</a>, as always. Also see the discussion of the interrupt vector tables in <a class="el" href="xintc_8h.html">xintc.h</a>.<p>
There are currently two interrupt handlers specified in this interface.<p>
<ul>
<li><a class="el" href="xintc__l_8h.html#bf91e27eb2cc036f84df2e15d14343a8">XIntc_LowLevelInterruptHandler()</a> is a handler without any arguments that is used in cases where there is a single interrupt controller device in the system and the handler cannot be passed an argument. This function is provided mostly for backward compatibility.</li></ul>
<p>
<ul>
<li><a class="el" href="xintc__l_8c.html#ce91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler()</a> is a handler that takes a device ID as an argument, indicating which interrupt controller device in the system is causing the interrupt - thereby supporting multiple interrupt controllers.</li></ul>
<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -----------------------------------------------------
 1.00b jhl  04/24/02 First release
 1.00c rpm  10/17/03 New release. Support the static vector table created
                     in the <a class="el" href="xintc__g_8c.html">xintc_g.c</a> configuration table.
 1.10c mta  03/21/07 Updated to new coding style
 1.11a sv   11/21/07 Updated driver to support access through a DCR bridge
 2.00a ktn  10/20/09 Updated to use HAL Processor APIs. _m is removed from all
		      the macro definitions.
 2.04a bss  01/13/12 Updated for adding defines for IMR and IVAR for
                     the FAST Interrupt
 2.05a bss  08/18/12 Added XIntc_RegisterFastHandler API to register fast
		      interrupt handlers using base address.
 2.07a bss  10/18/13 Added XIN_ILR_OFFSET macro for nested interrupts.</pre><p>
<pre> </pre>
<p>
<code>#include &quot;xil_types.h&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;xparameters.h&quot;</code><br>
<code>#include &quot;xil_io.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_intc___vector_table_entry.html">XIntc_VectorTableEntry</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#2591750e740c97fb30372d7fd6fba9ca">XINTC_L_H</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#06a568b99545df04b6d14da3b04f1da0">XPAR_XINTC_USE_DCR_BRIDGE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#4c1ce88ba61c2e42054faaef40539556">XIN_ISR_OFFSET</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#35c8f39e63012c1745df6faa39fc7335">XIN_IPR_OFFSET</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#12fbacf76cabd206d17acefd187fa7b4">XIN_IER_OFFSET</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#f12b5f9e19d0d544e8df96699db615bd">XIN_IAR_OFFSET</a>&nbsp;&nbsp;&nbsp;12</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#e3d1be1c28564014eba1e6a7da5f870c">XIN_SIE_OFFSET</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#1f88cc0f7e4c0fec39f68d4926537461">XIN_CIE_OFFSET</a>&nbsp;&nbsp;&nbsp;20</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#4704ae1ae4388d4b0187bb2ee79849d1">XIN_IVR_OFFSET</a>&nbsp;&nbsp;&nbsp;24</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#1286cdd3996f53dfe62703e6cd949b14">XIN_MER_OFFSET</a>&nbsp;&nbsp;&nbsp;28</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#2dc06911d25b46e1ddad8e2938f95b4c">XIN_IMR_OFFSET</a>&nbsp;&nbsp;&nbsp;32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#c92a6982a2d3a0f70a310c6912392765">XIN_ILR_OFFSET</a>&nbsp;&nbsp;&nbsp;36</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#b675a4446c4ab809551ea73ad2ca962d">XIN_IVAR_OFFSET</a>&nbsp;&nbsp;&nbsp;0x100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#a03735b19bf625b8868dd3633554addf">XIN_INT_MASTER_ENABLE_MASK</a>&nbsp;&nbsp;&nbsp;0x1UL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#399d5f29c768070adc3ac98c54c6634d">XIN_INT_HARDWARE_ENABLE_MASK</a>&nbsp;&nbsp;&nbsp;0x2UL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#0254df2003fdd1434617b0477224f748">XIntc_In32</a>&nbsp;&nbsp;&nbsp;Xil_In32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#c245f85f403876d4e23cf5e24439a66a">XIntc_Out32</a>&nbsp;&nbsp;&nbsp;Xil_Out32</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#f2aeec4bbc6e0c5ca2268e5d7c7dd5ce">XIntc_MasterEnable</a>(BaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#93be82188a607b0a13a13a96c5787bb6">XIntc_MasterDisable</a>(BaseAddress)&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_MER_OFFSET, 0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#d35ec3b9b658f26d989b19783954683e">XIntc_EnableIntr</a>(BaseAddress, EnableMask)&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#5df77bd3561a105f1d6b1837762db956">XIntc_DisableIntr</a>(BaseAddress, DisableMask)&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#4f699042980f8453713171959183fc49">XIntc_AckIntr</a>(BaseAddress, AckMask)&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#13c828dcbbdc3441c8abaded5cda888b">XIntc_GetIntrStatus</a>(BaseAddress)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#6de21b6c45b4ee4a4443b8daf9749e07">XFastInterruptHandler</a> (void)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#bf91e27eb2cc036f84df2e15d14343a8">XIntc_LowLevelInterruptHandler</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#ce91a1aeaf1a88e1b769decb4ac4a818">XIntc_DeviceInterruptHandler</a> (void *DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#b8e5767995d6318e6fc5cf114cda7b68">XIntc_SetIntrSvcOption</a> (u32 BaseAddress, int Option)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#d1f8540fa2171b00a3af03329677f684">XIntc_RegisterHandler</a> (u32 BaseAddress, int InterruptId, XInterruptHandler Handler, void *CallBackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xintc__l_8h.html#ed2ddee41f0861539f959522ce2f44af">XIntc_RegisterFastHandler</a> (u32 BaseAddress, u8 Id, <a class="el" href="xintc__l_8h.html#6de21b6c45b4ee4a4443b8daf9749e07">XFastInterruptHandler</a> FastHandler)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="1f88cc0f7e4c0fec39f68d4926537461"></a><!-- doxytag: member="xintc_l.h::XIN_CIE_OFFSET" ref="1f88cc0f7e4c0fec39f68d4926537461" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_CIE_OFFSET&nbsp;&nbsp;&nbsp;20          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f12b5f9e19d0d544e8df96699db615bd"></a><!-- doxytag: member="xintc_l.h::XIN_IAR_OFFSET" ref="f12b5f9e19d0d544e8df96699db615bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IAR_OFFSET&nbsp;&nbsp;&nbsp;12          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="12fbacf76cabd206d17acefd187fa7b4"></a><!-- doxytag: member="xintc_l.h::XIN_IER_OFFSET" ref="12fbacf76cabd206d17acefd187fa7b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IER_OFFSET&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c92a6982a2d3a0f70a310c6912392765"></a><!-- doxytag: member="xintc_l.h::XIN_ILR_OFFSET" ref="c92a6982a2d3a0f70a310c6912392765" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_ILR_OFFSET&nbsp;&nbsp;&nbsp;36          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2dc06911d25b46e1ddad8e2938f95b4c"></a><!-- doxytag: member="xintc_l.h::XIN_IMR_OFFSET" ref="2dc06911d25b46e1ddad8e2938f95b4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IMR_OFFSET&nbsp;&nbsp;&nbsp;32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="399d5f29c768070adc3ac98c54c6634d"></a><!-- doxytag: member="xintc_l.h::XIN_INT_HARDWARE_ENABLE_MASK" ref="399d5f29c768070adc3ac98c54c6634d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_INT_HARDWARE_ENABLE_MASK&nbsp;&nbsp;&nbsp;0x2UL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a03735b19bf625b8868dd3633554addf"></a><!-- doxytag: member="xintc_l.h::XIN_INT_MASTER_ENABLE_MASK" ref="a03735b19bf625b8868dd3633554addf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_INT_MASTER_ENABLE_MASK&nbsp;&nbsp;&nbsp;0x1UL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="35c8f39e63012c1745df6faa39fc7335"></a><!-- doxytag: member="xintc_l.h::XIN_IPR_OFFSET" ref="35c8f39e63012c1745df6faa39fc7335" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IPR_OFFSET&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4c1ce88ba61c2e42054faaef40539556"></a><!-- doxytag: member="xintc_l.h::XIN_ISR_OFFSET" ref="4c1ce88ba61c2e42054faaef40539556" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_ISR_OFFSET&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b675a4446c4ab809551ea73ad2ca962d"></a><!-- doxytag: member="xintc_l.h::XIN_IVAR_OFFSET" ref="b675a4446c4ab809551ea73ad2ca962d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IVAR_OFFSET&nbsp;&nbsp;&nbsp;0x100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4704ae1ae4388d4b0187bb2ee79849d1"></a><!-- doxytag: member="xintc_l.h::XIN_IVR_OFFSET" ref="4704ae1ae4388d4b0187bb2ee79849d1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_IVR_OFFSET&nbsp;&nbsp;&nbsp;24          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1286cdd3996f53dfe62703e6cd949b14"></a><!-- doxytag: member="xintc_l.h::XIN_MER_OFFSET" ref="1286cdd3996f53dfe62703e6cd949b14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_MER_OFFSET&nbsp;&nbsp;&nbsp;28          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e3d1be1c28564014eba1e6a7da5f870c"></a><!-- doxytag: member="xintc_l.h::XIN_SIE_OFFSET" ref="e3d1be1c28564014eba1e6a7da5f870c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIN_SIE_OFFSET&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4f699042980f8453713171959183fc49"></a><!-- doxytag: member="xintc_l.h::XIntc_AckIntr" ref="4f699042980f8453713171959183fc49" args="(BaseAddress, AckMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_AckIntr          </td>
          <td>(</td>
          <td class="paramtype">BaseAddress,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AckMask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_IAR_OFFSET, (AckMask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acknowledge specific interrupt(s) in the interrupt controller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AckMask</em>&nbsp;</td><td>is the 32-bit value to write to the acknowledge register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will acknowledge interrupts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xintc__l_8h.html#4f699042980f8453713171959183fc49">XIntc_AckIntr(u32 BaseAddress, u32 AckMask)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="5df77bd3561a105f1d6b1837762db956"></a><!-- doxytag: member="xintc_l.h::XIntc_DisableIntr" ref="5df77bd3561a105f1d6b1837762db956" args="(BaseAddress, DisableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_DisableIntr          </td>
          <td>(</td>
          <td class="paramtype">BaseAddress,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DisableMask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, ~(DisableMask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable specific interrupt(s) in the interrupt controller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DisableMask</em>&nbsp;</td><td>is the 32-bit value to write to the enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will disable interrupts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xintc__l_8h.html#5df77bd3561a105f1d6b1837762db956">XIntc_DisableIntr(u32 BaseAddress, u32 DisableMask)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="d35ec3b9b658f26d989b19783954683e"></a><!-- doxytag: member="xintc_l.h::XIntc_EnableIntr" ref="d35ec3b9b658f26d989b19783954683e" args="(BaseAddress, EnableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_EnableIntr          </td>
          <td>(</td>
          <td class="paramtype">BaseAddress,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnableMask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_IER_OFFSET, (EnableMask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable specific interrupt(s) in the interrupt controller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EnableMask</em>&nbsp;</td><td>is the 32-bit value to write to the enable register. Each bit of the mask corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Only the bits which are set in the mask will enable interrupts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xintc__l_8h.html#d35ec3b9b658f26d989b19783954683e">XIntc_EnableIntr(u32 BaseAddress, u32 EnableMask)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="13c828dcbbdc3441c8abaded5cda888b"></a><!-- doxytag: member="xintc_l.h::XIntc_GetIntrStatus" ref="13c828dcbbdc3441c8abaded5cda888b" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_GetIntrStatus          </td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xintc__l_8h.html#0254df2003fdd1434617b0477224f748">XIntc_In32</a>((BaseAddress) + <a class="code" href="xintc__l_8h.html#4c1ce88ba61c2e42054faaef40539556">XIN_ISR_OFFSET</a>) &amp; \
        <a class="code" href="xintc__l_8h.html#0254df2003fdd1434617b0477224f748">XIntc_In32</a>((BaseAddress) + <a class="code" href="xintc__l_8h.html#12fbacf76cabd206d17acefd187fa7b4">XIN_IER_OFFSET</a>))
</pre></div>Get the interrupt status from the interrupt controller which indicates which interrupts are active and enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The 32-bit contents of the interrupt status register. Each bit corresponds to an interrupt input signal that is connected to the interrupt controller (INT0 = LSB). Bits which are set indicate an active interrupt which is also enabled.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xintc__l_8h.html#13c828dcbbdc3441c8abaded5cda888b">XIntc_GetIntrStatus(u32 BaseAddress)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="0254df2003fdd1434617b0477224f748"></a><!-- doxytag: member="xintc_l.h::XIntc_In32" ref="0254df2003fdd1434617b0477224f748" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_In32&nbsp;&nbsp;&nbsp;Xil_In32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2591750e740c97fb30372d7fd6fba9ca"></a><!-- doxytag: member="xintc_l.h::XINTC_L_H" ref="2591750e740c97fb30372d7fd6fba9ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XINTC_L_H          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="93be82188a607b0a13a13a96c5787bb6"></a><!-- doxytag: member="xintc_l.h::XIntc_MasterDisable" ref="93be82188a607b0a13a13a96c5787bb6" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_MasterDisable          </td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XIntc_Out32((BaseAddress) + XIN_MER_OFFSET, 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disable all interrupts in the Master Enable register of the interrupt controller.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xintc__l_8h.html#93be82188a607b0a13a13a96c5787bb6">XIntc_MasterDisable(u32 BaseAddress)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="f2aeec4bbc6e0c5ca2268e5d7c7dd5ce"></a><!-- doxytag: member="xintc_l.h::XIntc_MasterEnable" ref="f2aeec4bbc6e0c5ca2268e5d7c7dd5ce" args="(BaseAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_MasterEnable          </td>
          <td>(</td>
          <td class="paramtype">BaseAddress&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xintc__l_8h.html#c245f85f403876d4e23cf5e24439a66a">XIntc_Out32</a>((BaseAddress) + <a class="code" href="xintc__l_8h.html#1286cdd3996f53dfe62703e6cd949b14">XIN_MER_OFFSET</a>, \
        <a class="code" href="xintc__l_8h.html#a03735b19bf625b8868dd3633554addf">XIN_INT_MASTER_ENABLE_MASK</a> | <a class="code" href="xintc__l_8h.html#399d5f29c768070adc3ac98c54c6634d">XIN_INT_HARDWARE_ENABLE_MASK</a>)
</pre></div>Enable all interrupts in the Master Enable register of the interrupt controller. The interrupt controller defaults to all interrupts disabled from reset such that this macro must be used to enable interrupts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xintc__l_8h.html#f2aeec4bbc6e0c5ca2268e5d7c7dd5ce">XIntc_MasterEnable(u32 BaseAddress)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="c245f85f403876d4e23cf5e24439a66a"></a><!-- doxytag: member="xintc_l.h::XIntc_Out32" ref="c245f85f403876d4e23cf5e24439a66a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIntc_Out32&nbsp;&nbsp;&nbsp;Xil_Out32          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="06a568b99545df04b6d14da3b04f1da0"></a><!-- doxytag: member="xintc_l.h::XPAR_XINTC_USE_DCR_BRIDGE" ref="06a568b99545df04b6d14da3b04f1da0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XPAR_XINTC_USE_DCR_BRIDGE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="6de21b6c45b4ee4a4443b8daf9749e07"></a><!-- doxytag: member="xintc_l.h::XFastInterruptHandler" ref="6de21b6c45b4ee4a4443b8daf9749e07" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xintc__l_8h.html#6de21b6c45b4ee4a4443b8daf9749e07">XFastInterruptHandler</a>(void)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ce91a1aeaf1a88e1b769decb4ac4a818"></a><!-- doxytag: member="xintc_l.h::XIntc_DeviceInterruptHandler" ref="ce91a1aeaf1a88e1b769decb4ac4a818" args="(void *DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_DeviceInterruptHandler           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the primary interrupt handler for the driver. It must be connected to the interrupt source such that is called when an interrupt of the interrupt controller is active. It will resolve which interrupts are active and enabled and call the appropriate interrupt handler. It uses the AckBeforeService flag in the configuration data to determine when to acknowledge the interrupt. Highest priority interrupts are serviced first. This function assumes that an interrupt vector table has been previously initialized.It does not verify that entries in the table are valid before calling an interrupt handler. In Cascade mode this function calls XIntc_CascadeHandler to handle interrupts of Master and Slave controllers. This functions also handles interrupts nesting by saving and restoring link register of Microblaze and Interrupt Level register of interrupt controller properly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the zero-based device ID defined in xparameters.h of the interrupting interrupt controller. It is used as a direct index into the configuration data, which contains the vector table for the interrupt controller. Note that even though the argument is a void pointer, the value is not a pointer but the actual device ID. The void pointer type is necessary to meet the XInterruptHandler typedef for interrupt handlers.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>For nested interrupts, this function saves microblaze r14 register on entry and restores on exit. This is required since compiler does not support nesting. This function enables Microblaze interrupts after blocking further interrupts from the current interrupt number and interrupts below current interrupt proirity by writing to Interrupt Level Register of INTC on entry. On exit, it disables microblaze interrupts and restores ILR register default value(0xFFFFFFFF)back. It is recommended to increase STACK_SIZE in linker script for nested interrupts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf91e27eb2cc036f84df2e15d14343a8"></a><!-- doxytag: member="xintc_l.h::XIntc_LowLevelInterruptHandler" ref="bf91e27eb2cc036f84df2e15d14343a8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_LowLevelInterruptHandler           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ed2ddee41f0861539f959522ce2f44af"></a><!-- doxytag: member="xintc_l.h::XIntc_RegisterFastHandler" ref="ed2ddee41f0861539f959522ce2f44af" args="(u32 BaseAddress, u8 Id, XFastInterruptHandler FastHandler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_RegisterFastHandler           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xintc__l_8h.html#6de21b6c45b4ee4a4443b8daf9749e07">XFastInterruptHandler</a>&nbsp;</td>
          <td class="paramname"> <em>FastHandler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a fast handler function for a specific interrupt ID. The handler function will be called when an interrupt occurs for the given interrupt ID. In Cascade mode Interrupt Id is used to set Handler for corresponding Slave Controller<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptId</em>&nbsp;</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FastHandler</em>&nbsp;</td><td>is the function pointer that will be called when interrupt occurs</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Note that this function has no effect if the input base address is invalid.
</div>
</div><p>
<a class="anchor" name="d1f8540fa2171b00a3af03329677f684"></a><!-- doxytag: member="xintc_l.h::XIntc_RegisterHandler" ref="d1f8540fa2171b00a3af03329677f684" args="(u32 BaseAddress, int InterruptId, XInterruptHandler Handler, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_RegisterHandler           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>InterruptId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XInterruptHandler&nbsp;</td>
          <td class="paramname"> <em>Handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Register a handler function for a specific interrupt ID. The vector table of the interrupt controller is updated, overwriting any previous handler. The handler function will be called when an interrupt occurs for the given interrupt ID.<p>
This function can also be used to remove a handler from the vector table by passing in the XIntc_DefaultHandler() as the handler and NULL as the callback reference. In Cascade mode Interrupt Id is used to set Handler for corresponding Slave Controller<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the base address of the interrupt controller whose vector table will be modified. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptId</em>&nbsp;</td><td>is the interrupt ID to be associated with the input handler. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Handler</em>&nbsp;</td><td>is the function pointer that will be added to the vector table for the given interrupt ID. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the argument that will be passed to the new handler function when it is called. This is user-specific.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Note that this function has no effect if the input base address is invalid.
</div>
</div><p>
<a class="anchor" name="b8e5767995d6318e6fc5cf114cda7b68"></a><!-- doxytag: member="xintc_l.h::XIntc_SetIntrSvcOption" ref="b8e5767995d6318e6fc5cf114cda7b68" args="(u32 BaseAddress, int Option)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIntc_SetIntrSvcOption           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BaseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the interrupt service option, which can configure the driver so that it services only a single interrupt at a time when an interrupt occurs, or services all pending interrupts when an interrupt occurs. The default behavior when using the driver interface given in <a class="el" href="xintc_8h.html">xintc.h</a> file is to service only a single interrupt, whereas the default behavior when using the driver interface given in this file is to service all outstanding interrupts when an interrupt occurs. In Cascade mode same Option is set to Slave controllers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>BaseAddress</em>&nbsp;</td><td>is the unique identifier for a device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Option</em>&nbsp;</td><td>is XIN_SVC_SGL_ISR_OPTION if you want only a single interrupt serviced when an interrupt occurs, or XIN_SVC_ALL_ISRS_OPTION if you want all pending interrupts serviced when an interrupt occurs.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Note that this function has no effect if the input base address is invalid.
</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
