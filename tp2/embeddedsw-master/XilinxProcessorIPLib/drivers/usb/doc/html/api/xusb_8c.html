<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver usb v5_0: xusb.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xusb.c File Reference</h1><code>#include &quot;<a class="el" href="xusb_8h.html">xusb.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a05f262f5c35f642fefc16b7912086265">XUsb_CfgInitialize</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, <a class="el" href="struct_x_usb___config.html">XUsb_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a9c50c0ee6d36d4b87a40018c2ad0fd25">XUsb_ConfigureDevice</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, <a class="el" href="struct_x_usb___device_config.html">XUsb_DeviceConfig</a> *CfgPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a4708ca8b9ca477b58d7da7db3f1be308">XUsb_Start</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a53f7e5c356dbe880560a6eb5942a74d6">XUsb_Stop</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a2bfe41baf4bcdaae0da439ec758de24e">XUsb_GetFrameNum</a> (const <a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#aa2f7958d25023d2ed18cfaabfb2baa0f">XUsb_SetDeviceAddress</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a4d5a367719f199ad49b9020f0fdd22ab">XUsb_SetTestMode</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 TestMode, u8 *BufPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a1702a7ff1e0627217bdf4d4429a76f1c">XUsb_DmaReset</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#afef9f47c6f77fa2a6a59cde1e2db21b9">XUsb_DmaTransfer</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u32 *SrcAddr, u32 *DstAddr, u16 Length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#af1806727cc17345c2b9a900804e3b322">XUsb_ReadErrorCounters</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 *BitStuffErrors, u8 *PidErrors, u8 *CrcErrors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a9d1522d41344290899ebbf1a40824697">XUsb_UlpiPhyReadRegister</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 RegAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a5464e6b0871344e088f252872554b7bb">XUsb_UlpiPhyWriteRegister</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 RegAddr, u8 UlpiPhyRegData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8c.html#a59efbc6f5496ad21e48659c5a7090425">XUsb_SieReset</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="struct_x_usb.html">XUsb</a> driver. Functions in this file are the minimum required functions for this driver. See <a class="el" href="xusb_8h.html">xusb.h</a> for a detailed description of the driver.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None.</dd></dl>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- -----------------------------------------------------------------
 1.00a hvm  2/22/07 First release
 2.00a hvm  10/22/08 Added DMA APIs.
 3.00a hvm  12/3/09 Added XUsb_ReadErrorCounters API to return USB error
                     counters data. Updated to use HAL processor APIs.
		       XUsb_mReadReg is renamed to XUsb_ReadReg and
		       XUsb_mWriteReg is renamed to XUsb_WriteReg.
 3.02a hvm  7/15/10  Added Device ID initialization in XUsb_CfgInitialize
		       function (CR555996).
 4.00a hvm  10/21/10 Added ULPI PHY Read/Write APIs.
 			Added DMA handler initialization in XUsb_CfgInitialize
			function
 4.03a bss  06/20/10 Added SIE Reset API (XUsb_SieReset) to reset the SIE
 			state machine (CR 660602)
 </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a05f262f5c35f642fefc16b7912086265"></a><!-- doxytag: member="xusb.c::XUsb_CfgInitialize" ref="a05f262f5c35f642fefc16b7912086265" args="(XUsb *InstancePtr, XUsb_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb___config.html">XUsb_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes a <a class="el" href="struct_x_usb.html">XUsb</a> instance/driver.</p>
<p>The initialization entails:</p>
<ul>
<li>Initialize all members of the <a class="el" href="struct_x_usb.html">XUsb</a> structure.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance of the USB device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_usb___config.html">XUsb_Config</a> configuration structure. This structure will contain the requested configuration for the device. Typically, this is a local structure and the content of which will be copied into the configuration structure within <a class="el" href="struct_x_usb.html">XUsb</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS no errors occurred.</li>
<li>XST_FAILURE an error occurred during initialization.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After calling <a class="el" href="xusb_8c.html#a05f262f5c35f642fefc16b7912086265">XUsb_CfgInitialize()</a> the USB device IS NOT READY for use. Before the USB device can be used its parameters must be configured. See <a class="el" href="xusb_8h.html">xusb.h</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c50c0ee6d36d4b87a40018c2ad0fd25"></a><!-- doxytag: member="xusb.c::XUsb_ConfigureDevice" ref="a9c50c0ee6d36d4b87a40018c2ad0fd25" args="(XUsb *InstancePtr, XUsb_DeviceConfig *CfgPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_ConfigureDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb___device_config.html">XUsb_DeviceConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes USB End points.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is pointer to a <a class="el" href="struct_x_usb___config.html">XUsb_Config</a> configuration structure. This structure will contain the requested configuration for the device. Typically, this is a local structure and the content of which will be copied into the configuration structure within <a class="el" href="struct_x_usb.html">XUsb</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS no errors occurred.</li>
<li>XST_FAILURE an error occurred during initialization.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1702a7ff1e0627217bdf4d4429a76f1c"></a><!-- doxytag: member="xusb.c::XUsb_DmaReset" ref="a1702a7ff1e0627217bdf4d4429a76f1c" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_DmaReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the DMA module of the USB device</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After the DMA reset, only the DMA related logic part of the USB device will be reset and all the DMA related registers will be reset to the default values. Upon DMA Reset, any DMA transfer in progress will be stopped. </dd></dl>

</div>
</div>
<a class="anchor" id="afef9f47c6f77fa2a6a59cde1e2db21b9"></a><!-- doxytag: member="xusb.c::XUsb_DmaTransfer" ref="afef9f47c6f77fa2a6a59cde1e2db21b9" args="(XUsb *InstancePtr, u32 *SrcAddr, u32 *DstAddr, u16 Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_DmaTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the DMA registers with the given values to initiate a DMA data transfer. This function is called by the XUsb_EpDataSend and XUsb_EpDataRecv functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcAddr</em>&nbsp;</td><td>is the source address from where the data is to be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DstAddr</em>&nbsp;</td><td>is the destination address to where the data is to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is the amount of data that can be transferred. The maximum data transfer can be 1024.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function doesn't guarantee that the transfer is done successfully. This function only initiates the DMA transfer. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bfe41baf4bcdaae0da439ec758de24e"></a><!-- doxytag: member="xusb.c::XUsb_GetFrameNum" ref="a2bfe41baf4bcdaae0da439ec758de24e" args="(const XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XUsb_GetFrameNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the current frame number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current frame number..</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af1806727cc17345c2b9a900804e3b322"></a><!-- doxytag: member="xusb.c::XUsb_ReadErrorCounters" ref="af1806727cc17345c2b9a900804e3b322" args="(XUsb *InstancePtr, u8 *BitStuffErrors, u8 *PidErrors, u8 *CrcErrors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_ReadErrorCounters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BitStuffErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>PidErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>CrcErrors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the USB error counter regsiter and returns the error counters information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BitStuffErrors</em>&nbsp;</td><td>is a pointer to the 8 bit bitstuff error counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PidErrors</em>&nbsp;</td><td>is a pointer to the 8 bit pid error counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CrcErrors</em>&nbsp;</td><td>is a pointer to the 8 bit crc error counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2f7958d25023d2ed18cfaabfb2baa0f"></a><!-- doxytag: member="xusb.c::XUsb_SetDeviceAddress" ref="aa2f7958d25023d2ed18cfaabfb2baa0f" args="(XUsb *InstancePtr, u8 Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_SetDeviceAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the USB device address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the device address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Address set successfully.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d5a367719f199ad49b9020f0fdd22ab"></a><!-- doxytag: member="xusb.c::XUsb_SetTestMode" ref="a4d5a367719f199ad49b9020f0fdd22ab" args="(XUsb *InstancePtr, u8 TestMode, u8 *BufPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_SetTestMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TestMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BufPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the USB device into a given test mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TestMode</em>&nbsp;</td><td>is the type of test to be performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufPtr</em>&nbsp;</td><td>is a pointer to the buffer containing the test packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the test mode is Test packet(TEST_PKT), then user needs to pass the address of the buffer containing the test packet. In other cases, the BufPtr parameter is not used and the user can send a NULL or any value. BufPtr parameter should be 32 bit aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="a59efbc6f5496ad21e48659c5a7090425"></a><!-- doxytag: member="xusb.c::XUsb_SieReset" ref="a59efbc6f5496ad21e48659c5a7090425" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_SieReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the Serial Interface Engine</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After the SIE reset, only the SIE state machine logic part of the USB device will be reset and starts from Init state. </dd></dl>

</div>
</div>
<a class="anchor" id="a4708ca8b9ca477b58d7da7db3f1be308"></a><!-- doxytag: member="xusb.c::XUsb_Start" ref="a4708ca8b9ca477b58d7da7db3f1be308" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function starts the USB Device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a53f7e5c356dbe880560a6eb5942a74d6"></a><!-- doxytag: member="xusb.c::XUsb_Stop" ref="a53f7e5c356dbe880560a6eb5942a74d6" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function stops the USB device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d1522d41344290899ebbf1a40824697"></a><!-- doxytag: member="xusb.c::XUsb_UlpiPhyReadRegister" ref="a9d1522d41344290899ebbf1a40824697" args="(XUsb *InstancePtr, u8 RegAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XUsb_UlpiPhyReadRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates the USB ULPI PHY regsiter read transaction. This function returns the busy status if the earlier transaction is still in progress and returns the PHY register data upon successful read transaction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegAddr</em>&nbsp;</td><td>is the address of the PHY register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>Register data</li>
<li>XST_DEVICE_BUSY: The previous PHY transaction is still in progress.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function waits till the BUSY bit is cleared in the ULPI PHY resgiter and then reads the register. The user of this API should note that the PHY interrupt should be ignored during read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a5464e6b0871344e088f252872554b7bb"></a><!-- doxytag: member="xusb.c::XUsb_UlpiPhyWriteRegister" ref="a5464e6b0871344e088f252872554b7bb" args="(XUsb *InstancePtr, u8 RegAddr, u8 UlpiPhyRegData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_UlpiPhyWriteRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>UlpiPhyRegData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates the USB ULPI PHY regsiter write transaction. This function returns the busy status if the earlier transaction is still in progress and returns a success upon successful write transaction initiation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegAddr</em>&nbsp;</td><td>is the address of the PHY register. counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UlpiPhyRegData</em>&nbsp;</td><td>is the data to be written to PHY register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Read transaction initiated successfully.</li>
<li>XST_DEVICE_BUSY: The previous PHY transaction is still in progress.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
