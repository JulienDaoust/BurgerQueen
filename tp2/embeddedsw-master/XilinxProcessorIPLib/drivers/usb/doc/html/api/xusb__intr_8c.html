<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver usb v5_0: xusb_intr.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xusb_intr.c File Reference</h1><code>#include &quot;<a class="el" href="xusb_8h.html">xusb.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#afcd3e91e72783087a0c6902724b8087f">XUsb_IntrEnable</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#a6a9e88138c012fcfa32717eeaab1e5b1">XUsb_IntrDisable</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#acc119aa9f628ab0cc3fac2f63073e386">XUsb_IntrHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#ada7caf770f82936ab7493b67d143b9a9">XUsb_IntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#ae7fef0669e6d6094cc2af067195cc04d">XUsb_EpSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum, <a class="el" href="xusb_8h.html#aa06782e29c2a89b4fc4a248d1af9af44">XUsb_EpHandlerFunc</a> *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#aa2a8bba76c93470302e179d7c4d864ac">XUsb_ErrIntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#a6fbf5a1ddbca576e8c1e7d235da878ab">XUsb_DmaIntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb__intr_8c.html#a0573097a6ec999bac0f865dc18113df3">XUsb_UlpiIntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file contains the functions that are related to interrupt processing for the USB device.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---- ------------------------------------------------------------------
 1.00a hvm  2/22/07  First release.
 2.00a hvm  12/2/08  Updated the interrupt handler for handling the
			new DMA bits defined in the interrupt status register.
 3.00a hvm  12/3/09 Updated to use HAL processor APIs. Removed _m from the
   			Added the interrrupt handling for the error interrupts.
			Added new API XUsb_ErrIntrSetHandler for setting up
			error handler.
 3.01a hvm  5/20/10 Updated with fix for CR561171. The interrupt handler is
			updated to call the error handler callback function
 			during error interrupts.
 4.00a hvm  9/01/10 Added new API XUsb_DmaIntrSetHandler for setting up DMA
			handler. Updated the XUsb_IntrHandler function to call
			the DMA handler to handle DMA events. Removed the
			DmaDone and DmaError variable usage from the
			XUsb_IntrHandler function.
			Added interrupt handling for ULPI PHY interrupts.
 4.02a bss  3/04/12 Modified XCOMPONENT_IS_READY to XIL_COMPONENT_IS_READY
			CR 650877
 </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6fbf5a1ddbca576e8c1e7d235da878ab"></a><!-- doxytag: member="xusb_intr.c::XUsb_DmaIntrSetHandler" ref="a6fbf5a1ddbca576e8c1e7d235da878ab" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_DmaIntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the DMA events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7fef0669e6d6094cc2af067195cc04d"></a><!-- doxytag: member="xusb_intr.c::XUsb_EpSetHandler" ref="ae7fef0669e6d6094cc2af067195cc04d" args="(XUsb *InstancePtr, u8 EpNum, XUsb_EpHandlerFunc *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xusb_8h.html#aa06782e29c2a89b4fc4a248d1af9af44">XUsb_EpHandlerFunc</a> *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler for endpoint events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a Pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the Number of the endpoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. It can be NULL if the user wants to disable the handler entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked. This can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2a8bba76c93470302e179d7c4d864ac"></a><!-- doxytag: member="xusb_intr.c::XUsb_ErrIntrSetHandler" ref="aa2a8bba76c93470302e179d7c4d864ac" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_ErrIntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the error events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a9e88138c012fcfa32717eeaab1e5b1"></a><!-- doxytag: member="xusb_intr.c::XUsb_IntrDisable" ref="a6a9e88138c012fcfa32717eeaab1e5b1" args="(XUsb *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the specified interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be disabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XUSB_STATUS_*_MASK bits defined in <a class="el" href="xusb__l_8h.html">xusb_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afcd3e91e72783087a0c6902724b8087f"></a><!-- doxytag: member="xusb_intr.c::XUsb_IntrEnable" ref="afcd3e91e72783087a0c6902724b8087f" args="(XUsb *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XUSB_STATUS_*_MASK bits defined in <a class="el" href="xusb__l_8h.html">xusb_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="acc119aa9f628ab0cc3fac2f63073e386"></a><!-- doxytag: member="xusb_intr.c::XUsb_IntrHandler" ref="acc119aa9f628ab0cc3fac2f63073e386" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the USB driver. This function is the first-level interrupt handler for the USB core. All USB interrupts will be handled here. Depending on the type of the interrupt, second level interrupt handler may be called. Second level interrupt handlers will be registered by the user using the <a class="el" href="xusb_8h.html#ada7caf770f82936ab7493b67d143b9a9">XUsb_IntrSetHandler()</a> and/or <a class="el" href="xusb_8h.html#ae7fef0669e6d6094cc2af067195cc04d">XUsb_EpSetHandler()</a> functions.</p>
<p>This handler reads the interrupt status from the Interrupt Status Register, determines the source of the interrupts, calls the corresponding callbacks and finally clears the interrupts.</p>
<p>The interrupt from the USB driver has to be connected to the interrupt controller and the handler has to be registered with the interrupt system.</p>
<p>Applications using this driver are responsible for providing the callbacks to handle interrupts and installing the callbacks using XUsb_SetHandler() during the initialization phase.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance that just interrupted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No user handler is defined for the DMA interrupts. The DMA interrupt status is updated in the DMA status variables defined under the USB driver instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ada7caf770f82936ab7493b67d143b9a9"></a><!-- doxytag: member="xusb_intr.c::XUsb_IntrSetHandler" ref="ada7caf770f82936ab7493b67d143b9a9" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the general interrupt (interrupts other than the endpoint and error interrupts).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a0573097a6ec999bac0f865dc18113df3"></a><!-- doxytag: member="xusb_intr.c::XUsb_UlpiIntrSetHandler" ref="a0573097a6ec999bac0f865dc18113df3" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_UlpiIntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the ULPI PHY events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
