<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver usb v5_0: xusb.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xusb.h File Reference</h1><code>#include &quot;<a class="el" href="xusb__l_8h.html">xusb_l.h</a>&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb___ep_config.html">XUsb_EpConfig</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb___device_config.html">XUsb_DeviceConfig</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb___config.html">XUsb_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_usb.html">XUsb</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Endpoint Direction</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp8d23180980439b95dba271c3c900e675"></a> Definitions to be used with Endpoint related function that require a 'Direction' parameter.</p>
<p>NOTE: The direction is always defined from the perspective of the HOST! This means that an IN endpoint on the device is used for sending data while the OUT endpoint on the device is used for receiving data. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ac41572da2aded6fe09ee6b423ddbd50a">XUSB_EP_DIRECTION_IN</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aaeed667f160bf00cc1e548a254fc45a3">XUSB_EP_DIRECTION_OUT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Speed</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp44877c6aa8e93fa5a91c9361211464fb"></a> Definitions to be used with speed. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#af18783c0d53b254b23bee3714df0c7b4">XUSB_EP_HIGH_SPEED</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a770274afcbbb1224ab5eec3a84a19acf">XUSB_EP_FULL_SPEED</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td colspan="2"><div class="groupHeader">USB device specific global configuration constants.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpdba181561324981ef98cf8e4cc59d1ea"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ac10c01aa71b29e898218eb4ffb61bea5">XUSB_MAX_ENDPOINTS</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aaa89db45cc42f7d9fb543921c6b023cf">XUSB_EP_NUMBER_ZERO</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a0ed00313b551842b1ba4bd28f2e446dd">XUSB_DEVICEADDR_MAX</a>&nbsp;&nbsp;&nbsp;127</td></tr>
<tr><td colspan="2"><div class="groupHeader">USB device disconnect state</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd66d46c38734b354d5877ad25b5576d7"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aa04141505aefe8349756ab664507892c">XUSB_DISCONNECTED</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ac5aabd610647e476facc6e8e9507f22c">XUSB_RESET</a>&nbsp;&nbsp;&nbsp;0x0</td></tr>
<tr><td colspan="2"><div class="groupHeader">Test Modes (Set Feature)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp1f0b74e7f1112a4ca9b24db949b48b61"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ab9387baa67fbacb67dc4bb8fb5099946">TEST_J</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aaab96404e28a24eeb6b35728f5252e84">TEST_K</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a2e9ef4860669530c69535fe849aa2731">TEST_SE0_NAK</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a793a5e7847d812a5e5de810db648b35a">TEST_PKT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aa06782e29c2a89b4fc4a248d1af9af44">XUsb_EpHandlerFunc</a> )(void *CallBackRef, u8 EpNum, u32 EventType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a66cf5b764672918ddaf3346b9cb15514">XUsb_IntrHandlerFunc</a> )(void *CallBackRef, u32 InterruptType)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a05f262f5c35f642fefc16b7912086265">XUsb_CfgInitialize</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, <a class="el" href="struct_x_usb___config.html">XUsb_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a9c50c0ee6d36d4b87a40018c2ad0fd25">XUsb_ConfigureDevice</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, <a class="el" href="struct_x_usb___device_config.html">XUsb_DeviceConfig</a> *CfgPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a4708ca8b9ca477b58d7da7db3f1be308">XUsb_Start</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a53f7e5c356dbe880560a6eb5942a74d6">XUsb_Stop</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a2bfe41baf4bcdaae0da439ec758de24e">XUsb_GetFrameNum</a> (const <a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aa2f7958d25023d2ed18cfaabfb2baa0f">XUsb_SetDeviceAddress</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a4d5a367719f199ad49b9020f0fdd22ab">XUsb_SetTestMode</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 TestMode, u8 *BufPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a1702a7ff1e0627217bdf4d4429a76f1c">XUsb_DmaReset</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#afef9f47c6f77fa2a6a59cde1e2db21b9">XUsb_DmaTransfer</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u32 *SrcAddr, u32 *DstAddr, u16 Length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#af1806727cc17345c2b9a900804e3b322">XUsb_ReadErrorCounters</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 *BitStuffErrors, u8 *PidErrors, u8 *CrcErrors)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a9d1522d41344290899ebbf1a40824697">XUsb_UlpiPhyReadRegister</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 RegAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a5464e6b0871344e088f252872554b7bb">XUsb_UlpiPhyWriteRegister</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 RegAddr, u8 UlpiPhyRegData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a59efbc6f5496ad21e48659c5a7090425">XUsb_SieReset</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#adc3661c9581f9dea4b01873cbaff31a8">XUsb_EpEnable</a> (const <a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a82e240bb1af0cc302cd2c8b7363161d8">XUsb_EpDisable</a> (const <a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a265f540fba1a12b0e310052d4cfa5a2d">XUsb_EpConfigure</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum, <a class="el" href="struct_x_usb___ep_config.html">XUsb_EpConfig</a> *EpCfgPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#abf09f948bc604c279cb0a12bba14057b">XUsb_EpDataSend</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum, u8 *BufferPtr, u32 BufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a143b99da38f8de7e4d0f5cee108fc797">XUsb_EpDataRecv</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum, u8 *BufferPtr, u32 BufferLen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ab38009aad2e0011e0bd392f064edeec7">XUsb_EpStall</a> (const <a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a30a3f5338e5938d9efc1e843c38e9d78">XUsb_EpUnstall</a> (const <a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a8af69babadc9c361e05afca4e350b918">XUsb_EpIsoTransferConfigure</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum, u8 NoOfTransfers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a2fd2df5a3cb63b2e1464a8362a743d3f">XUsb_IntrEnable</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u32 IntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ace4c1e20e3cbb5ed7a355c0ec48b9913">XUsb_IntrDisable</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u32 IntrMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#acc119aa9f628ab0cc3fac2f63073e386">XUsb_IntrHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ada7caf770f82936ab7493b67d143b9a9">XUsb_IntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#ae7fef0669e6d6094cc2af067195cc04d">XUsb_EpSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, u8 EpNum, <a class="el" href="xusb_8h.html#aa06782e29c2a89b4fc4a248d1af9af44">XUsb_EpHandlerFunc</a> *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#aa2a8bba76c93470302e179d7c4d864ac">XUsb_ErrIntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a6fbf5a1ddbca576e8c1e7d235da878ab">XUsb_DmaIntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a0573097a6ec999bac0f865dc18113df3">XUsb_UlpiIntrSetHandler</a> (<a class="el" href="struct_x_usb.html">XUsb</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_usb___config.html">XUsb_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xusb_8h.html#a9d684fb058664dc90720ea41cd59d6b0">XUsb_LookupConfig</a> (u16 DeviceId)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab9387baa67fbacb67dc4bb8fb5099946"></a><!-- doxytag: member="xusb.h::TEST_J" ref="ab9387baa67fbacb67dc4bb8fb5099946" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_J&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Chirp J Test </p>

</div>
</div>
<a class="anchor" id="aaab96404e28a24eeb6b35728f5252e84"></a><!-- doxytag: member="xusb.h::TEST_K" ref="aaab96404e28a24eeb6b35728f5252e84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_K&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Chirp K Test </p>

</div>
</div>
<a class="anchor" id="a793a5e7847d812a5e5de810db648b35a"></a><!-- doxytag: member="xusb.h::TEST_PKT" ref="a793a5e7847d812a5e5de810db648b35a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_PKT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Packet Test </p>

</div>
</div>
<a class="anchor" id="a2e9ef4860669530c69535fe849aa2731"></a><!-- doxytag: member="xusb.h::TEST_SE0_NAK" ref="a2e9ef4860669530c69535fe849aa2731" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEST_SE0_NAK&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Chirp SE0 Test </p>

</div>
</div>
<a class="anchor" id="a0ed00313b551842b1ba4bd28f2e446dd"></a><!-- doxytag: member="xusb.h::XUSB_DEVICEADDR_MAX" ref="a0ed00313b551842b1ba4bd28f2e446dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_DEVICEADDR_MAX&nbsp;&nbsp;&nbsp;127</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Max device address </p>

</div>
</div>
<a class="anchor" id="aa04141505aefe8349756ab664507892c"></a><!-- doxytag: member="xusb.h::XUSB_DISCONNECTED" ref="aa04141505aefe8349756ab664507892c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_DISCONNECTED&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disconnected state </p>

</div>
</div>
<a class="anchor" id="ac41572da2aded6fe09ee6b423ddbd50a"></a><!-- doxytag: member="xusb.h::XUSB_EP_DIRECTION_IN" ref="ac41572da2aded6fe09ee6b423ddbd50a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_EP_DIRECTION_IN&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint direction IN. </p>

</div>
</div>
<a class="anchor" id="aaeed667f160bf00cc1e548a254fc45a3"></a><!-- doxytag: member="xusb.h::XUSB_EP_DIRECTION_OUT" ref="aaeed667f160bf00cc1e548a254fc45a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_EP_DIRECTION_OUT&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Endpoint direction OUT. </p>

</div>
</div>
<a class="anchor" id="a770274afcbbb1224ab5eec3a84a19acf"></a><!-- doxytag: member="xusb.h::XUSB_EP_FULL_SPEED" ref="a770274afcbbb1224ab5eec3a84a19acf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_EP_FULL_SPEED&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Full Speed </p>

</div>
</div>
<a class="anchor" id="af18783c0d53b254b23bee3714df0c7b4"></a><!-- doxytag: member="xusb.h::XUSB_EP_HIGH_SPEED" ref="af18783c0d53b254b23bee3714df0c7b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_EP_HIGH_SPEED&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>High Speed </p>

</div>
</div>
<a class="anchor" id="aaa89db45cc42f7d9fb543921c6b023cf"></a><!-- doxytag: member="xusb.h::XUSB_EP_NUMBER_ZERO" ref="aaa89db45cc42f7d9fb543921c6b023cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_EP_NUMBER_ZERO&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>End point Zero </p>

</div>
</div>
<a class="anchor" id="ac10c01aa71b29e898218eb4ffb61bea5"></a><!-- doxytag: member="xusb.h::XUSB_MAX_ENDPOINTS" ref="ac10c01aa71b29e898218eb4ffb61bea5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_MAX_ENDPOINTS&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum End Points </p>

</div>
</div>
<a class="anchor" id="ac5aabd610647e476facc6e8e9507f22c"></a><!-- doxytag: member="xusb.h::XUSB_RESET" ref="ac5aabd610647e476facc6e8e9507f22c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XUSB_RESET&nbsp;&nbsp;&nbsp;0x0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset State </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa06782e29c2a89b4fc4a248d1af9af44"></a><!-- doxytag: member="xusb.h::XUsb_EpHandlerFunc" ref="aa06782e29c2a89b4fc4a248d1af9af44" args=")(void *CallBackRef, u8 EpNum, u32 EventType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xusb_8h.html#aa06782e29c2a89b4fc4a248d1af9af44">XUsb_EpHandlerFunc</a>)(void *CallBackRef, u8 EpNum, u32 EventType)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This data type defines the callback function to be used for Endpoint handlers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the Callback reference passed in by the upper layer when setting the handler, and is passed back to the upper layer when the handler is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint that caused the event. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EventType</em>&nbsp;</td><td>is the type of the event that occurred on that endpoint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a66cf5b764672918ddaf3346b9cb15514"></a><!-- doxytag: member="xusb.h::XUsb_IntrHandlerFunc" ref="a66cf5b764672918ddaf3346b9cb15514" args=")(void *CallBackRef, u32 InterruptType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xusb_8h.html#a66cf5b764672918ddaf3346b9cb15514">XUsb_IntrHandlerFunc</a>)(void *CallBackRef, u32 InterruptType)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This data type defines the callback function to be used for the general interrupt handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the Callback reference passed in by the upper layer when setting the handler, and is passed back to the upper layer when the handler is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptType</em>&nbsp;</td><td>is the type of the event that caused the interrupt. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a05f262f5c35f642fefc16b7912086265"></a><!-- doxytag: member="xusb.h::XUsb_CfgInitialize" ref="a05f262f5c35f642fefc16b7912086265" args="(XUsb *InstancePtr, XUsb_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb___config.html">XUsb_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Setup / Initialize and DMA functions</p>
<p>Implemented in the file <a class="el" href="xusb_8c.html">xusb.c</a></p>
<p>This function initializes a <a class="el" href="struct_x_usb.html">XUsb</a> instance/driver.</p>
<p>The initialization entails:</p>
<ul>
<li>Initialize all members of the <a class="el" href="struct_x_usb.html">XUsb</a> structure.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance of the USB device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_usb___config.html">XUsb_Config</a> configuration structure. This structure will contain the requested configuration for the device. Typically, this is a local structure and the content of which will be copied into the configuration structure within <a class="el" href="struct_x_usb.html">XUsb</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS no errors occurred.</li>
<li>XST_FAILURE an error occurred during initialization.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After calling <a class="el" href="xusb_8c.html#a05f262f5c35f642fefc16b7912086265">XUsb_CfgInitialize()</a> the USB device IS NOT READY for use. Before the USB device can be used its parameters must be configured. See <a class="el" href="xusb_8h.html">xusb.h</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="a9c50c0ee6d36d4b87a40018c2ad0fd25"></a><!-- doxytag: member="xusb.h::XUsb_ConfigureDevice" ref="a9c50c0ee6d36d4b87a40018c2ad0fd25" args="(XUsb *InstancePtr, XUsb_DeviceConfig *CfgPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_ConfigureDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb___device_config.html">XUsb_DeviceConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initializes USB End points.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>is pointer to a <a class="el" href="struct_x_usb___config.html">XUsb_Config</a> configuration structure. This structure will contain the requested configuration for the device. Typically, this is a local structure and the content of which will be copied into the configuration structure within <a class="el" href="struct_x_usb.html">XUsb</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS no errors occurred.</li>
<li>XST_FAILURE an error occurred during initialization.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fbf5a1ddbca576e8c1e7d235da878ab"></a><!-- doxytag: member="xusb.h::XUsb_DmaIntrSetHandler" ref="a6fbf5a1ddbca576e8c1e7d235da878ab" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_DmaIntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the DMA events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a1702a7ff1e0627217bdf4d4429a76f1c"></a><!-- doxytag: member="xusb.h::XUsb_DmaReset" ref="a1702a7ff1e0627217bdf4d4429a76f1c" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_DmaReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the DMA module of the USB device</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After the DMA reset, only the DMA related logic part of the USB device will be reset and all the DMA related registers will be reset to the default values. Upon DMA Reset, any DMA transfer in progress will be stopped. </dd></dl>

</div>
</div>
<a class="anchor" id="afef9f47c6f77fa2a6a59cde1e2db21b9"></a><!-- doxytag: member="xusb.h::XUsb_DmaTransfer" ref="afef9f47c6f77fa2a6a59cde1e2db21b9" args="(XUsb *InstancePtr, u32 *SrcAddr, u32 *DstAddr, u16 Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_DmaTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>SrcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>DstAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the DMA registers with the given values to initiate a DMA data transfer. This function is called by the XUsb_EpDataSend and XUsb_EpDataRecv functions.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcAddr</em>&nbsp;</td><td>is the source address from where the data is to be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DstAddr</em>&nbsp;</td><td>is the destination address to where the data is to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>is the amount of data that can be transferred. The maximum data transfer can be 1024.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function doesn't guarantee that the transfer is done successfully. This function only initiates the DMA transfer. </dd></dl>

</div>
</div>
<a class="anchor" id="a265f540fba1a12b0e310052d4cfa5a2d"></a><!-- doxytag: member="xusb.h::XUsb_EpConfigure" ref="a265f540fba1a12b0e310052d4cfa5a2d" args="(XUsb *InstancePtr, u8 EpNum, XUsb_EpConfig *EpCfgPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_usb___ep_config.html">XUsb_EpConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>EpCfgPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function configures a specific end point with the given configuration data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number which has to be configured. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpCfgPtr</em>&nbsp;</td><td>is a pointer to the endpoint configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a143b99da38f8de7e4d0f5cee108fc797"></a><!-- doxytag: member="xusb.h::XUsb_EpDataRecv" ref="a143b99da38f8de7e4d0f5cee108fc797" args="(XUsb *InstancePtr, u8 EpNum, u8 *BufferPtr, u32 BufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_EpDataRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the received data from end point buffer to the buffer passed and then makes the device ready for receiving data again into the same end point buffer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is a pointer to buffer where data is to be copied. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLen</em>&nbsp;</td><td>is the number of data bytes to be received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if there is no received data in any of the ping pong buffers.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="abf09f948bc604c279cb0a12bba14057b"></a><!-- doxytag: member="xusb.h::XUsb_EpDataSend" ref="abf09f948bc604c279cb0a12bba14057b" args="(XUsb *InstancePtr, u8 EpNum, u8 *BufferPtr, u32 BufferLen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_EpDataSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BufferLen</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function copies the transmit data to the end point buffer and enables the buffer for transmission.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferPtr</em>&nbsp;</td><td>is a pointer to buffer containing the data to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufferLen</em>&nbsp;</td><td>is the number of data bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_FAILURE if the send operation could not be performed due to non availability of the ping pong buffers in the DPRAM.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Success doesn't imply that the data is actually transmitted, it only confirms that the DPRAM buffer is updated with send data and the core is enabled for transmitting the data. </dd></dl>

</div>
</div>
<a class="anchor" id="a82e240bb1af0cc302cd2c8b7363161d8"></a><!-- doxytag: member="xusb.h::XUsb_EpDisable" ref="a82e240bb1af0cc302cd2c8b7363161d8" args="(const XUsb *InstancePtr, u8 EpNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpDisable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the specified endpoint for all operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number which has to be disabled for operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adc3661c9581f9dea4b01873cbaff31a8"></a><!-- doxytag: member="xusb.h::XUsb_EpEnable" ref="adc3661c9581f9dea4b01873cbaff31a8" args="(const XUsb *InstancePtr, u8 EpNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpEnable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified endpoint for all operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number which has to be enabled for operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8af69babadc9c361e05afca4e350b918"></a><!-- doxytag: member="xusb.h::XUsb_EpIsoTransferConfigure" ref="a8af69babadc9c361e05afca4e350b918" args="(XUsb *InstancePtr, u8 EpNum, u8 NoOfTransfers)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpIsoTransferConfigure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>NoOfTransfers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the number of isochronous transfers in a microframe for a given endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoOfTransfers</em>&nbsp;</td><td>is the number of transfers in a microframe.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The values allowed for number of transfers is 1, 2 and 3. This function should be called after all the endpoints are configured. The allowed value for EpNum is 1 to 7 </dd></dl>

</div>
</div>
<a class="anchor" id="ae7fef0669e6d6094cc2af067195cc04d"></a><!-- doxytag: member="xusb.h::XUsb_EpSetHandler" ref="ae7fef0669e6d6094cc2af067195cc04d" args="(XUsb *InstancePtr, u8 EpNum, XUsb_EpHandlerFunc *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xusb_8h.html#aa06782e29c2a89b4fc4a248d1af9af44">XUsb_EpHandlerFunc</a> *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the handler for endpoint events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a Pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the Number of the endpoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. It can be NULL if the user wants to disable the handler entry. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked. This can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ab38009aad2e0011e0bd392f064edeec7"></a><!-- doxytag: member="xusb.h::XUsb_EpStall" ref="ab38009aad2e0011e0bd392f064edeec7" args="(const XUsb *InstancePtr, u8 EpNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpStall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function stalls operations for the specified endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number which has to be stalled for operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function does not guaranty the Stall operation, it only sets the Stall bit in the Endpoint configuration register. </dd></dl>

</div>
</div>
<a class="anchor" id="a30a3f5338e5938d9efc1e843c38e9d78"></a><!-- doxytag: member="xusb.h::XUsb_EpUnstall" ref="a30a3f5338e5938d9efc1e843c38e9d78" args="(const XUsb *InstancePtr, u8 EpNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_EpUnstall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>EpNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function unstalls operations for the specified endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EpNum</em>&nbsp;</td><td>is the endpoint number for which the unstall operations are to be carried out.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function does not guaranty the Stall operation, it only sets the Stall bit in the Endpoint configuration register. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2a8bba76c93470302e179d7c4d864ac"></a><!-- doxytag: member="xusb.h::XUsb_ErrIntrSetHandler" ref="aa2a8bba76c93470302e179d7c4d864ac" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_ErrIntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the error events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bfe41baf4bcdaae0da439ec758de24e"></a><!-- doxytag: member="xusb.h::XUsb_GetFrameNum" ref="a2bfe41baf4bcdaae0da439ec758de24e" args="(const XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XUsb_GetFrameNum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the current frame number.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current frame number..</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ace4c1e20e3cbb5ed7a355c0ec48b9913"></a><!-- doxytag: member="xusb.h::XUsb_IntrDisable" ref="ace4c1e20e3cbb5ed7a355c0ec48b9913" args="(XUsb *InstancePtr, u32 IntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the specified interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be disabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XUSB_STATUS_*_MASK bits defined in <a class="el" href="xusb__l_8h.html">xusb_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2fd2df5a3cb63b2e1464a8362a743d3f"></a><!-- doxytag: member="xusb.h::XUsb_IntrEnable" ref="a2fd2df5a3cb63b2e1464a8362a743d3f" args="(XUsb *InstancePtr, u32 IntrMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XUSB_STATUS_*_MASK bits defined in <a class="el" href="xusb__l_8h.html">xusb_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="acc119aa9f628ab0cc3fac2f63073e386"></a><!-- doxytag: member="xusb.h::XUsb_IntrHandler" ref="acc119aa9f628ab0cc3fac2f63073e386" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the USB driver. This function is the first-level interrupt handler for the USB core. All USB interrupts will be handled here. Depending on the type of the interrupt, second level interrupt handler may be called. Second level interrupt handlers will be registered by the user using the <a class="el" href="xusb_8h.html#ada7caf770f82936ab7493b67d143b9a9">XUsb_IntrSetHandler()</a> and/or <a class="el" href="xusb_8h.html#ae7fef0669e6d6094cc2af067195cc04d">XUsb_EpSetHandler()</a> functions.</p>
<p>This handler reads the interrupt status from the Interrupt Status Register, determines the source of the interrupts, calls the corresponding callbacks and finally clears the interrupts.</p>
<p>The interrupt from the USB driver has to be connected to the interrupt controller and the handler has to be registered with the interrupt system.</p>
<p>Applications using this driver are responsible for providing the callbacks to handle interrupts and installing the callbacks using XUsb_SetHandler() during the initialization phase.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance that just interrupted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>No user handler is defined for the DMA interrupts. The DMA interrupt status is updated in the DMA status variables defined under the USB driver instance. </dd></dl>

</div>
</div>
<a class="anchor" id="ada7caf770f82936ab7493b67d143b9a9"></a><!-- doxytag: member="xusb.h::XUsb_IntrSetHandler" ref="ada7caf770f82936ab7493b67d143b9a9" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_IntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the general interrupt (interrupts other than the endpoint and error interrupts).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d684fb058664dc90720ea41cd59d6b0"></a><!-- doxytag: member="xusb.h::XUsb_LookupConfig" ref="a9d684fb058664dc90720ea41cd59d6b0" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_usb___config.html">XUsb_Config</a>* XUsb_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>contains the ID of the device for which the device configuration pointer is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>A pointer to the configuration found.</li>
<li>NULL if the specified device ID was not found. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="af1806727cc17345c2b9a900804e3b322"></a><!-- doxytag: member="xusb.h::XUsb_ReadErrorCounters" ref="af1806727cc17345c2b9a900804e3b322" args="(XUsb *InstancePtr, u8 *BitStuffErrors, u8 *PidErrors, u8 *CrcErrors)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_ReadErrorCounters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BitStuffErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>PidErrors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>CrcErrors</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the USB error counter regsiter and returns the error counters information.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BitStuffErrors</em>&nbsp;</td><td>is a pointer to the 8 bit bitstuff error counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PidErrors</em>&nbsp;</td><td>is a pointer to the 8 bit pid error counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CrcErrors</em>&nbsp;</td><td>is a pointer to the 8 bit crc error counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2f7958d25023d2ed18cfaabfb2baa0f"></a><!-- doxytag: member="xusb.h::XUsb_SetDeviceAddress" ref="aa2f7958d25023d2ed18cfaabfb2baa0f" args="(XUsb *InstancePtr, u8 Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_SetDeviceAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the USB device address.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the device address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Address set successfully.</li>
<li>XST_INVALID_PARAM: Invalid parameter passed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d5a367719f199ad49b9020f0fdd22ab"></a><!-- doxytag: member="xusb.h::XUsb_SetTestMode" ref="a4d5a367719f199ad49b9020f0fdd22ab" args="(XUsb *InstancePtr, u8 TestMode, u8 *BufPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_SetTestMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TestMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>BufPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the USB device into a given test mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TestMode</em>&nbsp;</td><td>is the type of test to be performed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BufPtr</em>&nbsp;</td><td>is a pointer to the buffer containing the test packet.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If the test mode is Test packet(TEST_PKT), then user needs to pass the address of the buffer containing the test packet. In other cases, the BufPtr parameter is not used and the user can send a NULL or any value. BufPtr parameter should be 32 bit aligned. </dd></dl>

</div>
</div>
<a class="anchor" id="a59efbc6f5496ad21e48659c5a7090425"></a><!-- doxytag: member="xusb.h::XUsb_SieReset" ref="a59efbc6f5496ad21e48659c5a7090425" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_SieReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the Serial Interface Engine</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>After the SIE reset, only the SIE state machine logic part of the USB device will be reset and starts from Init state. </dd></dl>

</div>
</div>
<a class="anchor" id="a4708ca8b9ca477b58d7da7db3f1be308"></a><!-- doxytag: member="xusb.h::XUsb_Start" ref="a4708ca8b9ca477b58d7da7db3f1be308" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function starts the USB Device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a53f7e5c356dbe880560a6eb5942a74d6"></a><!-- doxytag: member="xusb.h::XUsb_Stop" ref="a53f7e5c356dbe880560a6eb5942a74d6" args="(XUsb *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function stops the USB device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0573097a6ec999bac0f865dc18113df3"></a><!-- doxytag: member="xusb.h::XUsb_UlpiIntrSetHandler" ref="a0573097a6ec999bac0f865dc18113df3" args="(XUsb *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XUsb_UlpiIntrSetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function installs an asynchronous callback function for the ULPI PHY events.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. The user can disable a handler by setting the callback function pointer to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d1522d41344290899ebbf1a40824697"></a><!-- doxytag: member="xusb.h::XUsb_UlpiPhyReadRegister" ref="a9d1522d41344290899ebbf1a40824697" args="(XUsb *InstancePtr, u8 RegAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XUsb_UlpiPhyReadRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates the USB ULPI PHY regsiter read transaction. This function returns the busy status if the earlier transaction is still in progress and returns the PHY register data upon successful read transaction.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegAddr</em>&nbsp;</td><td>is the address of the PHY register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>Register data</li>
<li>XST_DEVICE_BUSY: The previous PHY transaction is still in progress.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function waits till the BUSY bit is cleared in the ULPI PHY resgiter and then reads the register. The user of this API should note that the PHY interrupt should be ignored during read operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a5464e6b0871344e088f252872554b7bb"></a><!-- doxytag: member="xusb.h::XUsb_UlpiPhyWriteRegister" ref="a5464e6b0871344e088f252872554b7bb" args="(XUsb *InstancePtr, u8 RegAddr, u8 UlpiPhyRegData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XUsb_UlpiPhyWriteRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_usb.html">XUsb</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>RegAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>UlpiPhyRegData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates the USB ULPI PHY regsiter write transaction. This function returns the busy status if the earlier transaction is still in progress and returns a success upon successful write transaction initiation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_usb.html">XUsb</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RegAddr</em>&nbsp;</td><td>is the address of the PHY register. counter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UlpiPhyRegData</em>&nbsp;</td><td>is the data to be written to PHY register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS: Read transaction initiated successfully.</li>
<li>XST_DEVICE_BUSY: The previous PHY transaction is still in progress.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
