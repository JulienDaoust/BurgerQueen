<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xdp.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xdp.h File Reference</h1>
<p>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;xil_types.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xdp__hw_8h.html">xdp_hw.h</a>&quot;</code><br>
<code>#include &quot;xstatus.h&quot;</code><br>
<code>#include &quot;xvidc.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___config.html">XDp_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_sink_config.html">XDp_TxSinkConfig</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_link_config.html">XDp_TxLinkConfig</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_main_stream_attributes.html">XDp_TxMainStreamAttributes</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_mst_stream.html">XDp_TxMstStream</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_board_char.html">XDp_TxBoardChar</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_topology_node.html">XDp_TxTopologyNode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_topology.html">XDp_TxTopology</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_sb_msg_link_address_reply_port_detail.html">XDp_TxSbMsgLinkAddressReplyPortDetail</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx_sb_msg_link_address_reply_device_info.html">XDp_TxSbMsgLinkAddressReplyDeviceInfo</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___rx_link_config.html">XDp_RxLinkConfig</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___tx.html">XDp_Tx</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp___rx.html">XDp_Rx</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_dp.html">XDp</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#a3afd37e5bb042c2a75443eaadb79998">XDp_GetCoreType</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#271f1b2a20ca364ec0ce08ec1c7550ad">XDptx_ReadReg</a>&nbsp;&nbsp;&nbsp;XDp_ReadReg</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#375c994e4be673c637c6f7763eb7043a">XDprx_ReadReg</a>&nbsp;&nbsp;&nbsp;XDp_ReadReg</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#7861fa71b501cb8e0652983bac2d1667">XDptx_WriteReg</a>&nbsp;&nbsp;&nbsp;XDp_WriteReg</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#09aeb13773c5d98a00cf657547297240">XDprx_WriteReg</a>&nbsp;&nbsp;&nbsp;XDp_WriteReg</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#01f87635ba8bf944420ecff70e6dad60">XDptx_Config</a>&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp___config.html">XDp_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#e8525af82086937c660af869240cad2f">XDprx_Config</a>&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp___config.html">XDp_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#14b9a1405b0f7dbb10e18ba7599994d9">XDptx_TimerHandler</a>&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2593f251dc247b3b3cb67fefa69c4eb0">XDprx_TimerHandler</a>&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#847e15772e8e242680800a66c8403ff5">XDptx_HpdEventHandler</a>&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#6bd70ff9dfd00e77eb9c3b3809dc0a51">XDptx_HpdPulseHandler</a>&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5f6d6322ccdd30a72ed1bff992c826c7">XDprx_IntrHandler</a>&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#76abcc25167c863fc908d209bd9ad16b">XDptx_LookupConfig</a>&nbsp;&nbsp;&nbsp;XDp_LookupConfig</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#3a32f20893940e1f21e314c83a86b1b0">XDprx_LookupConfig</a>&nbsp;&nbsp;&nbsp;XDp_LookupConfig</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#8db3f1c5c6050e8394fd5c179b0d7a5a">XDptx_CfgInitialize</a>&nbsp;&nbsp;&nbsp;XDp_CfgInitialize</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5ca5e5f9ed2ebcfe07da8b07b1aa30f9">XDprx_CfgInitialize</a>&nbsp;&nbsp;&nbsp;XDp_CfgInitialize</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#ab525d035beadef1156aaecdf675e531">XDptx_InitializeTx</a>&nbsp;&nbsp;&nbsp;XDp_Initialize</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#518ed8abb17284e34c24c41f97e929d4">XDprx_InitializeRx</a>&nbsp;&nbsp;&nbsp;XDp_Initialize</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#abdd05fa8bf9325be958b54074bd02ea">XDptx_WaitUs</a>&nbsp;&nbsp;&nbsp;XDp_WaitUs</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5b5593bdaa9747d153e56b50148a7136">XDprx_WaitUs</a>&nbsp;&nbsp;&nbsp;XDp_WaitUs</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#9edc7662e22b23761a4ae787628ea424">XDptx_SetUserTimerHandler</a>&nbsp;&nbsp;&nbsp;XDp_SetUserTimerHandler</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#555d7e44834dcb7a7dc6638439057b28">XDprx_SetUserTimerHandler</a>&nbsp;&nbsp;&nbsp;XDp_SetUserTimerHandler</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#7e91ffab1f59aab90b0c5ad9c368ca23">XDptx_SelfTest</a>&nbsp;&nbsp;&nbsp;XDp_SelfTest</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#019e21f29e885a55b217e2ffb1542e57">XDprx_SelfTest</a>&nbsp;&nbsp;&nbsp;XDp_SelfTest</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5b4593582f4316691a04e764217a6a07">XDptx_HpdInterruptHandler</a>&nbsp;&nbsp;&nbsp;XDp_InterruptHandler</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#294684facc13f2158e58572553791120">XDprx_InterruptHandler</a>&nbsp;&nbsp;&nbsp;XDp_InterruptHandler</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#289da1dbb40e62ada891039e5d68c507">XDptx</a>&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp.html">XDp</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4c30366156ec8f2c6c8b6829733b3af0">XDprx</a>&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp.html">XDp</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#fbcf5cb1cdded0579fc927fae6511c36">XDPTX</a>&nbsp;&nbsp;&nbsp;XDP_TX</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#343c4e8772e00e2754382e8a04bcedf7">XDPRX</a>&nbsp;&nbsp;&nbsp;XDP_RX</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a> (void *InstancePtr, u32 MicroSeconds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> (void *InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#8d85f6071200723596c18f46ce9ef438">XDp_CoreType</a> { <a class="el" href="xdp_8h.html#8d85f6071200723596c18f46ce9ef4382660d3d871232c9a9d8e18867f6ac31b">XDP_TX</a> =  0,
<a class="el" href="xdp_8h.html#8d85f6071200723596c18f46ce9ef438af80f7b90e40284ace23dd7dd3b1b567">XDP_RX</a>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_dp___config.html">XDp_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#46c2b674f7a6e6e71016577cc975f00b">XDp_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#cfec4779f9319bc515e77088923eb05e">XDp_CfgInitialize</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="struct_x_dp___config.html">XDp_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#85f185599e63935fa41e46ca249d4a3a">XDp_Initialize</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#831242817739efb8ec76f65b317b00c7">XDp_TxGetRxCapabilities</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f68236955b8b3a6292a9b9cc357ec1fa">XDp_TxCfgMainLinkMax</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#04b03753ee278bdac3e2262b99366493">XDp_TxEstablishLink</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#a50e8ec50a21bb3df5d1125ebe95493d">XDp_TxCheckLinkStatus</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5a07f4cc7ae9d45915497ed53d288061">XDp_TxEnableTrainAdaptive</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f3915b9c29ed8a077adaed36e04622b4">XDp_TxSetHasRedriverInPath</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Set)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#56904fc019dd1c8bc629b601ae5b5eba">XDp_TxCfgTxVsOffset</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Offset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#3633e0db29e804a6f3da321613e3539d">XDp_TxCfgTxVsLevel</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Level, u8 TxLevel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#90b6e9474941dd1dee7eebb4f9ba57ca">XDp_TxCfgTxPeLevel</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Level, u8 TxLevel)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#326335c87939629db5364c21c7e81a45">XDp_TxAuxRead</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u32 DpcdAddress, u32 BytesToRead, void *ReadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#cec5ef6d6656c0c2ae17761172acf6c1">XDp_TxAuxWrite</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u32 DpcdAddress, u32 BytesToWrite, void *WriteData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#c0b819f21d763400b8f9c2cc150e060f">XDp_TxIicRead</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 IicAddress, u16 Offset, u16 BytesToRead, void *ReadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#6cbeb74d7664817db482923e4dc1683c">XDp_TxIicWrite</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 IicAddress, u8 BytesToWrite, void *WriteData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#63402c58ed10a4c59aa0757970351fbe">XDp_TxSetDownspread</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#266286fa19c4e031a7de23fab583ba4f">XDp_TxSetEnhancedFrameMode</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2eee185e6b432dda6a7ab410b5e78541">XDp_TxSetLaneCount</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#e01933583cbbbe16c3582d7440f10a2e">XDp_TxSetLinkRate</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkRate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#60da59209c30be099d00f0053a0e809d">XDp_TxSetScrambler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#7e31cad17809d5e67bade4c08a4b6c93">XDp_SetUserTimerHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#82deff65c3a8f1a090bcda332df3a7ee">XDp_WaitUs</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u32 MicroSeconds)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#3305ff3687d4c994d2200ad861828295">XDp_TxIsConnected</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#400f2bfe7aa6c820e915afd0fb685779">XDp_TxEnableMainLink</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2ebce10cc5382091395edb1e106f4ad1">XDp_TxDisableMainLink</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#89c4158905d36c050a2f77cd70ebef11">XDp_TxResetPhy</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u32 Reset)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#aedf47a4635bd225559da3b5cc4c6ac0">XDp_TxSetPhyPolarityAll</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Polarity)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#e829b18d0b930de7a7851172b2bd41bb">XDp_TxSetPhyPolarityLane</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Lane, u8 Polarity)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#ec7d0a8c9e4b593ccdcb82e9d1e7f28d">XDp_RxCheckLinkStatus</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5e8030bf5d75d0d33d65480200472f10">XDp_RxDtgEn</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#395b87d147ea149bbc51dc6f2d72fedd">XDp_RxDtgDis</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f65a177db143ac0cff1f44f155673c22">XDp_RxSetLinkRate</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkRate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#424d3b46101c70b80d79047d75227fa8">XDp_RxSetLaneCount</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LaneCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#85656ea0eb2f4208877f724413a25c3f">XDp_RxAudioEn</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#c946b1c8836833f0c1f0ff321a92bfc7">XDp_RxAudioDis</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#126e52feb62e37f339c56de2713bb2c0">XDp_RxAudioReset</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4c4fe5a7f59bbbb3b91c4dcbd6a3280c">XDp_TxGetEdid</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 *Edid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2edcf18e30888578b5fe3e4afa86e3d4">XDp_TxGetRemoteEdid</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 *Edid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#62d43d69dfcac22d0e9dffc134ee670e">XDp_TxGetEdidBlock</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 *Data, u8 BlockNum)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#b34e369e6c231b095eed99aaaa118f2e">XDp_TxGetRemoteEdidBlock</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 *Data, u8 BlockNum, u8 LinkCountTotal, u8 *RelativeAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2abe15d9275d859a4ed36b4f65ab5da8">XDp_TxGetRemoteEdidDispIdExt</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 *Data, u8 LinkCountTotal, u8 *RelativeAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#19b64566bd575c0072b389c152f34390">XDp_TxGetDispIdDataBlock</a> (u8 *DisplayIdRaw, u8 SectionTag, u8 **DataBlockPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#744c99641ebfc7223353138cd7e79c98">XDp_TxGetRemoteTiledDisplayDb</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 *EdidExt, u8 LinkCountTotal, u8 *RelativeAddress, u8 **DataBlockPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5d95fcd5fa78f5ad7ac1bbfc112ea5f3">XDp_InterruptHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#015d1109cc6a50a52f4bfee772eb6d38">XDp_TxSetHpdEventHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#fd7cec8cb4c2a2470d5ab060017d9132">XDp_TxSetHpdPulseHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#8ee156df7f22a63cf2f0dfd0e7a5a05e">XDp_RxGenerateHpdInterrupt</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u16 DurationUs)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#80768e1423577f78e4b47f99f888a927">XDp_RxInterruptEnable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u32 Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4bd465055f990598d2554b065a295c04">XDp_RxInterruptDisable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u32 Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#a008236da2a86d134dd18cd463387df8">XDp_RxSetIntrVmChangeHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#80bbedf6face50b43843aeadec3f010b">XDp_RxSetIntrPowerStateHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#ccb98a439bb34f0ab58fae003dcf6365">XDp_RxSetIntrNoVideoHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#51379d32d900f3db2b8f54b872c76242">XDp_RxSetIntrVBlankHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f1b3d151179648a008b57635ad21e418">XDp_RxSetIntrTrainingLostHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#6bb8bfa0a951fca74a8d43d024bb4bb5">XDp_RxSetIntrVideoHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#22ace1a70921ee6c408fb4ef86d89188">XDp_RxSetIntrInfoPktHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#28512b0f6c69e090eb2297e6581d507b">XDp_RxSetIntrExtPktHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#de66ad73b7c1a6fa78182a60b62731ef">XDp_RxSetIntrTrainingDoneHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#3b90476f54f7b4473781240bff4e80fa">XDp_RxSetIntrBwChangeHandler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2481d3a65349fba469276b49dbdcbd98">XDp_RxSetIntrTp1Handler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4fc426c024bce1cc4c6d8c95367a3672">XDp_RxSetIntrTp2Handler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4cc462c847bca8413725425db80ff248">XDp_RxSetIntrTp3Handler</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a> CallbackFunc, void *CallbackRef)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f3d32422b4420ff71f43ecfe863249ab">XDp_TxMstCfgModeEnable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#8877b3e06ff0321a58e3fe4167a76dee">XDp_TxMstCfgModeDisable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4e381b64a7c146f4445dec587af71026">XDp_TxMstCapable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#9ea5a1e175846bc39b73cb43e4adc93b">XDp_TxMstEnable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4d4040715b5a0c02ea8e863aaae13bf5">XDp_TxMstDisable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#3b8898c6deb06d19d6ca33426a25a2d4">XDp_TxMstCfgStreamEnable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#cf8367ea139bff42c91d4c277f33466f">XDp_TxMstCfgStreamDisable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#da7cb5422a2febd13c8d4009aa77cc86">XDp_TxMstStreamIsEnabled</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#b277199a6f1fefa04965a87a24173bad">XDp_TxSetStreamSelectFromSinkList</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, u8 SinkNum)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#70fa67f68567df53d33163b09e9bca77">XDp_TxSetStreamSinkRad</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, u8 LinkCountTotal, u8 *RelativeAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f3879301590a6b55a4db582910e256f2">XDp_TxDiscoverTopology</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#a094e899b8686f7032698af2df865ce9">XDp_TxFindAccessibleDpDevices</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#4a28e8ab8abf429af41a27ea2b9323f9">XDp_TxTopologySwapSinks</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Index0, u8 Index1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#7ca9c95087f08d94d156873946712649">XDp_TxTopologySortSinksByTiling</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#0e67200282a52949a768a2ef651f41f0">XDp_TxRemoteDpcdRead</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToRead, u8 *ReadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2ad9ff7800cdd57422a3938ab6405cc5">XDp_TxRemoteDpcdWrite</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToWrite, u8 *WriteData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#8a4291b36c0db0564a2eefd589fc0260">XDp_TxRemoteIicRead</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicAddress, u16 Offset, u16 BytesToRead, u8 *ReadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#47cea5859706b6a888a7fb1b588da3c6">XDp_TxRemoteIicWrite</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicAddress, u8 BytesToWrite, u8 *WriteData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#0315e8c1c74e07b261c17dc2bf38d0e8">XDp_TxAllocatePayloadStreams</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5a72b9b2e38f4fb11ac0848da9a80df1">XDp_TxAllocatePayloadVcIdTable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 VcId, u8 Ts)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#c546c6baf95bf88dfa20d761848582a9">XDp_TxClearPayloadVcIdTable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#0b7cf1a8fce1050a660092aa612da79d">XDp_TxSendSbMsgRemoteDpcdWrite</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToWrite, u8 *WriteData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#fce6a6d29a3ac432244022407d63a6f0">XDp_TxSendSbMsgRemoteDpcdRead</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToRead, u8 *ReadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#2f896e53aeb519373f53b7cbf431d321">XDp_TxSendSbMsgRemoteIicWrite</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicDeviceId, u8 BytesToWrite, u8 *WriteData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5c4648a54d9a5941c25dbfc2b9315e15">XDp_TxSendSbMsgRemoteIicRead</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicDeviceId, u8 Offset, u8 BytesToRead, u8 *ReadData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#86609c6780646369e1ba37a50ded5b10">XDp_TxSendSbMsgLinkAddress</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, <a class="el" href="struct_x_dp___tx_sb_msg_link_address_reply_device_info.html">XDp_TxSbMsgLinkAddressReplyDeviceInfo</a> *DeviceInfo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#c08d3ad6aa95b172a0559eef622c59de">XDp_TxSendSbMsgEnumPathResources</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u16 *AvailPbn, u16 *FullPbn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#6c5992df734aee9d237d02cb92003388">XDp_TxSendSbMsgAllocatePayload</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 VcId, u16 Pbn)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#080e95835c089e6995e3db4744173019">XDp_TxSendSbMsgClearPayloadIdTable</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#6b1d94c567787ac3bd900d90dcd96a82">XDp_TxWriteGuid</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 Guid[4])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#fb249ef78276acc6e8f5e6d00ed614b1">XDp_TxGetGuid</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 *Guid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#506720dc403caa084533c26e52ae464b">XDp_SelfTest</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#512d65ee27d139f0190269fd7148c055">XDp_TxCfgMsaRecalculate</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#c35bac1818faf6e2bda67b5ce4df28f7">XDp_TxCfgMsaUseStandardVideoMode</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, XVidC_VideoMode VideoMode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#21d7294a283415a739b7acbd0b8bec46">XDp_TxCfgMsaUseEdidPreferredTiming</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, u8 *Edid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#bccc02a47b1fe214ed8a0dac33054775">XDp_TxCfgMsaUseCustom</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, <a class="el" href="struct_x_dp___tx_main_stream_attributes.html">XDp_TxMainStreamAttributes</a> *MsaConfigCustom, u8 Recalculate)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#8f2e11e13ef75b28079efe02539145a9">XDp_TxCfgMsaSetBpc</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, u8 BitsPerColor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#f8c0dad1a34563fbd6083e0398ced9a2">XDp_TxCfgMsaEnSynchClkMode</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream, u8 Enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#1c30da13f38cf02dc52a07347c99e71e">XDp_TxSetVideoMode</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5ba215b5d2d3ada4c90aafb36f4ed74a">XDp_TxClearMsaValues</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#123f88a702fe841a63f3d0a4bb7aaf09">XDp_TxSetMsaValues</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 Stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdp_8h.html#5222dbc2986980ba1f5edfa42084eaa4">XDp_RxSetUserPixelWidth</a> (<a class="el" href="struct_x_dp.html">XDp</a> *InstancePtr, u8 UserPixelWidth)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a3afd37e5bb042c2a75443eaadb79998"></a><!-- doxytag: member="xdp.h::XDp_GetCoreType" ref="a3afd37e5bb042c2a75443eaadb79998" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDp_GetCoreType          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((InstancePtr)-&gt;Config.IsRx \
                                                        ? <a class="code" href="xdp_8h.html#8d85f6071200723596c18f46ce9ef438af80f7b90e40284ace23dd7dd3b1b567">XDP_RX</a> : <a class="code" href="xdp_8h.html#8d85f6071200723596c18f46ce9ef4382660d3d871232c9a9d8e18867f6ac31b">XDP_TX</a>)
</pre></div>This is function determines whether the DisplayPort core, represented by the <a class="el" href="struct_x_dp.html">XDp</a> structure pointed to, is a transmitter (TX) or a receiver (RX).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XDP_RX if the core is of type RX. XDP_TX if the core is of type TX.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: XDp_CoreType <a class="el" href="xdp_8h.html#a3afd37e5bb042c2a75443eaadb79998">XDp_GetCoreType(XDp *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="343c4e8772e00e2754382e8a04bcedf7"></a><!-- doxytag: member="xdp.h::XDPRX" ref="343c4e8772e00e2754382e8a04bcedf7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDPRX&nbsp;&nbsp;&nbsp;XDP_RX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4c30366156ec8f2c6c8b6829733b3af0"></a><!-- doxytag: member="xdp.h::XDprx" ref="4c30366156ec8f2c6c8b6829733b3af0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp.html">XDp</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5ca5e5f9ed2ebcfe07da8b07b1aa30f9"></a><!-- doxytag: member="xdp.h::XDprx_CfgInitialize" ref="5ca5e5f9ed2ebcfe07da8b07b1aa30f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_CfgInitialize&nbsp;&nbsp;&nbsp;XDp_CfgInitialize          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e8525af82086937c660af869240cad2f"></a><!-- doxytag: member="xdp.h::XDprx_Config" ref="e8525af82086937c660af869240cad2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_Config&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp___config.html">XDp_Config</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="518ed8abb17284e34c24c41f97e929d4"></a><!-- doxytag: member="xdp.h::XDprx_InitializeRx" ref="518ed8abb17284e34c24c41f97e929d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_InitializeRx&nbsp;&nbsp;&nbsp;XDp_Initialize          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="294684facc13f2158e58572553791120"></a><!-- doxytag: member="xdp.h::XDprx_InterruptHandler" ref="294684facc13f2158e58572553791120" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_InterruptHandler&nbsp;&nbsp;&nbsp;XDp_InterruptHandler          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5f6d6322ccdd30a72ed1bff992c826c7"></a><!-- doxytag: member="xdp.h::XDprx_IntrHandler" ref="5f6d6322ccdd30a72ed1bff992c826c7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_IntrHandler&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3a32f20893940e1f21e314c83a86b1b0"></a><!-- doxytag: member="xdp.h::XDprx_LookupConfig" ref="3a32f20893940e1f21e314c83a86b1b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_LookupConfig&nbsp;&nbsp;&nbsp;XDp_LookupConfig          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="375c994e4be673c637c6f7763eb7043a"></a><!-- doxytag: member="xdp.h::XDprx_ReadReg" ref="375c994e4be673c637c6f7763eb7043a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_ReadReg&nbsp;&nbsp;&nbsp;XDp_ReadReg          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="019e21f29e885a55b217e2ffb1542e57"></a><!-- doxytag: member="xdp.h::XDprx_SelfTest" ref="019e21f29e885a55b217e2ffb1542e57" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_SelfTest&nbsp;&nbsp;&nbsp;XDp_SelfTest          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="555d7e44834dcb7a7dc6638439057b28"></a><!-- doxytag: member="xdp.h::XDprx_SetUserTimerHandler" ref="555d7e44834dcb7a7dc6638439057b28" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_SetUserTimerHandler&nbsp;&nbsp;&nbsp;XDp_SetUserTimerHandler          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2593f251dc247b3b3cb67fefa69c4eb0"></a><!-- doxytag: member="xdp.h::XDprx_TimerHandler" ref="2593f251dc247b3b3cb67fefa69c4eb0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_TimerHandler&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5b5593bdaa9747d153e56b50148a7136"></a><!-- doxytag: member="xdp.h::XDprx_WaitUs" ref="5b5593bdaa9747d153e56b50148a7136" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_WaitUs&nbsp;&nbsp;&nbsp;XDp_WaitUs          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="09aeb13773c5d98a00cf657547297240"></a><!-- doxytag: member="xdp.h::XDprx_WriteReg" ref="09aeb13773c5d98a00cf657547297240" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDprx_WriteReg&nbsp;&nbsp;&nbsp;XDp_WriteReg          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fbcf5cb1cdded0579fc927fae6511c36"></a><!-- doxytag: member="xdp.h::XDPTX" ref="fbcf5cb1cdded0579fc927fae6511c36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDPTX&nbsp;&nbsp;&nbsp;XDP_TX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="289da1dbb40e62ada891039e5d68c507"></a><!-- doxytag: member="xdp.h::XDptx" ref="289da1dbb40e62ada891039e5d68c507" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp.html">XDp</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8db3f1c5c6050e8394fd5c179b0d7a5a"></a><!-- doxytag: member="xdp.h::XDptx_CfgInitialize" ref="8db3f1c5c6050e8394fd5c179b0d7a5a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_CfgInitialize&nbsp;&nbsp;&nbsp;XDp_CfgInitialize          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="01f87635ba8bf944420ecff70e6dad60"></a><!-- doxytag: member="xdp.h::XDptx_Config" ref="01f87635ba8bf944420ecff70e6dad60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_Config&nbsp;&nbsp;&nbsp;<a class="el" href="struct_x_dp___config.html">XDp_Config</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="847e15772e8e242680800a66c8403ff5"></a><!-- doxytag: member="xdp.h::XDptx_HpdEventHandler" ref="847e15772e8e242680800a66c8403ff5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_HpdEventHandler&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5b4593582f4316691a04e764217a6a07"></a><!-- doxytag: member="xdp.h::XDptx_HpdInterruptHandler" ref="5b4593582f4316691a04e764217a6a07" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_HpdInterruptHandler&nbsp;&nbsp;&nbsp;XDp_InterruptHandler          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6bd70ff9dfd00e77eb9c3b3809dc0a51"></a><!-- doxytag: member="xdp.h::XDptx_HpdPulseHandler" ref="6bd70ff9dfd00e77eb9c3b3809dc0a51" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_HpdPulseHandler&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ab525d035beadef1156aaecdf675e531"></a><!-- doxytag: member="xdp.h::XDptx_InitializeTx" ref="ab525d035beadef1156aaecdf675e531" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_InitializeTx&nbsp;&nbsp;&nbsp;XDp_Initialize          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="76abcc25167c863fc908d209bd9ad16b"></a><!-- doxytag: member="xdp.h::XDptx_LookupConfig" ref="76abcc25167c863fc908d209bd9ad16b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_LookupConfig&nbsp;&nbsp;&nbsp;XDp_LookupConfig          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="271f1b2a20ca364ec0ce08ec1c7550ad"></a><!-- doxytag: member="xdp.h::XDptx_ReadReg" ref="271f1b2a20ca364ec0ce08ec1c7550ad" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_ReadReg&nbsp;&nbsp;&nbsp;XDp_ReadReg          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7e91ffab1f59aab90b0c5ad9c368ca23"></a><!-- doxytag: member="xdp.h::XDptx_SelfTest" ref="7e91ffab1f59aab90b0c5ad9c368ca23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_SelfTest&nbsp;&nbsp;&nbsp;XDp_SelfTest          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9edc7662e22b23761a4ae787628ea424"></a><!-- doxytag: member="xdp.h::XDptx_SetUserTimerHandler" ref="9edc7662e22b23761a4ae787628ea424" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_SetUserTimerHandler&nbsp;&nbsp;&nbsp;XDp_SetUserTimerHandler          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="14b9a1405b0f7dbb10e18ba7599994d9"></a><!-- doxytag: member="xdp.h::XDptx_TimerHandler" ref="14b9a1405b0f7dbb10e18ba7599994d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_TimerHandler&nbsp;&nbsp;&nbsp;<a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="abdd05fa8bf9325be958b54074bd02ea"></a><!-- doxytag: member="xdp.h::XDptx_WaitUs" ref="abdd05fa8bf9325be958b54074bd02ea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_WaitUs&nbsp;&nbsp;&nbsp;XDp_WaitUs          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7861fa71b501cb8e0652983bac2d1667"></a><!-- doxytag: member="xdp.h::XDptx_WriteReg" ref="7861fa71b501cb8e0652983bac2d1667" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XDptx_WriteReg&nbsp;&nbsp;&nbsp;XDp_WriteReg          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="986a09cc49fd7645fa11107cc25c453f"></a><!-- doxytag: member="xdp.h::XDp_IntrHandler" ref="986a09cc49fd7645fa11107cc25c453f" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>(void *InstancePtr)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback type which represents the handler for interrupts.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2ee8cde914736409c4b04146aa84462"></a><!-- doxytag: member="xdp.h::XDp_TimerHandler" ref="b2ee8cde914736409c4b04146aa84462" args="(void *InstancePtr, u32 MicroSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a>(void *InstancePtr, u32 MicroSeconds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback type which represents a custom timer wait handler. This is only used for Microblaze since it doesn't have a native sleep function. To avoid dependency on a hardware timer, the default wait functionality is implemented using loop iterations; this isn't too accurate. If a custom timer handler is used, the user may implement their own wait implementation using a hardware timer (see example/) for better accuracy.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MicroSeconds</em>&nbsp;</td><td>is the number of microseconds to be passed to the timer function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="8d85f6071200723596c18f46ce9ef438"></a><!-- doxytag: member="xdp.h::XDp_CoreType" ref="8d85f6071200723596c18f46ce9ef438" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="xdp_8h.html#8d85f6071200723596c18f46ce9ef438">XDp_CoreType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This typedef enumerates the RX and TX modes of operation for the DisplayPort core. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="8d85f6071200723596c18f46ce9ef4382660d3d871232c9a9d8e18867f6ac31b"></a><!-- doxytag: member="XDP_TX" ref="8d85f6071200723596c18f46ce9ef4382660d3d871232c9a9d8e18867f6ac31b" args="" -->XDP_TX</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="8d85f6071200723596c18f46ce9ef438af80f7b90e40284ace23dd7dd3b1b567"></a><!-- doxytag: member="XDP_RX" ref="8d85f6071200723596c18f46ce9ef438af80f7b90e40284ace23dd7dd3b1b567" args="" -->XDP_RX</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="cfec4779f9319bc515e77088923eb05e"></a><!-- doxytag: member="xdp.h::XDp_CfgInitialize" ref="cfec4779f9319bc515e77088923eb05e" args="(XDp *InstancePtr, XDp_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dp___config.html">XDp_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves the configuration for this DisplayPort instance and fills in the InstancePtr-&gt;Config structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a pointer to the configuration structure that will be used to copy the settings from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory space. If the address translation is not used, then the physical address is passed.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Unexpected errors may occur if the address mapping is changed after this function is invoked. </dd></dl>

</div>
</div><p>
<a class="anchor" name="85f185599e63935fa41e46ca249d4a3a"></a><!-- doxytag: member="xdp.h::XDp_Initialize" ref="85f185599e63935fa41e46ca249d4a3a" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_Initialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function prepares the DisplayPort core for use depending on whether the core is operating in TX or RX mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DisplayPort core was successfully initialized.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d95fcd5fa78f5ad7ac1bbfc112ea5f3"></a><!-- doxytag: member="xdp.h::XDp_InterruptHandler" ref="5d95fcd5fa78f5ad7ac1bbfc112ea5f3" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_InterruptHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the interrupt handler for the <a class="el" href="struct_x_dp.html">XDp</a> driver. When an interrupt happens, this interrupt handler will check which TX/RX mode of operation the core is running in, and will call the appropriate interrupt handler. The called interrupt handler will first detect what kind of interrupt happened, then decides which callback function to invoke.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="46c2b674f7a6e6e71016577cc975f00b"></a><!-- doxytag: member="xdp.h::XDp_LookupConfig" ref="46c2b674f7a6e6e71016577cc975f00b" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_dp___config.html">XDp_Config</a>* XDp_LookupConfig           </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function looks for the device configuration based on the unique device ID. The table XDp_ConfigTable[] contains the configuration information for each device in the system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c946b1c8836833f0c1f0ff321a92bfc7"></a><!-- doxytag: member="xdp.h::XDp_RxAudioDis" ref="c946b1c8836833f0c1f0ff321a92bfc7" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxAudioDis           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables audio stream packets on the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="85656ea0eb2f4208877f724413a25c3f"></a><!-- doxytag: member="xdp.h::XDp_RxAudioEn" ref="85656ea0eb2f4208877f724413a25c3f" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxAudioEn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables audio stream packets on the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="126e52feb62e37f339c56de2713bb2c0"></a><!-- doxytag: member="xdp.h::XDp_RxAudioReset" ref="126e52feb62e37f339c56de2713bb2c0" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxAudioReset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function resets the RX core's reception of audio stream packets on the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec7d0a8c9e4b593ccdcb82e9d1e7f28d"></a><!-- doxytag: member="xdp.h::XDp_RxCheckLinkStatus" ref="ec7d0a8c9e4b593ccdcb82e9d1e7f28d" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_RxCheckLinkStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if the reciever's internal registers indicate that link training has complete. That is, training has achieved channel equalization, symbol lock, and interlane alignment for all lanes currently in use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the RX device has achieved clock recovery, channel equalization, symbol lock, and interlane alignment.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="395b87d147ea149bbc51dc6f2d72fedd"></a><!-- doxytag: member="xdp.h::XDp_RxDtgDis" ref="395b87d147ea149bbc51dc6f2d72fedd" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxDtgDis           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables the display timing generator (DTG).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5e8030bf5d75d0d33d65480200472f10"></a><!-- doxytag: member="xdp.h::XDp_RxDtgEn" ref="5e8030bf5d75d0d33d65480200472f10" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxDtgEn           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables the display timing generator (DTG).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8ee156df7f22a63cf2f0dfd0e7a5a05e"></a><!-- doxytag: member="xdp.h::XDp_RxGenerateHpdInterrupt" ref="8ee156df7f22a63cf2f0dfd0e7a5a05e" args="(XDp *InstancePtr, u16 DurationUs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxGenerateHpdInterrupt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DurationUs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function generates a pulse on the hot-plug-detect (HPD) line of the specified duration.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DurationUs</em>&nbsp;</td><td>is the duration of the HPD pulse, in microseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4bd465055f990598d2554b065a295c04"></a><!-- doxytag: member="xdp.h::XDp_RxInterruptDisable" ref="4bd465055f990598d2554b065a295c04" args="(XDp *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxInterruptDisable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables interrupts associated with the specified mask.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>specifies which interrupts should be disabled. Bits set to 1 will disable the corresponding interrupts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80768e1423577f78e4b47f99f888a927"></a><!-- doxytag: member="xdp.h::XDp_RxInterruptEnable" ref="80768e1423577f78e4b47f99f888a927" args="(XDp *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxInterruptEnable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables interrupts associated with the specified mask.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>specifies which interrupts should be enabled. Bits set to 1 will enable the corresponding interrupts.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b90476f54f7b4473781240bff4e80fa"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrBwChangeHandler" ref="3b90476f54f7b4473781240bff4e80fa" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrBwChangeHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a bandwidth change interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="28512b0f6c69e090eb2297e6581d507b"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrExtPktHandler" ref="28512b0f6c69e090eb2297e6581d507b" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrExtPktHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when an audio extension packet interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="22ace1a70921ee6c408fb4ef86d89188"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrInfoPktHandler" ref="22ace1a70921ee6c408fb4ef86d89188" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrInfoPktHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when an audio info packet interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccb98a439bb34f0ab58fae003dcf6365"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrNoVideoHandler" ref="ccb98a439bb34f0ab58fae003dcf6365" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrNoVideoHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a no video interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="80bbedf6face50b43843aeadec3f010b"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrPowerStateHandler" ref="80bbedf6face50b43843aeadec3f010b" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrPowerStateHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when the power state interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2481d3a65349fba469276b49dbdcbd98"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrTp1Handler" ref="2481d3a65349fba469276b49dbdcbd98" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrTp1Handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a training pattern 1 interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4fc426c024bce1cc4c6d8c95367a3672"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrTp2Handler" ref="4fc426c024bce1cc4c6d8c95367a3672" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrTp2Handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a training pattern 2 interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4cc462c847bca8413725425db80ff248"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrTp3Handler" ref="4cc462c847bca8413725425db80ff248" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrTp3Handler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a training pattern 3 interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="de66ad73b7c1a6fa78182a60b62731ef"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrTrainingDoneHandler" ref="de66ad73b7c1a6fa78182a60b62731ef" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrTrainingDoneHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a training done interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f1b3d151179648a008b57635ad21e418"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrTrainingLostHandler" ref="f1b3d151179648a008b57635ad21e418" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrTrainingLostHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a training lost interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="51379d32d900f3db2b8f54b872c76242"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrVBlankHandler" ref="51379d32d900f3db2b8f54b872c76242" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrVBlankHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a vertical blanking interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6bb8bfa0a951fca74a8d43d024bb4bb5"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrVideoHandler" ref="6bb8bfa0a951fca74a8d43d024bb4bb5" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrVideoHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a valid video interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a008236da2a86d134dd18cd463387df8"></a><!-- doxytag: member="xdp.h::XDp_RxSetIntrVmChangeHandler" ref="a008236da2a86d134dd18cd463387df8" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetIntrVmChangeHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a video mode change interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="424d3b46101c70b80d79047d75227fa8"></a><!-- doxytag: member="xdp.h::XDp_RxSetLaneCount" ref="424d3b46101c70b80d79047d75227fa8" args="(XDp *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetLaneCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the maximum lane count to be exposed in the RX device's DisplayPort Configuration Data (DPCD) registers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to be used over the main link.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f65a177db143ac0cff1f44f155673c22"></a><!-- doxytag: member="xdp.h::XDp_RxSetLinkRate" ref="f65a177db143ac0cff1f44f155673c22" args="(XDp *InstancePtr, u8 LinkRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetLinkRate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the maximum data rate to be exposed in the RX device's DisplayPort Configuration Data (DPCD) registers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkRate</em>&nbsp;</td><td>is the link rate to be used over the main link based on one of the following selects:<ul>
<li>XDP_RX_LINK_BW_SET_162GBPS = 0x06 (for a 1.62 Gbps data rate)</li><li>XDP_RX_LINK_BW_SET_270GBPS = 0x0A (for a 2.70 Gbps data rate)</li><li>XDP_RX_LINK_BW_SET_540GBPS = 0x14 (for a 5.40 Gbps data rate)</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5222dbc2986980ba1f5edfa42084eaa4"></a><!-- doxytag: member="xdp.h::XDp_RxSetUserPixelWidth" ref="5222dbc2986980ba1f5edfa42084eaa4" args="(XDp *InstancePtr, u8 UserPixelWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_RxSetUserPixelWidth           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>UserPixelWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function configures the number of pixels output through the user data interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>UserPixelWidth</em>&nbsp;</td><td>is the user pixel width to be configured.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="506720dc403caa084533c26e52ae464b"></a><!-- doxytag: member="xdp.h::XDp_SelfTest" ref="506720dc403caa084533c26e52ae464b" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_SelfTest           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function runs a self-test on the <a class="el" href="struct_x_dp.html">XDp</a> driver/device depending on whether the core is operating in TX or RX mode. The sanity test checks whether or not all tested registers hold their default reset values.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the self-test passed - all tested registers hold their default reset values.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e31cad17809d5e67bade4c08a4b6c93"></a><!-- doxytag: member="xdp.h::XDp_SetUserTimerHandler" ref="7e31cad17809d5e67bade4c08a4b6c93" args="(XDp *InstancePtr, XDp_TimerHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_SetUserTimerHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#b2ee8cde914736409c4b04146aa84462">XDp_TimerHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a custom delay/sleep function to be used by the <a class="el" href="struct_x_dp.html">XDp</a> driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item (microseconds to delay) that will be passed to the custom sleep/delay function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0315e8c1c74e07b261c17dc2bf38d0e8"></a><!-- doxytag: member="xdp.h::XDp_TxAllocatePayloadStreams" ref="0315e8c1c74e07b261c17dc2bf38d0e8" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxAllocatePayloadStreams           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will allocate bandwidth for all enabled stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the payload ID tables were successfully updated with the new allocation.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, waiting for the payload ID table to be cleared or updated, or an AUX request timed out.</li><li>XST_BUFFER_TOO_SMALL if there is not enough free timeslots in the payload ID table for the requested Ts.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of a sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a72b9b2e38f4fb11ac0848da9a80df1"></a><!-- doxytag: member="xdp.h::XDp_TxAllocatePayloadVcIdTable" ref="5a72b9b2e38f4fb11ac0848da9a80df1" args="(XDp *InstancePtr, u8 VcId, u8 Ts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxAllocatePayloadVcIdTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Ts</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will allocate a bandwidth for a virtual channel in the payload ID table in both the DisplayPort TX and the downstream DisplayPort devices on the path to the target device specified by LinkCountTotal and RelativeAddress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VcId</em>&nbsp;</td><td>is the unique virtual channel ID to allocate into the payload ID tables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Ts</em>&nbsp;</td><td>is the number of timeslots to allocate in the payload ID tables.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the payload ID tables were successfully updated with the new allocation.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_BUFFER_TOO_SMALL if there is not enough free timeslots in the payload ID table for the requested Ts.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of a sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="326335c87939629db5364c21c7e81a45"></a><!-- doxytag: member="xdp.h::XDp_TxAuxRead" ref="326335c87939629db5364c21c7e81a45" args="(XDp *InstancePtr, u32 DpcdAddress, u32 BytesToRead, void *ReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxAuxRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DpcdAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ReadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function issues a read request over the AUX channel that will read from the RX device's DisplayPort Configuration Data (DPCD) address space. The read message will be divided into multiple transactions which read a maximum of 16 bytes each.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DpcdAddress</em>&nbsp;</td><td>is the starting address to read from the RX device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToRead</em>&nbsp;</td><td>is the number of bytes to read from the RX device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReadData</em>&nbsp;</td><td>is a pointer to the data buffer that will be filled with read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the AUX read request was successfully acknowledged.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cec5ef6d6656c0c2ae17761172acf6c1"></a><!-- doxytag: member="xdp.h::XDp_TxAuxWrite" ref="cec5ef6d6656c0c2ae17761172acf6c1" args="(XDp *InstancePtr, u32 DpcdAddress, u32 BytesToWrite, void *WriteData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxAuxWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DpcdAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>WriteData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function issues a write request over the AUX channel that will write to the RX device's DisplayPort Configuration Data (DPCD) address space. The write message will be divided into multiple transactions which write a maximum of 16 bytes each.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DpcdAddress</em>&nbsp;</td><td>is the starting address to write to the RX device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToWrite</em>&nbsp;</td><td>is the number of bytes to write to the RX device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WriteData</em>&nbsp;</td><td>is a pointer to the data buffer that contains the data to be written to the RX device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the AUX write request was successfully acknowledged.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f68236955b8b3a6292a9b9cc357ec1fa"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMainLinkMax" ref="f68236955b8b3a6292a9b9cc357ec1fa" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxCfgMainLinkMax           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function determines the common capabilities between the DisplayPort TX core and the RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if main link settings were successfully set.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f8c0dad1a34563fbd6083e0398ced9a2"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMsaEnSynchClkMode" ref="f8c0dad1a34563fbd6083e0398ced9a2" args="(XDp *InstancePtr, u8 Stream, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgMsaEnSynchClkMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables synchronous clock mode for a video stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which to enable or disable synchronous clock mode. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>if set to 1, will enable synchronous clock mode. Otherwise, if set to 0, synchronous clock mode will be disabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="512d65ee27d139f0190269fd7148c055"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMsaRecalculate" ref="512d65ee27d139f0190269fd7148c055" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgMsaRecalculate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function calculates the following Main Stream Attributes (MSA):<ul>
<li>Transfer unit size</li><li>User pixel width</li><li>Horizontal start</li><li>Vertical start</li><li>Horizontal total clock</li><li>Vertical total clock</li><li>Misc0</li><li>Misc1</li><li>Data per lane</li><li>Average number of bytes per transfer unit</li><li>Number of initial wait cycles These values are derived from:</li><li>Bits per color</li><li>Horizontal resolution</li><li>Vertical resolution</li><li>Pixel clock (in KHz)</li><li>Horizontal sync polarity</li><li>Vertical sync polarity</li><li>Horizontal front porch</li><li>Horizontal sync pulse width</li><li>Horizontal back porch</li><li>Vertical front porch</li><li>Vertical sync pulse width</li><li>Vertical back porch</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which to calculate the MSA values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The MsaConfig structure is modified with the new, calculated values. The main stream attributes that were used to derive the calculated values are untouched in the MsaConfig structure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f2e11e13ef75b28079efe02539145a9"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMsaSetBpc" ref="8f2e11e13ef75b28079efe02539145a9" args="(XDp *InstancePtr, u8 Stream, u8 BitsPerColor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgMsaSetBpc           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BitsPerColor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the bits per color value of the video stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which to set the color depth. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BitsPerColor</em>&nbsp;</td><td>is the new number of bits per color to use.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;TxInstance.MsaConfig structure is modified to reflect the new main stream attributes associated with a new bits per color value. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bccc02a47b1fe214ed8a0dac33054775"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMsaUseCustom" ref="bccc02a47b1fe214ed8a0dac33054775" args="(XDp *InstancePtr, u8 Stream, XDp_TxMainStreamAttributes *MsaConfigCustom, u8 Recalculate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgMsaUseCustom           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dp___tx_main_stream_attributes.html">XDp_TxMainStreamAttributes</a> *&nbsp;</td>
          <td class="paramname"> <em>MsaConfigCustom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Recalculate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function takes a the main stream attributes from MsaConfigCustom and copies them into InstancePtr-&gt;TxInstance.MsaConfig. If desired, given a base set of attributes, the rest of the attributes may be derived. The minimal required main stream attributes (MSA) that must be contained in the MsaConfigCustom structure are:<ul>
<li>Pixel clock (in Hz)</li><li>Frame rate</li><li>Horizontal active resolution</li><li>Horizontal front porch</li><li>Horizontal sync pulse width</li><li>Horizontal back porch</li><li>Horizontal total</li><li>Horizontal sync polarity</li><li>Vertical active resolution</li><li>Vertical back porch</li><li>Vertical sync pulse width</li><li>Vertical front porch</li><li>Vertical total</li><li>Vertical sync polarity</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which the MSA values will be used for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsaConfigCustom</em>&nbsp;</td><td>is the structure that will be used to copy the main stream attributes from (into InstancePtr-&gt;TxInstance.MsaConfig). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Recalculate</em>&nbsp;</td><td>is a boolean enable that determines whether or not the main stream attributes should be recalculated.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;TxInstance.MsaConfig structure is modified with the new values. </dd></dl>

</div>
</div><p>
<a class="anchor" name="21d7294a283415a739b7acbd0b8bec46"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMsaUseEdidPreferredTiming" ref="21d7294a283415a739b7acbd0b8bec46" args="(XDp *InstancePtr, u8 Stream, u8 *Edid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgMsaUseEdidPreferredTiming           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Edid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the main stream attribute values in the configuration structure to match the preferred timing of the sink monitor. This Preferred Timing Mode (PTM) information is stored in the sink's Extended Display Identification Data (EDID).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which the MSA values will be used for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Edid</em>&nbsp;</td><td>is a pointer to the Edid to use for the specified stream.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;TxInstance.MsaConfig structure is modified to reflect the main stream attribute values associated to the preferred timing of the sink monitor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c35bac1818faf6e2bda67b5ce4df28f7"></a><!-- doxytag: member="xdp.h::XDp_TxCfgMsaUseStandardVideoMode" ref="c35bac1818faf6e2bda67b5ce4df28f7" args="(XDp *InstancePtr, u8 Stream, XVidC_VideoMode VideoMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgMsaUseStandardVideoMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">XVidC_VideoMode&nbsp;</td>
          <td class="paramname"> <em>VideoMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the Main Stream Attribute (MSA) values in the configuration structure to match one of the standard display mode timings from the XDp_TxDmtModes[] standard Display Monitor Timing (DMT) table. The XDp_TxVideoMode enumeration in xvidc.h lists the available video modes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which the MSA values will be used for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VideoMode</em>&nbsp;</td><td>is one of the enumerated standard video modes that is used to determine the MSA values to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The InstancePtr-&gt;TxInstance.MsaConfig structure is modified to reflect the MSA values associated to the specified video mode. </dd></dl>

</div>
</div><p>
<a class="anchor" name="90b6e9474941dd1dee7eebb4f9ba57ca"></a><!-- doxytag: member="xdp.h::XDp_TxCfgTxPeLevel" ref="90b6e9474941dd1dee7eebb4f9ba57ca" args="(XDp *InstancePtr, u8 Level, u8 TxLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgTxPeLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TxLevel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the pre-emphasis level value in the DisplayPort TX that will be used during link training for a given pre-emphasis training level.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Level</em>&nbsp;</td><td>is the pre-emphasis training level to set the DisplayPort TX level for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxLevel</em>&nbsp;</td><td>is the DisplayPort TX pre-emphasis level value to be used during link training.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>There are 32 possible pre-emphasis levels in the DisplayPort TX core that map to 4 possible pre-emphasis training levels in the RX device. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3633e0db29e804a6f3da321613e3539d"></a><!-- doxytag: member="xdp.h::XDp_TxCfgTxVsLevel" ref="3633e0db29e804a6f3da321613e3539d" args="(XDp *InstancePtr, u8 Level, u8 TxLevel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgTxVsLevel           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TxLevel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the voltage swing level value in the DisplayPort TX that will be used during link training for a given voltage swing training level.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Level</em>&nbsp;</td><td>is the voltage swing training level to set the DisplayPort TX level for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxLevel</em>&nbsp;</td><td>is the DisplayPort TX voltage swing level value to be used during link training.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>There are 16 possible voltage swing levels in the DisplayPort TX core that map to 4 possible voltage swing training levels in the RX device. </dd></dl>

</div>
</div><p>
<a class="anchor" name="56904fc019dd1c8bc629b601ae5b5eba"></a><!-- doxytag: member="xdp.h::XDp_TxCfgTxVsOffset" ref="56904fc019dd1c8bc629b601ae5b5eba" args="(XDp *InstancePtr, u8 Offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxCfgTxVsOffset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Offset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the voltage swing offset to use during training when no redriver exists. The offset will be added to the DisplayPort TX's voltage swing level value when pre-emphasis is used (when the pre-emphasis level not equal to 0).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the value to set for the voltage swing offset.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a50e8ec50a21bb3df5d1125ebe95493d"></a><!-- doxytag: member="xdp.h::XDp_TxCheckLinkStatus" ref="a50e8ec50a21bb3df5d1125ebe95493d" args="(XDp *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxCheckLinkStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if the reciever's DisplayPort Configuration Data (DPCD) indicates the reciever has achieved and maintained clock recovery, channel equalization, symbol lock, and interlane alignment for all lanes currently in use.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to check.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the RX device has maintained clock recovery, channel equalization, symbol lock, and interlane alignment.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5ba215b5d2d3ada4c90aafb36f4ed74a"></a><!-- doxytag: member="xdp.h::XDp_TxClearMsaValues" ref="5ba215b5d2d3ada4c90aafb36f4ed74a" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxClearMsaValues           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function clears the main stream attributes registers of the DisplayPort TX core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which to clear the MSA values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c546c6baf95bf88dfa20d761848582a9"></a><!-- doxytag: member="xdp.h::XDp_TxClearPayloadVcIdTable" ref="c546c6baf95bf88dfa20d761848582a9" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxClearPayloadVcIdTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will clear the virtual channel payload ID table in both the DisplayPort TX and all downstream DisplayPort devices.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the payload ID tables were successfully cleared.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of a sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ebce10cc5382091395edb1e106f4ad1"></a><!-- doxytag: member="xdp.h::XDp_TxDisableMainLink" ref="2ebce10cc5382091395edb1e106f4ad1" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxDisableMainLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function disables the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3879301590a6b55a4db582910e256f2"></a><!-- doxytag: member="xdp.h::XDp_TxDiscoverTopology" ref="f3879301590a6b55a4db582910e256f2" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxDiscoverTopology           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will explore the DisplayPort topology of downstream devices connected to the DisplayPort TX. It will recursively go through each branch device, obtain its information by sending a LINK_ADDRESS sideband message, and add this information to the the topology's node table. For each sink device connected to a branch's downstream port, this function will obtain the details of the sink, add it to the topology's node table, as well as add it to the topology's sink list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the topology discovery is successful.</li><li>XST_FAILURE otherwise - if sending a LINK_ADDRESS sideband message to one of the branch devices in the topology failed.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The contents of the InstancePtr-&gt;TxInstance.Topology structure will be modified. </dd></dl>

</div>
</div><p>
<a class="anchor" name="400f2bfe7aa6c820e915afd0fb685779"></a><!-- doxytag: member="xdp.h::XDp_TxEnableMainLink" ref="400f2bfe7aa6c820e915afd0fb685779" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxEnableMainLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables the main link.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a07f4cc7ae9d45915497ed53d288061"></a><!-- doxytag: member="xdp.h::XDp_TxEnableTrainAdaptive" ref="5a07f4cc7ae9d45915497ed53d288061" args="(XDp *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxEnableTrainAdaptive           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables downshifting during the training process.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>controls the downshift feature in the training process.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04b03753ee278bdac3e2262b99366493"></a><!-- doxytag: member="xdp.h::XDp_TxEstablishLink" ref="04b03753ee278bdac3e2262b99366493" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxEstablishLink           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if the link needs training and runs the training sequence if training is required.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS was either already trained, or has been trained successfully.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a094e899b8686f7032698af2df865ce9"></a><!-- doxytag: member="xdp.h::XDp_TxFindAccessibleDpDevices" ref="a094e899b8686f7032698af2df865ce9" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxFindAccessibleDpDevices           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will explore the DisplayPort topology of downstream devices starting from the branch device specified by the LinkCountTotal and RelativeAddress parameters. It will recursively go through each branch device, obtain its information by sending a LINK_ADDRESS sideband message, and add this information to the the topology's node table. For each sink device connected to a branch's downstream port, this function will obtain the details of the sink, add it to the topology's node table, as well as add it to the topology's sink list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the total DisplayPort links connecting the DisplayPort TX to the current downstream device in the recursion. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the current target DisplayPort device in the recursion.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the topology discovery is successful.</li><li>XST_FAILURE otherwise - if sending a LINK_ADDRESS sideband message to one of the branch devices in the topology failed.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The contents of the InstancePtr-&gt;TxInstance.Topology structure will be modified. </dd></dl>

</div>
</div><p>
<a class="anchor" name="19b64566bd575c0072b389c152f34390"></a><!-- doxytag: member="xdp.h::XDp_TxGetDispIdDataBlock" ref="19b64566bd575c0072b389c152f34390" args="(u8 *DisplayIdRaw, u8 SectionTag, u8 **DataBlockPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetDispIdDataBlock           </td>
          <td>(</td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>DisplayIdRaw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>SectionTag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&nbsp;</td>
          <td class="paramname"> <em>DataBlockPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a section tag, search for and retrieve the appropriate section data block that is part of the specified DisplayID structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DisplayIdRaw</em>&nbsp;</td><td>is a pointer to the DisplayID data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SectionTag</em>&nbsp;</td><td>is the tag to search for that represents the desired section data block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBlockPtr</em>&nbsp;</td><td>will be set by this function to point to the appropriate section data block that is part of the DisplayIdRaw.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the section data block with the specified tag was found.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The DataBlockPtr argument is modified to point to the entry in DisplayIdRaw that represents the beginning of the desired section data block. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4c4fe5a7f59bbbb3b91c4dcbd6a3280c"></a><!-- doxytag: member="xdp.h::XDp_TxGetEdid" ref="4c4fe5a7f59bbbb3b91c4dcbd6a3280c" args="(XDp *InstancePtr, u8 *Edid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetEdid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Edid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves an immediately connected RX device's Extended Display Identification Data (EDID) structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Edid</em>&nbsp;</td><td>is a pointer to the Edid buffer to save to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C transactions to read the EDID were successful.</li><li>XST_ERROR_COUNT_MAX if the EDID read request timed out.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="62d43d69dfcac22d0e9dffc134ee670e"></a><!-- doxytag: member="xdp.h::XDp_TxGetEdidBlock" ref="62d43d69dfcac22d0e9dffc134ee670e" args="(XDp *InstancePtr, u8 *Data, u8 BlockNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetEdidBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BlockNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve an immediately connected RX device's Extended Display Identification Data (EDID) block given the block number. A block number of 0 represents the base EDID and subsequent block numbers represent EDID extension blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer to save the block data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockNum</em>&nbsp;</td><td>is the EDID block number to retrieve.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the block read has successfully completed with no errors.</li><li>XST_ERROR_COUNT_MAX if a time out occurred while attempting to read the requested block.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fb249ef78276acc6e8f5e6d00ed614b1"></a><!-- doxytag: member="xdp.h::XDp_TxGetGuid" ref="fb249ef78276acc6e8f5e6d00ed614b1" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 *Guid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxGetGuid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>Guid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will obtain the global unique identifier (GUID) for the target DisplayPort device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Guid</em>&nbsp;</td><td>is a pointer to the GUID that will store the existing GUID of the target device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2edcf18e30888578b5fe3e4afa86e3d4"></a><!-- doxytag: member="xdp.h::XDp_TxGetRemoteEdid" ref="2edcf18e30888578b5fe3e4afa86e3d4" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 *Edid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetRemoteEdid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Edid</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves a remote RX device's Extended Display Identification Data (EDID) structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Edid</em>&nbsp;</td><td>is a pointer to the Edid buffer to save to.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C transactions to read the EDID were successful.</li><li>XST_ERROR_COUNT_MAX if the EDID read request timed out.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b34e369e6c231b095eed99aaaa118f2e"></a><!-- doxytag: member="xdp.h::XDp_TxGetRemoteEdidBlock" ref="b34e369e6c231b095eed99aaaa118f2e" args="(XDp *InstancePtr, u8 *Data, u8 BlockNum, u8 LinkCountTotal, u8 *RelativeAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetRemoteEdidBlock           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BlockNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Retrieve a downstream DisplayPort device's Extended Display Identification Data (EDID) block given the block number. A block number of 0 represents the base EDID and subsequent block numbers represent EDID extension blocks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer to save the block data to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BlockNum</em>&nbsp;</td><td>is the EDID block number to retrieve. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the total DisplayPort links connecting the DisplayPort TX to the targeted downstream device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the targeted DisplayPort device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the block read has successfully completed with no errors.</li><li>XST_ERROR_COUNT_MAX if a time out occurred while attempting to read the requested block.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2abe15d9275d859a4ed36b4f65ab5da8"></a><!-- doxytag: member="xdp.h::XDp_TxGetRemoteEdidDispIdExt" ref="2abe15d9275d859a4ed36b4f65ab5da8" args="(XDp *InstancePtr, u8 *Data, u8 LinkCountTotal, u8 *RelativeAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetRemoteEdidDispIdExt           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>Data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search for and retrieve a downstream DisplayPort device's Extended Display Identification Data (EDID) extension block of type DisplayID.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is a pointer to the data buffer to save the DisplayID to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the total DisplayPort links connecting the DisplayPort TX to the targeted downstream device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the targeted DisplayPort device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS a DisplayID extension block was found.</li><li>XST_ERROR_COUNT_MAX if a time out occurred while attempting to read an extension block.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE if no DisplayID extension block was found or some error occurred in the search.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="744c99641ebfc7223353138cd7e79c98"></a><!-- doxytag: member="xdp.h::XDp_TxGetRemoteTiledDisplayDb" ref="744c99641ebfc7223353138cd7e79c98" args="(XDp *InstancePtr, u8 *EdidExt, u8 LinkCountTotal, u8 *RelativeAddress, u8 **DataBlockPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetRemoteTiledDisplayDb           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>EdidExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 **&nbsp;</td>
          <td class="paramname"> <em>DataBlockPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Search for and retrieve a downstream DisplayPort device's Tiled Display Topology (TDT) section data block that is part of the downstream device's DisplayID structure. The DisplayID structure is part of the Extended Display Identification Data (EDID) in the form of an extension block.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EdidExt</em>&nbsp;</td><td>is a pointer to the data area that will be filled by the retrieved DisplayID extension block. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the total DisplayPort links connecting the DisplayPort TX to the targeted downstream device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the targeted DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DataBlockPtr</em>&nbsp;</td><td>will be set by this function to point to the TDT data block that is part of the EdidExt extension block.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS a DisplayID extension block was found.</li><li>XST_ERROR_COUNT_MAX if a time out occurred while attempting to read an extension block.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE if no DisplayID extension block was found or some error occurred in the search.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The EdidExt will be filled with the DisplayID EDID extension block and the DataBlockPtr argument is modified to point to the EdidExt entry representing the TDT section data block. </dd></dl>

</div>
</div><p>
<a class="anchor" name="831242817739efb8ec76f65b317b00c7"></a><!-- doxytag: member="xdp.h::XDp_TxGetRxCapabilities" ref="831242817739efb8ec76f65b317b00c7" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxGetRxCapabilities           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function retrieves the RX device's capabilities from the RX device's DisplayPort Configuration Data (DPCD).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DisplayPort Configuration Data was read successfully.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c0b819f21d763400b8f9c2cc150e060f"></a><!-- doxytag: member="xdp.h::XDp_TxIicRead" ref="c0b819f21d763400b8f9c2cc150e060f" args="(XDp *InstancePtr, u8 IicAddress, u16 Offset, u16 BytesToRead, void *ReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxIicRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>BytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>ReadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs an I2C read over the AUX channel. The read message will be divided into multiple transactions if the requested data spans multiple segments. The segment pointer is automatically incremented and the offset is calibrated as needed. E.g. For an overall offset of:<ul>
<li>128, an I2C read is done on segptr=0; offset=128.</li><li>256, an I2C read is done on segptr=1; offset=0.</li><li>384, an I2C read is done on segptr=1; offset=128.</li><li>512, an I2C read is done on segptr=2; offset=0.</li><li>etc.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset at the specified address of the targeted I2C device that the read will start from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToRead</em>&nbsp;</td><td>is the number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReadData</em>&nbsp;</td><td>is a pointer to a buffer that will be filled with the I2C read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C read has successfully completed with no errors.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6cbeb74d7664817db482923e4dc1683c"></a><!-- doxytag: member="xdp.h::XDp_TxIicWrite" ref="6cbeb74d7664817db482923e4dc1683c" args="(XDp *InstancePtr, u8 IicAddress, u8 BytesToWrite, void *WriteData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxIicWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>WriteData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs an I2C write over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToWrite</em>&nbsp;</td><td>is the number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WriteData</em>&nbsp;</td><td>is a pointer to a buffer which will be used as the data source for the write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C write has successfully completed with no errors.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if the AUX request timed out.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3305ff3687d4c994d2200ad861828295"></a><!-- doxytag: member="xdp.h::XDp_TxIsConnected" ref="3305ff3687d4c994d2200ad861828295" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxIsConnected           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function checks if there is a connected RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if there is a connection.</li><li>FALSE if there is no connection. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="4e381b64a7c146f4445dec587af71026"></a><!-- doxytag: member="xdp.h::XDp_TxMstCapable" ref="4e381b64a7c146f4445dec587af71026" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxMstCapable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will check if the immediate downstream RX device is capable of multi-stream transport (MST) mode. A DisplayPort Configuration Data (DPCD) version of 1.2 or higher is required and the MST capability bit in the DPCD must be set for this function to return XST_SUCCESS.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the RX device is MST capable.</li><li>XST_NO_FEATURE if the RX device does not support MST.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if an AUX read request timed out.</li><li>XST_FAILURE otherwise - if an AUX read transaction failed.</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8877b3e06ff0321a58e3fe4167a76dee"></a><!-- doxytag: member="xdp.h::XDp_TxMstCfgModeDisable" ref="8877b3e06ff0321a58e3fe4167a76dee" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxMstCfgModeDisable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable multi-stream transport (MST) mode for the driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>When disabled, the driver will behave in single-stream transport (SST) mode. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3d32422b4420ff71f43ecfe863249ab"></a><!-- doxytag: member="xdp.h::XDp_TxMstCfgModeEnable" ref="f3d32422b4420ff71f43ecfe863249ab" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxMstCfgModeEnable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable multi-stream transport (MST) mode for the driver.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cf8367ea139bff42c91d4c277f33466f"></a><!-- doxytag: member="xdp.h::XDp_TxMstCfgStreamDisable" ref="cf8367ea139bff42c91d4c277f33466f" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxMstCfgStreamDisable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will configure the InstancePtr-&gt;TxInstance.MstStreamConfig structure to disable the specified stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream ID that will be disabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b8898c6deb06d19d6ca33426a25a2d4"></a><!-- doxytag: member="xdp.h::XDp_TxMstCfgStreamEnable" ref="3b8898c6deb06d19d6ca33426a25a2d4" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxMstCfgStreamEnable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will configure the InstancePtr-&gt;TxInstance.MstStreamConfig structure to enable the specified stream.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream ID that will be enabled.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d4040715b5a0c02ea8e863aaae13bf5"></a><!-- doxytag: member="xdp.h::XDp_TxMstDisable" ref="4d4040715b5a0c02ea8e863aaae13bf5" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxMstDisable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will disable multi-stream transport (MST) mode in both the DisplayPort TX and the immediate downstream RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if MST mode has been successful disabled in hardware.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if the AUX write request timed out.</li><li>XST_FAILURE otherwise - if the AUX write transaction failed.</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ea5a1e175846bc39b73cb43e4adc93b"></a><!-- doxytag: member="xdp.h::XDp_TxMstEnable" ref="9ea5a1e175846bc39b73cb43e4adc93b" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxMstEnable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will enable multi-stream transport (MST) mode in both the DisplayPort TX and the immediate downstream RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if MST mode has been successful enabled in hardware.</li><li>XST_NO_FEATURE if the immediate downstream RX device does not support MST - that is, if its DisplayPort Configuration Data (DPCD) version is less than 1.2, or if the DPCD indicates that it has no DPCD capabilities.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed.</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="da7cb5422a2febd13c8d4009aa77cc86"></a><!-- doxytag: member="xdp.h::XDp_TxMstStreamIsEnabled" ref="da7cb5422a2febd13c8d4009aa77cc86" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XDp_TxMstStreamIsEnabled           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will check whether<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream ID to check for enable/disable status.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>1 if the specified stream is enabled.</li><li>0 if the specified stream is disabled.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0e67200282a52949a768a2ef651f41f0"></a><!-- doxytag: member="xdp.h::XDp_TxRemoteDpcdRead" ref="0e67200282a52949a768a2ef651f41f0" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToRead, u8 *ReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxRemoteDpcdRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DpcdAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ReadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a remote DisplayPort Configuration Data (DPCD) read by sending a sideband message. In case message is directed at the RX device connected immediately to the TX, the message is issued over the AUX channel. The read message will be divided into multiple transactions which read a maximum of 16 bytes each.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DpcdAddress</em>&nbsp;</td><td>is the starting address to read from the RX device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToRead</em>&nbsp;</td><td>is the number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReadData</em>&nbsp;</td><td>is a pointer to the data buffer that will be filled with read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DPCD read has successfully completed (has been acknowledged).</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_DATA_LOST if the requested number of BytesToRead does not equal that actually received.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2ad9ff7800cdd57422a3938ab6405cc5"></a><!-- doxytag: member="xdp.h::XDp_TxRemoteDpcdWrite" ref="2ad9ff7800cdd57422a3938ab6405cc5" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToWrite, u8 *WriteData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxRemoteDpcdWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DpcdAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>WriteData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a remote DisplayPort Configuration Data (DPCD) write by sending a sideband message. In case message is directed at the RX device connected immediately to the TX, the message is issued over the AUX channel. The write message will be divided into multiple transactions which write a maximum of 16 bytes each.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DpcdAddress</em>&nbsp;</td><td>is the starting address to write to the RX device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToWrite</em>&nbsp;</td><td>is the number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WriteData</em>&nbsp;</td><td>is a pointer to a buffer which will be used as the data source for the write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the DPCD write has successfully completed (has been acknowledged).</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_DATA_LOST if the requested number of BytesToWrite does not equal that actually received.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a4291b36c0db0564a2eefd589fc0260"></a><!-- doxytag: member="xdp.h::XDp_TxRemoteIicRead" ref="8a4291b36c0db0564a2eefd589fc0260" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicAddress, u16 Offset, u16 BytesToRead, u8 *ReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxRemoteIicRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>BytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ReadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a remote I2C read by sending a sideband message. In case message is directed at the RX device connected immediately to the TX, the message is sent over the AUX channel. The read message will be divided into multiple transactions which read a maximum of 16 bytes each. The segment pointer is automatically incremented and the offset is calibrated as needed. E.g. For an overall offset of:<ul>
<li>128, an I2C read is done on segptr=0; offset=128.</li><li>256, an I2C read is done on segptr=1; offset=0.</li><li>384, an I2C read is done on segptr=1; offset=128.</li><li>512, an I2C read is done on segptr=2; offset=0.</li><li>etc.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset at the specified address of the targeted I2C device that the read will start from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToRead</em>&nbsp;</td><td>is the number of bytes to read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReadData</em>&nbsp;</td><td>is a pointer to a buffer that will be filled with the I2C read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C read has successfully completed with no errors.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_DATA_LOST if the requested number of BytesToRead does not equal that actually received.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="47cea5859706b6a888a7fb1b588da3c6"></a><!-- doxytag: member="xdp.h::XDp_TxRemoteIicWrite" ref="47cea5859706b6a888a7fb1b588da3c6" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicAddress, u8 BytesToWrite, u8 *WriteData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxRemoteIicWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>WriteData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function performs a remote I2C write by sending a sideband message. In case message is directed at the RX device connected immediately to the TX, the message is sent over the AUX channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicAddress</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToWrite</em>&nbsp;</td><td>is the number of bytes to write. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WriteData</em>&nbsp;</td><td>is a pointer to a buffer which will be used as the data source for the write.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the I2C write has successfully completed with no errors.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_DATA_LOST if the requested number of BytesToWrite does not equal that actually received.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="89c4158905d36c050a2f77cd70ebef11"></a><!-- doxytag: member="xdp.h::XDp_TxResetPhy" ref="89c4158905d36c050a2f77cd70ebef11" args="(XDp *InstancePtr, u32 Reset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxResetPhy           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Reset</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function does a PHY reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Reset</em>&nbsp;</td><td>is the type of reset to assert.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c5992df734aee9d237d02cb92003388"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgAllocatePayload" ref="6c5992df734aee9d237d02cb92003388" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 VcId, u16 Pbn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgAllocatePayload           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Pbn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send an ALLOCATE_PAYLOAD sideband message which will allocate bandwidth for a virtual channel in the payload ID tables of the downstream devices connecting the DisplayPort TX to the target device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VcId</em>&nbsp;</td><td>is the unique virtual channel ID to allocate into the payload ID tables. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Pbn</em>&nbsp;</td><td>is the payload bandwidth number that determines how much bandwidth will be allocated for the virtual channel.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>ALLOCATE_PAYLOAD is a path message that will be serviced by all downstream DisplayPort devices connecting the DisplayPort TX and the target device. </dd></dl>

</div>
</div><p>
<a class="anchor" name="080e95835c089e6995e3db4744173019"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgClearPayloadIdTable" ref="080e95835c089e6995e3db4744173019" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgClearPayloadIdTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send a CLEAR_PAYLOAD_ID_TABLE sideband message which will de-allocate all virtual channel payload ID tables.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>CLEAR_PAYLOAD_ID_TABLE is a broadcast message sent to all downstream devices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c08d3ad6aa95b172a0559eef622c59de"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgEnumPathResources" ref="c08d3ad6aa95b172a0559eef622c59de" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u16 *AvailPbn, u16 *FullPbn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgEnumPathResources           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>AvailPbn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>FullPbn</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send an ENUM_PATH_RESOURCES sideband message which will determine the available payload bandwidth number (PBN) for a path to a target device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AvailPbn</em>&nbsp;</td><td>is a pointer to the available PBN of the path whose value will be filled in by this function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FullPbn</em>&nbsp;</td><td>is a pointer to the total PBN of the path whose value will be filled in by this function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>ENUM_PATH_RESOURCES is a path message that will be serviced by all downstream DisplayPort devices connecting the DisplayPort TX and the target device. <p>
AvailPbn will be modified with the available PBN from the reply. <p>
FullPbn will be modified with the total PBN of the path from the reply. </dd></dl>

</div>
</div><p>
<a class="anchor" name="86609c6780646369e1ba37a50ded5b10"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgLinkAddress" ref="86609c6780646369e1ba37a50ded5b10" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, XDp_TxSbMsgLinkAddressReplyDeviceInfo *DeviceInfo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgLinkAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dp___tx_sb_msg_link_address_reply_device_info.html">XDp_TxSbMsgLinkAddressReplyDeviceInfo</a> *&nbsp;</td>
          <td class="paramname"> <em>DeviceInfo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send a LINK_ADDRESS sideband message to a target DisplayPort branch device. It is used to determine the resources available for that device and some device information for each of the ports connected to the branch device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort branch device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort branch device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceInfo</em>&nbsp;</td><td>is a pointer to the device information structure whose contents will be filled in with the information obtained by the LINK_ADDRESS sideband message.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>The contents of the DeviceInfo structure will be modified with the information obtained from the LINK_ADDRESS sideband message reply. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fce6a6d29a3ac432244022407d63a6f0"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgRemoteDpcdRead" ref="fce6a6d29a3ac432244022407d63a6f0" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToRead, u8 *ReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgRemoteDpcdRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DpcdAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ReadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send a REMOTE_DPCD_READ sideband message which will read from the specified DisplayPort Configuration Data (DPCD) address of a downstream DisplayPort device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DpcdAddress</em>&nbsp;</td><td>is the DPCD address of the target device that data will be read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToRead</em>&nbsp;</td><td>is the number of bytes to read from the specified DPCD address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReadData</em>&nbsp;</td><td>is a pointer to a buffer that will be filled with the DPCD read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_DATA_LOST if the requested number of BytesToRead does not equal that actually received.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0b7cf1a8fce1050a660092aa612da79d"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgRemoteDpcdWrite" ref="0b7cf1a8fce1050a660092aa612da79d" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 DpcdAddress, u32 BytesToWrite, u8 *WriteData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgRemoteDpcdWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DpcdAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>WriteData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send a REMOTE_DPCD_WRITE sideband message which will write some data to the specified DisplayPort Configuration Data (DPCD) address of a downstream DisplayPort device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DpcdAddress</em>&nbsp;</td><td>is the DPCD address of the target device that data will be written to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToWrite</em>&nbsp;</td><td>is the number of bytes to write to the specified DPCD address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WriteData</em>&nbsp;</td><td>is a pointer to a buffer that stores the data to write to the DPCD location.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c4648a54d9a5941c25dbfc2b9315e15"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgRemoteIicRead" ref="5c4648a54d9a5941c25dbfc2b9315e15" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicDeviceId, u8 Offset, u8 BytesToRead, u8 *ReadData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgRemoteIicRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicDeviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BytesToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ReadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send a REMOTE_I2C_READ sideband message which will read from the specified I2C address of a downstream DisplayPort device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicDeviceId</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Offset</em>&nbsp;</td><td>is the offset at the specified address of the targeted I2C device that the read will start from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToRead</em>&nbsp;</td><td>is the number of bytes to read from the I2C address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ReadData</em>&nbsp;</td><td>is a pointer to a buffer that will be filled with the I2C read data.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_DATA_LOST if the requested number of BytesToRead does not equal that actually received.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f896e53aeb519373f53b7cbf431d321"></a><!-- doxytag: member="xdp.h::XDp_TxSendSbMsgRemoteIicWrite" ref="2f896e53aeb519373f53b7cbf431d321" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u8 IicDeviceId, u8 BytesToWrite, u8 *WriteData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSendSbMsgRemoteIicWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IicDeviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>BytesToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>WriteData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will send a REMOTE_I2C_WRITE sideband message which will write to the specified I2C address of a downstream DisplayPort device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IicDeviceId</em>&nbsp;</td><td>is the address on the I2C bus of the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>BytesToWrite</em>&nbsp;</td><td>is the number of bytes to write to the I2C address. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>WriteData</em>&nbsp;</td><td>is a pointer to a buffer that will be written.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the reply to the sideband message was successfully obtained and it indicates an acknowledge.</li></ul>
</dd></dl>
<ul>
<li>XST_DEVICE_NOT_FOUND if no RX device is connected.<ul>
<li>XST_ERROR_COUNT_MAX if either waiting for a reply, or an AUX request timed out.</li><li>XST_FAILURE otherwise - if an AUX read or write transaction failed, the header or body CRC of the sideband message did not match the calculated value, or the a reply was negative acknowledged (NACK'ed).</li></ul>
</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="63402c58ed10a4c59aa0757970351fbe"></a><!-- doxytag: member="xdp.h::XDp_TxSetDownspread" ref="63402c58ed10a4c59aa0757970351fbe" args="(XDp *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSetDownspread           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables 0.5% spreading of the clock for both the DisplayPort and the RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will downspread the main link signal if set to 1 and disable downspreading if set to 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the downspread control enable was successful.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="266286fa19c4e031a7de23fab583ba4f"></a><!-- doxytag: member="xdp.h::XDp_TxSetEnhancedFrameMode" ref="266286fa19c4e031a7de23fab583ba4f" args="(XDp *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSetEnhancedFrameMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables the enhanced framing symbol sequence for both the DisplayPort TX core and the RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable enhanced frame mode if set to 1 and disable it if set to 0.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the enhanced frame mode enable was successful.</li><li>XST_DEVICE_NOT_FOUND if no RX is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f3915b9c29ed8a077adaed36e04622b4"></a><!-- doxytag: member="xdp.h::XDp_TxSetHasRedriverInPath" ref="f3915b9c29ed8a077adaed36e04622b4" args="(XDp *InstancePtr, u8 Set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetHasRedriverInPath           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Set</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets a software switch that signifies whether or not a redriver exists on the DisplayPort output path. XDp_TxSetVswingPreemp uses this switch to determine which set of voltage swing and pre-emphasis values to use in the TX core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Set</em>&nbsp;</td><td>establishes that a redriver exists in the DisplayPort output path.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="015d1109cc6a50a52f4bfee772eb6d38"></a><!-- doxytag: member="xdp.h::XDp_TxSetHpdEventHandler" ref="015d1109cc6a50a52f4bfee772eb6d38" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetHpdEventHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a hot-plug-detect event interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fd7cec8cb4c2a2470d5ab060017d9132"></a><!-- doxytag: member="xdp.h::XDp_TxSetHpdPulseHandler" ref="fd7cec8cb4c2a2470d5ab060017d9132" args="(XDp *InstancePtr, XDp_IntrHandler CallbackFunc, void *CallbackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetHpdPulseHandler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xdp_8h.html#986a09cc49fd7645fa11107cc25c453f">XDp_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>CallbackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallbackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function installs a callback function for when a hot-plug-detect pulse interrupt occurs.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackFunc</em>&nbsp;</td><td>is the address to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallbackRef</em>&nbsp;</td><td>is the user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2eee185e6b432dda6a7ab410b5e78541"></a><!-- doxytag: member="xdp.h::XDp_TxSetLaneCount" ref="2eee185e6b432dda6a7ab410b5e78541" args="(XDp *InstancePtr, u8 LaneCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSetLaneCount           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LaneCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the number of lanes to be used by the main link for both the DisplayPort TX core and the RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LaneCount</em>&nbsp;</td><td>is the number of lanes to be used over the main link.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the new lane count was successful.</li><li>XST_DEVICE_NOT_FOUND if no RX is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e01933583cbbbe16c3582d7440f10a2e"></a><!-- doxytag: member="xdp.h::XDp_TxSetLinkRate" ref="e01933583cbbbe16c3582d7440f10a2e" args="(XDp *InstancePtr, u8 LinkRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSetLinkRate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkRate</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the data rate to be used by the main link for both the DisplayPort TX core and the RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkRate</em>&nbsp;</td><td>is the link rate to be used over the main link based on one of the following selects:<ul>
<li>XDP_TX_LINK_BW_SET_162GBPS = 0x06 (for a 1.62 Gbps data rate)</li><li>XDP_TX_LINK_BW_SET_270GBPS = 0x0A (for a 2.70 Gbps data rate)</li><li>XDP_TX_LINK_BW_SET_540GBPS = 0x14 (for a 5.40 Gbps data rate)</li></ul>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the new link rate was successful.</li><li>XST_DEVICE_NOT_FOUND if no RX device is connected.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="123f88a702fe841a63f3d0a4bb7aaf09"></a><!-- doxytag: member="xdp.h::XDp_TxSetMsaValues" ref="123f88a702fe841a63f3d0a4bb7aaf09" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetMsaValues           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the main stream attributes registers of the DisplayPort TX core with the values specified in the main stream attributes configuration structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which to set the MSA values for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="aedf47a4635bd225559da3b5cc4c6ac0"></a><!-- doxytag: member="xdp.h::XDp_TxSetPhyPolarityAll" ref="aedf47a4635bd225559da3b5cc4c6ac0" args="(XDp *InstancePtr, u8 Polarity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetPhyPolarityAll           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Polarity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the PHY polarity on all lanes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Polarity</em>&nbsp;</td><td>is the value to set for the polarity (0 or 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The individual PHY polarity option will be disabled if set. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e829b18d0b930de7a7851172b2bd41bb"></a><!-- doxytag: member="xdp.h::XDp_TxSetPhyPolarityLane" ref="e829b18d0b930de7a7851172b2bd41bb" args="(XDp *InstancePtr, u8 Lane, u8 Polarity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetPhyPolarityLane           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Lane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Polarity</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the PHY polarity on a specified lane.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Lane</em>&nbsp;</td><td>is the lane number (0-3) to set the polarity for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Polarity</em>&nbsp;</td><td>is the value to set for the polarity (0 or 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>If individual lane polarity is used, it is recommended that this function is called for every lane in use. </dd></dl>

</div>
</div><p>
<a class="anchor" name="60da59209c30be099d00f0053a0e809d"></a><!-- doxytag: member="xdp.h::XDp_TxSetScrambler" ref="60da59209c30be099d00f0053a0e809d" args="(XDp *InstancePtr, u8 Enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDp_TxSetScrambler           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Enable</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function enables or disables scrambling of symbols for both the DisplayPort and the RX device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Enable</em>&nbsp;</td><td>will enable or disable scrambling.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if setting the scrambling enable was successful.</li><li>XST_FAILURE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b277199a6f1fefa04965a87a24173bad"></a><!-- doxytag: member="xdp.h::XDp_TxSetStreamSelectFromSinkList" ref="b277199a6f1fefa04965a87a24173bad" args="(XDp *InstancePtr, u8 Stream, u8 SinkNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetStreamSelectFromSinkList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>SinkNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will map a stream to a downstream DisplayPort TX device that is associated with a sink from the InstancePtr-&gt;TxInstance.Topology.SinkList.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream ID that will be mapped to a DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SinkNum</em>&nbsp;</td><td>is the sink ID in the sink list that will be mapped to the stream.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The contents of the InstancePtr-&gt;TxInstance. MstStreamConfig[Stream] will be modified. <p>
The topology will need to be determined prior to calling this function using the XDp_TxFindAccessibleDpDevices. </dd></dl>

</div>
</div><p>
<a class="anchor" name="70fa67f68567df53d33163b09e9bca77"></a><!-- doxytag: member="xdp.h::XDp_TxSetStreamSinkRad" ref="70fa67f68567df53d33163b09e9bca77" args="(XDp *InstancePtr, u8 Stream, u8 LinkCountTotal, u8 *RelativeAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetStreamSinkRad           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will map a stream to a downstream DisplayPort TX device determined by the relative address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number that will be mapped to a DisplayPort device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the total DisplayPort links connecting the DisplayPort TX to the targeted downstream device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the targeted DisplayPort device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The contents of the InstancePtr-&gt;TxInstance. MstStreamConfig[Stream] will be modified. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1c30da13f38cf02dc52a07347c99e71e"></a><!-- doxytag: member="xdp.h::XDp_TxSetVideoMode" ref="1c30da13f38cf02dc52a07347c99e71e" args="(XDp *InstancePtr, u8 Stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxSetVideoMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function clears the main stream attributes registers of the DisplayPort TX core and sets them to the values specified in the main stream attributes configuration structure.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Stream</em>&nbsp;</td><td>is the stream number for which to set the MSA values for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ca9c95087f08d94d156873946712649"></a><!-- doxytag: member="xdp.h::XDp_TxTopologySortSinksByTiling" ref="7ca9c95087f08d94d156873946712649" args="(XDp *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxTopologySortSinksByTiling           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Order the sink list with all sinks of the same tiled display being sorted by 'tile order'. Refer to the XDp_TxGetDispIdTdtTileOrder macro on how to determine the 'tile order'. Sinks of a tiled display will have an index in the sink list that is lower than all indices of other sinks within that same tiled display that have a greater 'tile order'. When operations are done on the sink list, this ordering will ensure that sinks within the same tiled display will be acted upon in a consistent manner - with an incrementing sink list index, sinks with a lower 'tile order' will be acted upon first relative to the other sinks in the same tiled display. Multiple tiled displays may exist in the sink list.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4a28e8ab8abf429af41a27ea2b9323f9"></a><!-- doxytag: member="xdp.h::XDp_TxTopologySwapSinks" ref="4a28e8ab8abf429af41a27ea2b9323f9" args="(XDp *InstancePtr, u8 Index0, u8 Index1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxTopologySwapSinks           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Index1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Swap the ordering of the sinks in the topology's sink list. All sink information is preserved in the node table - the swapping takes place only on the pointers to the sinks in the node table. The reason this swapping is done is so that functions that use the sink list will act on the sinks in a different order.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index0</em>&nbsp;</td><td>is the sink list's index of one of the sink pointers to be swapped. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Index1</em>&nbsp;</td><td>is the sink list's index of the other sink pointer to be swapped.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6b1d94c567787ac3bd900d90dcd96a82"></a><!-- doxytag: member="xdp.h::XDp_TxWriteGuid" ref="6b1d94c567787ac3bd900d90dcd96a82" args="(XDp *InstancePtr, u8 LinkCountTotal, u8 *RelativeAddress, u32 Guid[4])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_TxWriteGuid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>LinkCountTotal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RelativeAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Guid</em>[4]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will write a global unique identifier (GUID) to the target DisplayPort device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>LinkCountTotal</em>&nbsp;</td><td>is the number of DisplayPort links from the DisplayPort source to the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RelativeAddress</em>&nbsp;</td><td>is the relative address from the DisplayPort source to the target device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Guid</em>&nbsp;</td><td>is a the GUID to write to the target device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="82deff65c3a8f1a090bcda332df3a7ee"></a><!-- doxytag: member="xdp.h::XDp_WaitUs" ref="82deff65c3a8f1a090bcda332df3a7ee" args="(XDp *InstancePtr, u32 MicroSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDp_WaitUs           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dp.html">XDp</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>MicroSeconds</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the delay/sleep function for the <a class="el" href="struct_x_dp.html">XDp</a> driver. For the Zynq family, there exists native sleep functionality. For MicroBlaze however, there does not exist such functionality. In the MicroBlaze case, the default method for delaying is to use a predetermined amount of loop iterations. This method is prone to inaccuracy and dependent on system configuration; for greater accuracy, the user may supply their own delay/sleep handler, pointed to by InstancePtr-&gt;UserTimerWaitUs, which may have better accuracy if a hardware timer is used.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dp.html">XDp</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MicroSeconds</em>&nbsp;</td><td>is the number of microseconds to delay/sleep for.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
Copyright @ 1995-2015 Xilinx, Inc. All rights reserved.
