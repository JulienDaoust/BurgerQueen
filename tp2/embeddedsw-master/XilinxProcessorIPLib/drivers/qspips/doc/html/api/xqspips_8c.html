<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xqspips.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.5 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xqspips.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Contains implements the interface functions of the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> driver. See xqspips.h for a detailed description of the device and driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who Date     Changes
 ----- --- -------- -----------------------------------------------
 1.00  sdm 11/25/10 First release
 2.00a kka 07/25/12 Removed XQspiPs_GetWriteData API.
		     The XQspiPs_SetSlaveSelect has been modified to remove
		     the argument of the slave select as the QSPI controller
		     only supports one slave.
 		     XQspiPs_GetSlaveSelect API has been removed
 		     Added logic to XQspiPs_GetReadData to handle data
		     shift for normal data reads and instruction/status
		     reads differently based on the ShiftReadData flag.
 		     Removed the selection for the following options:
		     Master mode (XQSPIPS_MASTER_OPTION) and
		     Flash interface mode (XQSPIPS_FLASH_MODE_OPTION) option
		     as the QSPI driver supports the Master mode
		     and Flash Interface mode and doesnot support
		     Slave mode or the legacy mode.
		     Modified the XQspiPs_PolledTransfer and XQspiPs_Transfer
		     APIs so that the last argument (IsInst) specifying whether
		     it is instruction or data has been removed. The first byte
		     in the SendBufPtr argument of these APIs specify the
		     instruction to be sent to the Flash Device.
		     The XQspiPs_PolledTransfer function has been updated
		     to fill the data to fifo depth.
		     This version of the driver fixes CRs 670197/663787.
 2.01a sg  02/03/13 Added flash opcodes for DUAL_IO_READ,QUAD_IO_READ.
		     Created macros XQspiPs_IsManualStart and
		     XQspiPs_IsManualChipSelect.
		     Changed QSPI transfer logic for polled and interrupt
		     modes to be based on filled tx fifo count and receive
		     based on it. RXNEMPTY interrupt is not used.
		     Added assertions to XQspiPs_LqspiRead function.</pre><p>
<pre> 2.02a hk  05/14/13 Added enable and disable to the <a class="el" href="xqspips_8c.html#4153b7e9b6f54d80085f7ad187150649">XQspiPs_LqspiRead()</a>
			 function
            Added instructions for bank selection, die erase and
            flag status register to the flash instruction table
            Handling for instructions not in flash instruction
			 table added. Checking for Tx FIFO empty when switching from
			 TXD1/2/3 to TXD0 added. If WRSR instruction is sent with
            byte count 3 (spansion), instruction size and TXD register
			 changed accordingly. CR# 712502 and 703869.
            Added (ifdef linear base address) in the Linear read function.
            Changed  XPAR_XQSPIPS_0_LINEAR_BASEADDR to
            XPAR_PS7_QSPI_LINEAR_0_S_AXI_BASEADDR in
            XQspiPs_LqspiRead function. Fix for CR#718141</pre><p>
<pre> 2.03a hk  09/05/13 Modified polled and interrupt transfers to make use of
                    thresholds. This is to improve performance.
                    Added RX and TX threshold reset to one in XQspiPs_Abort.
                    Added RX threshold reset(1) after transfer in polled and
                    interrupt transfers. Made changes to make sure threshold
                    change is done only when no transfer is in progress.</pre><p>
<pre> </pre> 
<p>
<code>#include &quot;xqspips.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_qspi_ps_inst_format.html">XQspiPsInstFormat</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#69467f58b91c68df59575a522c5aca34">XQspiPs_CfgInitialize</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr, <a class="el" href="struct_x_qspi_ps___config.html">XQspiPs_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#584ce23b113278dab3f6d0a8afa2e043">XQspiPs_Reset</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#68d0be250f02b437ac6512b028e6cfca">XQspiPs_Abort</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#909fe8801464653cb8fbc9317c29d19a">XQspiPs_Transfer</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#144b518850ced0514e20bf5959d2b048">XQspiPs_PolledTransfer</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#4153b7e9b6f54d80085f7ad187150649">XQspiPs_LqspiRead</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr, u8 *RecvBufPtr, u32 Address, unsigned ByteCount)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#f283dc63facf3cf5fc1a529a15cb033c">XQspiPs_SetSlaveSelect</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#404836890740b94141d7fb1d2ed18f60">XQspiPs_SetStatusHandler</a> (<a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *InstancePtr, void *CallBackRef, XQspiPs_StatusHandler FuncPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xqspips_8c.html#74d652c80c4016e67d95cb1f14dcd310">XQspiPs_InterruptHandler</a> (void *InstancePtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="68d0be250f02b437ac6512b028e6cfca"></a><!-- doxytag: member="xqspips.c::XQspiPs_Abort" ref="68d0be250f02b437ac6512b028e6cfca" args="(XQspiPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XQspiPs_Abort           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Aborts a transfer in progress by disabling the device and flush the RxFIFO. The byte counts are cleared, the busy flag is cleared.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function does a read/modify/write of the config register. The user of this function needs to take care of critical sections.     </td>
  </tr>
</table>
<a class="anchor" name="69467f58b91c68df59575a522c5aca34"></a><!-- doxytag: member="xqspips.c::XQspiPs_CfgInitialize" ref="69467f58b91c68df59575a522c5aca34" args="(XQspiPs *InstancePtr, XQspiPs_Config *ConfigPtr, u32 EffectiveAddr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XQspiPs_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_qspi_ps___config.html">XQspiPs_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initializes a specific <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance such that the driver is ready to use.<p>
The state of the device after initialization is:<ul>
<li>Master mode</li><li>Active high clock polarity</li><li>Clock phase 0</li><li>Baud rate divisor 2</li><li>Transfer width 32</li><li>Master reference clock = pclk</li><li>No chip select active</li><li>Manual CS and Manual Start disabled</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a reference to a structure containing information about a specific QSPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use ConfigPtr-&gt;Config.BaseAddress for this device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li><li>XST_DEVICE_IS_STARTED if the device is already started. It must be stopped to re-initialize.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="74d652c80c4016e67d95cb1f14dcd310"></a><!-- doxytag: member="xqspips.c::XQspiPs_InterruptHandler" ref="74d652c80c4016e67d95cb1f14dcd310" args="(void *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XQspiPs_InterruptHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The interrupt handler for QSPI interrupts. This function must be connected by the user to an interrupt controller.<p>
The interrupts that are handled are:<p>
<ul>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until the transfer is done.</li></ul>
<p>
<ul>
<li>Data Transmit Register (FIFO) Underflow. This interrupt is generated when the QSPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<ul>
<li>Data Receive Register (FIFO) Overflow. This interrupt is generated when the QSPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The slave select register is being set to deselect the slave when a transfer is complete.     </td>
  </tr>
</table>
<a class="anchor" name="4153b7e9b6f54d80085f7ad187150649"></a><!-- doxytag: member="xqspips.c::XQspiPs_LqspiRead" ref="4153b7e9b6f54d80085f7ad187150649" args="(XQspiPs *InstancePtr, u8 *RecvBufPtr, u32 Address, unsigned ByteCount)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XQspiPs_LqspiRead           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Address</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read the flash in Linear QSPI mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer for received data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>is the starting address within the flash from from where data needs to be read. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to receive.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if read is performed</li><li>XST_FAILURE if Linear mode is not set</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="144b518850ced0514e20bf5959d2b048"></a><!-- doxytag: member="xqspips.c::XQspiPs_PolledTransfer" ref="144b518850ced0514e20bf5959d2b048" args="(XQspiPs *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XQspiPs_PolledTransfer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transfers specified data on the QSPI bus in polled mode.<p>
The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: <pre>
   XQspiPs_PolledTransfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><p>
<pre>   XQspiPs_PolledTransfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><p>
<pre>   XQspiPs_PolledTransfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><p>
<pre>   XQspiPs_PolledTransfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends.  The device must send N bytes of data if it wishes to
	receive N bytes of data.</pre><p>
<pre> </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a data buffer that needs to be transmitted. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer for received data. This argument can be NULL if do not care about receiving. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the buffers are successfully handed off to the device for transfer.</li><li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the QSPI bus at the same time.     </td>
  </tr>
</table>
<a class="anchor" name="584ce23b113278dab3f6d0a8afa2e043"></a><!-- doxytag: member="xqspips.c::XQspiPs_Reset" ref="584ce23b113278dab3f6d0a8afa2e043" args="(XQspiPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XQspiPs_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resets the QSPI device. Reset must only be called after the driver has been initialized. Any data transfer that is in progress is aborted.<p>
The upper layer software is responsible for re-configuring (if necessary) and restarting the QSPI device after the reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="f283dc63facf3cf5fc1a529a15cb033c"></a><!-- doxytag: member="xqspips.c::XQspiPs_SetSlaveSelect" ref="f283dc63facf3cf5fc1a529a15cb033c" args="(XQspiPs *InstancePtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XQspiPs_SetSlaveSelect           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Selects the slave with which the master communicates.<p>
The user is not allowed to select the slave while a transfer is in progress.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li><li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the QSPI is idle.     </td>
  </tr>
</table>
<a class="anchor" name="404836890740b94141d7fb1d2ed18f60"></a><!-- doxytag: member="xqspips.c::XQspiPs_SetStatusHandler" ref="404836890740b94141d7fb1d2ed18f60" args="(XQspiPs *InstancePtr, void *CallBackRef, XQspiPs_StatusHandler FuncPtr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XQspiPs_SetStatusHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>XQspiPs_StatusHandler&nbsp;</td>
          <td class="mdname" nowrap> <em>FuncPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to upper layer software. The handler executes in an interrupt context, so it must minimize the amount of processing performed. One of the following status events is passed to the status handler.<p>
<pre></pre><p>
<pre> XST_SPI_TRANSFER_DONE		The requested data transfer is done</pre><p>
<pre> XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked data
				but there were none available in the transmit
				register/FIFO. This typically means the slave
				application did not issue a transfer request
				fast enough, or the processor/driver could not
				fill the transmit register/FIFO fast enough.</pre><p>
<pre> XST_SPI_RECEIVE_OVERRUN	The QSPI device lost data. Data was received
				but the receive data register/FIFO was full.</pre><p>
<pre> </pre> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The handler is called within interrupt context, so it should do its work quickly and queue potentially time-consuming work to a task-level thread.     </td>
  </tr>
</table>
<a class="anchor" name="909fe8801464653cb8fbc9317c29d19a"></a><!-- doxytag: member="xqspips.c::XQspiPs_Transfer" ref="909fe8801464653cb8fbc9317c29d19a" args="(XQspiPs *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned ByteCount)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int XQspiPs_Transfer           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8 *&nbsp;</td>
          <td class="mdname" nowrap> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>unsigned&nbsp;</td>
          <td class="mdname" nowrap> <em>ByteCount</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Transfers specified data on the QSPI bus. Initiates bus communication and sends/receives data to/from the selected QSPI slave. For every byte sent, a byte is received.<p>
The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: <pre>
   XQspiPs_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><p>
<pre>   XQspiPs_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><p>
<pre>   XQspiPs_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><p>
<pre>   XQspiPs_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends.  The device must send N bytes of data if it wishes to
	receive N bytes of data.
 </pre> Although this function takes entire buffers as arguments, the driver can only transfer a limited number of bytes at a time, limited by the size of the FIFO. A call to this function only starts the transfer, then subsequent transfers of the data is performed by the interrupt service routine until the entire buffer has been transferred. The status callback function is called when the entire buffer has been sent/received.<p>
This function is non-blocking. The SetSlaveSelect function must be called prior to this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_qspi_ps.html">XQspiPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a data buffer that needs to be transmitted. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer for received data. This argument can be NULL if do not care about receiving. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the buffers are successfully handed off to the device for transfer.</li><li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the QSPI bus at the same time.     </td>
  </tr>
</table>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
