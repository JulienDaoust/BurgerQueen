<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xaxiethernet.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xaxiethernet.h File Reference</h1>
<p>
<code>#include &quot;xenv.h&quot;</code><br>
<code>#include &quot;xstatus.h&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xaxiethernet__hw_8h.html">xaxiethernet_hw.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a></td></tr>

<tr><td colspan="2"><br><h2>Configuration options</h2></td></tr>
<tr><td colspan="2">The following are device configuration options. See the <em>XAxiEthernet_SetOptions</em>, <em>XAxiEthernet_ClearOptions</em> and <em>XAxiEthernet_GetOptions</em> routines for information on how to use options.<p>
The default state of the options are also noted below. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#85d541107aad56649d63d548813e1091">XAE_PROMISC_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#0c81a1ba1412a469773217a168902aa2">XAE_JUMBO_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#aacd508700a0767d156cf47e71e1ea76">XAE_VLAN_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ce9786d16960daabfdb803388b4ff0f3">XAE_FLOW_CONTROL_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#e274295c74b82214342722ee5b5d9392">XAE_FCS_STRIP_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#9b828349795f783755ab6fd9413f6ff9">XAE_FCS_INSERT_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#7f163c38fd07679c8a358c843a52f19e">XAE_LENTYPE_ERR_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000040</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#1e81b6f5f677ed0370507c117b565b20">XAE_TRANSMITTER_ENABLE_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000080</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#027d60f8fd28b519cad51e450b71c07b">XAE_RECEIVER_ENABLE_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000100</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ed55b7962f8aab228e2c41be4154a834">XAE_BROADCAST_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000200</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#bf6e17b27602db32c134aaf5afdd33dd">XAE_MULTICAST_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000400</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#200a4ee26fb655cce6de8edc7a3cc6b9">XAE_EXT_MULTICAST_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000800</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#a8451191982023f578cda79fca48b190">XAE_EXT_TXVLAN_TRAN_OPTION</a>&nbsp;&nbsp;&nbsp;0x00001000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#1cef34ccc21b501cf2f5d0efe22392bd">XAE_EXT_RXVLAN_TRAN_OPTION</a>&nbsp;&nbsp;&nbsp;0x00002000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b4a430ee8f463578c6d55f527a56cd0b">XAE_EXT_TXVLAN_TAG_OPTION</a>&nbsp;&nbsp;&nbsp;0x00004000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#fd0f2f2b21a02e3b8c8a11a86085c0c4">XAE_EXT_RXVLAN_TAG_OPTION</a>&nbsp;&nbsp;&nbsp;0x00008000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2957a816e7ff90ff5d53bfe30eb7bfec">XAE_EXT_TXVLAN_STRP_OPTION</a>&nbsp;&nbsp;&nbsp;0x00010000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#d5ddc37c61d5f484d5eb541218bf7429">XAE_EXT_RXVLAN_STRP_OPTION</a>&nbsp;&nbsp;&nbsp;0x00020000</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#71e31b002d0e8c019bad31fc22b21c8e">XAE_DEFAULT_OPTIONS</a></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#bf9a1c5aa83b9ea9dde1fc701d088de4">XAXIETHERNET_H</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#8275681d6099aeb497580d8c3ef6ce3e">XAE_MULTI_MAT_ENTRIES</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#484436248277bbcece62a29c8789cf43">XAE_MDIO_DIV_DFT</a>&nbsp;&nbsp;&nbsp;29</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#39d26bcf35e735803e47fe67ad623ddd">XAE_MAC_ADDR_SIZE</a>&nbsp;&nbsp;&nbsp;6</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#16a49d47cbdf8e84658587ab3dc321ba">XAE_MTU</a>&nbsp;&nbsp;&nbsp;1500</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#13bb35c49061f25927af2930f2c5f10c">XAE_JUMBO_MTU</a>&nbsp;&nbsp;&nbsp;8982</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c4a5559d3b5abff1af1516f98b9d9749">XAE_HDR_SIZE</a>&nbsp;&nbsp;&nbsp;14</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#dd8df5928f5a322246ffcce9750a9442">XAE_HDR_VLAN_SIZE</a>&nbsp;&nbsp;&nbsp;18</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#cba30b0be35698c11eb103a31cd43d36">XAE_TRL_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#050af72e3d42870ff4da0f7d3511a768">XAE_MAX_FRAME_SIZE</a>&nbsp;&nbsp;&nbsp;(XAE_MTU + XAE_HDR_SIZE + XAE_TRL_SIZE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#026a07802956bbf92ecea0326be28a12">XAE_MAX_VLAN_FRAME_SIZE</a>&nbsp;&nbsp;&nbsp;(XAE_MTU + XAE_HDR_VLAN_SIZE + XAE_TRL_SIZE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#aa1d4a2c37669bd618cf201b505c73e4">XAE_MAX_JUMBO_FRAME_SIZE</a>&nbsp;&nbsp;&nbsp;(XAE_JUMBO_MTU + XAE_HDR_SIZE + XAE_TRL_SIZE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#4ac0ca7b46aa8c67b25a96f39517c69d">XAE_PHY_TYPE_MII</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#043115e2c3d919eb1acaddc361f28ff7">XAE_PHY_TYPE_GMII</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#23aa3d4dc1966f51828b1f10e3785e40">XAE_PHY_TYPE_RGMII_1_3</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6b78dfcbcf5ec2752c092c102b6e1f29">XAE_PHY_TYPE_RGMII_2_0</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#1ac7731fa009b34277258f5691fabd34">XAE_PHY_TYPE_SGMII</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#82ebee74425e2075c7946217ac1da504">XAE_PHY_TYPE_1000BASE_X</a>&nbsp;&nbsp;&nbsp;5</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ab704e33f806e844b0978c23729d23a3">XAE_TPID_MAX_ENTRIES</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c4d258f46096316458c83f93aa546b05">XAE_VTAG_NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2ca8aa2e2c5fc1906c59c130466e51af">XAE_VTAG_ALL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#7c0862c33dbb447dbf24503faf13e6ed">XAE_VTAG_EXISTED</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#fa30034861eb0242b65ed65bd3ebe813">XAE_VTAG_SELECT</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ad800257af91fd7ad73fc65905325486">XAE_DEFAULT_TXVTAG_MODE</a>&nbsp;&nbsp;&nbsp;XAE_VTAG_ALL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#34a659ff3b425eb6995e9ea35156e275">XAE_DEFAULT_RXVTAG_MODE</a>&nbsp;&nbsp;&nbsp;XAE_VTAG_ALL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#acd260b8f206af87b18f1b71d4b8427e">XAE_VSTRP_NONE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c1e4f255f237002ef89f3bc0f7ac6435">XAE_VSTRP_ALL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#bf516cd3159320e0c799ff40040552ce">XAE_VSTRP_SELECT</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2d1b179c6d63265c6a8d8f6b4575bc06">XAE_DEFAULT_TXVSTRP_MODE</a>&nbsp;&nbsp;&nbsp;XAE_VSTRP_ALL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#96fb69c0d6db49740731b5e2b9cc04c4">XAE_DEFAULT_RXVSTRP_MODE</a>&nbsp;&nbsp;&nbsp;XAE_VSTRP_ALL</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#171dca954a974c164fe82fdb3736d6d2">XAE_RX</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#a451942ad49082bf76752438e3c167c9">XAE_TX</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#7969c4f16ffd611a8562aa53b8b238d8">XAE_SOFT_TEMAC_10_100_MBPS</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#0fcf8494f98bdf4395e204d1cee8324e">XAE_SOFT_TEMAC_10_100_1000_MBPS</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c23f3851430f7ea598c544f6afd85e79">XAE_HARD_TEMC</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6c513f6bb939a705f56da5c826d9ec63">XAxiEthernet_IsStarted</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;IsStarted == XIL_COMPONENT_IS_STARTED) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6fa193e8b9cf3c2807d328829903bf6c">XAxiEthernet_IsDma</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.AxiDevType == XPAR_AXI_DMA) ? TRUE: FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#aedd2fe4a2b3d24152c3f32160e8f994">XAxiEthernet_IsFifo</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.AxiDevType == XPAR_AXI_FIFO) ? TRUE: FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ce643555d4c75d40b1ddee9dbd814a74">XAxiEthernet_AxiDevBaseAddress</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;Config.AxiDevBaseAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#e5c91a283a8b79c5e0735588ed8064ec">XAxiEthernet_IsRecvFrameDropped</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#e21c088294f79359ed1ee74468100e9a">XAxiEthernet_IsRxPartialCsum</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.RxCsum) == 0x01) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6e44788bbc239e6cea83d1e07ddb65ed">XAxiEthernet_IsTxPartialCsum</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.TxCsum) == 0x01) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#70ae7bc7e8d22aa1c7be7076c83d4015">XAxiEthernet_IsRxFullCsum</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.RxCsum) == 0x02) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#8d1defd403ed40f023650e1e44651c88">XAxiEthernet_IsTxFullCsum</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.TxCsum) == 0x02) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#dc2cf9ec186f1dffaece1552f96fcdd9">XAxiEthernet_GetPhysicalInterface</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;Config.PhyType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#56664c785ad43b4458a1109d3a5b3bc5">XAxiEthernet_GetIntStatus</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XAxiEthernet_ReadReg((InstancePtr)-&gt;Config.BaseAddress, XAE_IS_OFFSET)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b5476b0e04b0ecd8f9fd027f90ea648f">XAxiEthernet_IntEnable</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6357e97582bc0e064c5b169d212e41df">XAxiEthernet_IntDisable</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#492b674e8d7584ed5e73e2b1a886bcc3">XAxiEthernet_IntPending</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XAxiEthernet_ReadReg((InstancePtr)-&gt;Config.BaseAddress, XAE_IP_OFFSET)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#aaef83a7f1fe4d8ca117cf6bc80500a8">XAxiEthernet_IntClear</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#51c2a30cc98f11355ce3639139b41d8a">XAxiEthernet_IsExtFuncCap</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b62015adb15bebd496a5346e3877af55">XAxiEthernet_IsExtMcastEnable</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#751c51d9ed918ca9dd556d98187eb76e">XAxiEthernet_IsExtMcast</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.ExtMcast) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#92ea2563addd13a5d3008a0bd9d069bc">XAxiEthernet_IsTxVlanStrp</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.TxVlanStrp) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#4764b3156c37e0b505c4df69b105b770">XAxiEthernet_IsRxVlanStrp</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.RxVlanStrp) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ac1bbeb5294915665aae439a33e3b887">XAxiEthernet_IsTxVlanTran</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.TxVlanTran) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#04ad5f292476ee8d62a2cacc66bf8767">XAxiEthernet_IsRxVlanTran</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.RxVlanTran) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2d75475a1e85f44562fd614960744b23">XAxiEthernet_IsTxVlanTag</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.TxVlanTag) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#16debcb3a008c09bc8c4e29764310cae">XAxiEthernet_IsRxVlanTag</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.RxVlanTag) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6ee4e2b95cc8d84e227f51e28ff07901">XAxiEthernet_GetTemacType</a>(InstancePtr)&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;Config.TemacType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#a09f91114abaefee6e94e8a5f48923e7">XAxiEthernet_IsAvbConfigured</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.Avb) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#f20d2f840ee7c6defacb6e1a478b38a7">XAxiEthernet_IsSgmiiOverLvdsEnabled</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.EnableSgmiiOverLvds) ? TRUE : FALSE)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2e75a48d11c00b0c39339bd2f2461bdc">XAxiEthernet_IsStatsConfigured</a>(InstancePtr)&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.Stats) ? TRUE : FALSE)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#cfb6c81216c79e4a3a307448e9f60be0">XAxiEthernet_CfgInitialize</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, <a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a> *CfgPtr, u32 VirtualAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2cfa48d42e55238f6f30aff6d658e4fe">XAxiEthernet_Start</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#4e952a55f342f176ba9ec2b49e2e47cb">XAxiEthernet_Stop</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#091a291d11f394e3eaf0b79195666d9f">XAxiEthernet_Reset</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b25ee3d4c048dccce6e97f59529ed2c3">XAxiEthernet_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#e3265620b9d9b86643abe5ff5e2b7d79">XAxiEthernet_SetOptions</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#d3e7253d626c02a96ac35f981ac11ba2">XAxiEthernet_ClearOptions</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#f48b8f321b842bfb139b473ad7185874">XAxiEthernet_GetOptions</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b2298b2b1af89cf0f0a78d4fda03ed7f">XAxiEthernet_SetMacAddress</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#a5b70a456ac18505132f61f596428ab7">XAxiEthernet_GetMacAddress</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#99c4e06d4db500ab7bf6bc20853330e2">XAxiEthernet_SetMacPauseAddress</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#369290833088c56abf0a967f16233266">XAxiEthernet_GetMacPauseAddress</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#e513f052386deaf8c5994b768f9647ce">XAxiEthernet_SendPausePacket</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 PauseValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b7d57eaf1bb97c34a92cc5e2c8600075">XAxiEthernet_GetSgmiiStatus</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 *SpeedPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#de4816d9067e13fbac2ceb66cf32360d">XAxiEthernet_GetRgmiiStatus</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 *SpeedPtr, int *IsFullDuplexPtr, int *IsLinkUpPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#8e8caa9c4ac753744bd08ebf103877c3">XAxiEthernet_GetOperatingSpeed</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b2d0106f26a1a2e1f2b902dc0a2822c9">XAxiEthernet_SetOperatingSpeed</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 Speed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#3db57c4a261afc854985297afed2373b">XAxiEthernet_SetBadFrmRcvOption</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#ab45f6c7a4440bc3f58d4ff971e6be7b">XAxiEthernet_ClearBadFrmRcvOption</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#41049ca22799d42d1279461be627c72e">XAxiEthernet_DisableControlFrameLenCheck</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#8b71bcdc8be6ae5d6364c59ea0f53aab">XAxiEthernet_EnableControlFrameLenCheck</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2b33bc77237bf039c02d4619a811aed6">XAxiEthernet_PhySetMdioDivisor</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u8 Divisor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6dc70adcb2c07eb801facc8e2243ea98">XAxiEthernet_PhyRead</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#9394dd066a7497ed9346b26457c28247">XAxiEthernet_PhyWrite</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c186de218bc1df3afe9e1c91c6b749b6">XAxiEthernet_MulticastAdd</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c95ba7bcd0c537eec1787f5ea49488df">XAxiEthernet_MulticastGet</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#1db86bd14ba6b769f6fdf34c0e277c10">XAxiEthernet_MulticastClear</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#2d692528035485610c1bbf6e3fbb4a84">XAxiEthernet_SetTpid</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 Tpid, u8 Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#338bb9b51764235ed6969faa58503455">XAxiEthernet_ClearTpid</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u8 Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#498bdb032a67313102ac7dee10ae8e7e">XAxiEthernet_GetTpid</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 *TpidPtr, u8 Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#44f51417734b0ca355da2e87a67aa0a3">XAxiEthernet_SetVTagMode</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Mode, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#9d375eb39bb3a8f724123aa9a9585e47">XAxiEthernet_GetVTagMode</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u8 *ModePtr, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#95198cfb6e93a13c115c7c6610a68ded">XAxiEthernet_SetVStripMode</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Mode, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#fb2a0cbe2263410d25caa0e87428a6d7">XAxiEthernet_GetVStripMode</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u8 *ModePtr, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#43d59456dc8e08f671745c70e48e9a59">XAxiEthernet_SetVTagValue</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 VTagValue, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#00d242e51aeec92bf07528bbf58709ea">XAxiEthernet_GetVTagValue</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 *VTagValuePtr, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#4f860a127fcc5756c2dc62337eb1b934">XAxiEthernet_SetVidTable</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Entry, u32 Vid, u8 Strip, u8 Tag, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b13721145a4632d987bd858483c00011">XAxiEthernet_GetVidTable</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Entry, u32 *VidPtr, u8 *StripPtr, u8 *TagPtr, int Dir)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#c6e848552b34aa85f6801ab269521cf3">XAxiEthernet_AddExtMulticastGroup</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#b4a3a1fdf74706efe50812be6ec78839">XAxiEthernet_ClearExtMulticastGroup</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#6932bd79a08811085a47ad1357a4ef89">XAxiEthernet_GetExtMulticastGroup</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8h.html#08b7db7c5a837de18afceb58230351b3">XAxiEthernet_DumpExtMulticastGroup</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="ed55b7962f8aab228e2c41be4154a834"></a><!-- doxytag: member="xaxiethernet.h::XAE_BROADCAST_OPTION" ref="ed55b7962f8aab228e2c41be4154a834" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_BROADCAST_OPTION&nbsp;&nbsp;&nbsp;0x00000200          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_MULTICAST_OPTION specifies the Axi Ethernet device to receive frames sent to Ethernet addresses that are programmed into the Multicast Address Table (MAT). This driver sets this option to disabled (cleared) by default.
</div>
</div><p>
<a class="anchor" name="71e31b002d0e8c019bad31fc22b21c8e"></a><!-- doxytag: member="xaxiethernet.h::XAE_DEFAULT_OPTIONS" ref="71e31b002d0e8c019bad31fc22b21c8e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_DEFAULT_OPTIONS          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xaxiethernet_8h.html#ce9786d16960daabfdb803388b4ff0f3">XAE_FLOW_CONTROL_OPTION</a> |              \
                 <a class="code" href="xaxiethernet_8h.html#ed55b7962f8aab228e2c41be4154a834">XAE_BROADCAST_OPTION</a> |                 \
                 <a class="code" href="xaxiethernet_8h.html#9b828349795f783755ab6fd9413f6ff9">XAE_FCS_INSERT_OPTION</a> |                \
                 <a class="code" href="xaxiethernet_8h.html#e274295c74b82214342722ee5b5d9392">XAE_FCS_STRIP_OPTION</a> |                 \
                 <a class="code" href="xaxiethernet_8h.html#7f163c38fd07679c8a358c843a52f19e">XAE_LENTYPE_ERR_OPTION</a> |               \
                 <a class="code" href="xaxiethernet_8h.html#1e81b6f5f677ed0370507c117b565b20">XAE_TRANSMITTER_ENABLE_OPTION</a> |        \
                 <a class="code" href="xaxiethernet_8h.html#027d60f8fd28b519cad51e450b71c07b">XAE_RECEIVER_ENABLE_OPTION</a>)
</pre></div>XAE_DEFAULT_OPTIONS specify the options set in <a class="el" href="xaxiethernet_8c.html#091a291d11f394e3eaf0b79195666d9f">XAxiEthernet_Reset()</a> and <a class="el" href="xaxiethernet_8c.html#73871df4ff59ae908c63c51db94f1a90">XAxiEthernet_CfgInitialize()</a>
</div>
</div><p>
<a class="anchor" name="96fb69c0d6db49740731b5e2b9cc04c4"></a><!-- doxytag: member="xaxiethernet.h::XAE_DEFAULT_RXVSTRP_MODE" ref="96fb69c0d6db49740731b5e2b9cc04c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_DEFAULT_RXVSTRP_MODE&nbsp;&nbsp;&nbsp;XAE_VSTRP_ALL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="34a659ff3b425eb6995e9ea35156e275"></a><!-- doxytag: member="xaxiethernet.h::XAE_DEFAULT_RXVTAG_MODE" ref="34a659ff3b425eb6995e9ea35156e275" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_DEFAULT_RXVTAG_MODE&nbsp;&nbsp;&nbsp;XAE_VTAG_ALL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2d1b179c6d63265c6a8d8f6b4575bc06"></a><!-- doxytag: member="xaxiethernet.h::XAE_DEFAULT_TXVSTRP_MODE" ref="2d1b179c6d63265c6a8d8f6b4575bc06" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_DEFAULT_TXVSTRP_MODE&nbsp;&nbsp;&nbsp;XAE_VSTRP_ALL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ad800257af91fd7ad73fc65905325486"></a><!-- doxytag: member="xaxiethernet.h::XAE_DEFAULT_TXVTAG_MODE" ref="ad800257af91fd7ad73fc65905325486" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_DEFAULT_TXVTAG_MODE&nbsp;&nbsp;&nbsp;XAE_VTAG_ALL          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="200a4ee26fb655cce6de8edc7a3cc6b9"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_MULTICAST_OPTION" ref="200a4ee26fb655cce6de8edc7a3cc6b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_MULTICAST_OPTION&nbsp;&nbsp;&nbsp;0x00000800          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_TXVLAN_TRAN_OPTION specifies the Axi Ethernet device to enable transmit VLAN translation. This driver sets this option to be dependent on HW configuration by default.
</div>
</div><p>
<a class="anchor" name="d5ddc37c61d5f484d5eb541218bf7429"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_RXVLAN_STRP_OPTION" ref="d5ddc37c61d5f484d5eb541218bf7429" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_RXVLAN_STRP_OPTION&nbsp;&nbsp;&nbsp;0x00020000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fd0f2f2b21a02e3b8c8a11a86085c0c4"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_RXVLAN_TAG_OPTION" ref="fd0f2f2b21a02e3b8c8a11a86085c0c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_RXVLAN_TAG_OPTION&nbsp;&nbsp;&nbsp;0x00008000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_TXVLAN_STRP_OPTION specifies the Axi Ethernet device to enable transmit VLAN stripping. This driver sets this option to be dependent during HW build time by default.
</div>
</div><p>
<a class="anchor" name="1cef34ccc21b501cf2f5d0efe22392bd"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_RXVLAN_TRAN_OPTION" ref="1cef34ccc21b501cf2f5d0efe22392bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_RXVLAN_TRAN_OPTION&nbsp;&nbsp;&nbsp;0x00002000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_TXVLAN_TAG_OPTION specifies the Axi Ethernet device to enable transmit VLAN tagging. This driver sets this option to be dependent during HW build time by default.
</div>
</div><p>
<a class="anchor" name="2957a816e7ff90ff5d53bfe30eb7bfec"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_TXVLAN_STRP_OPTION" ref="2957a816e7ff90ff5d53bfe30eb7bfec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_TXVLAN_STRP_OPTION&nbsp;&nbsp;&nbsp;0x00010000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_RXVLAN_STRP_OPTION specifies the Axi Ethernet device to enable receive VLAN stripping. This driver sets this option to be dependent during HW build time by default.
</div>
</div><p>
<a class="anchor" name="b4a430ee8f463578c6d55f527a56cd0b"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_TXVLAN_TAG_OPTION" ref="b4a430ee8f463578c6d55f527a56cd0b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_TXVLAN_TAG_OPTION&nbsp;&nbsp;&nbsp;0x00004000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_RXVLAN_TAG_OPTION specifies the Axi Ethernet device to enable receive VLAN tagging. This driver sets this option to be dependent during HW build time by default.
</div>
</div><p>
<a class="anchor" name="a8451191982023f578cda79fca48b190"></a><!-- doxytag: member="xaxiethernet.h::XAE_EXT_TXVLAN_TRAN_OPTION" ref="a8451191982023f578cda79fca48b190" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_EXT_TXVLAN_TRAN_OPTION&nbsp;&nbsp;&nbsp;0x00001000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_RXVLAN_TRAN_OPTION specifies the Axi Ethernet device to enable receive VLAN translation. This driver sets this option to be dependent on HW configuration by default.
</div>
</div><p>
<a class="anchor" name="9b828349795f783755ab6fd9413f6ff9"></a><!-- doxytag: member="xaxiethernet.h::XAE_FCS_INSERT_OPTION" ref="9b828349795f783755ab6fd9413f6ff9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_FCS_INSERT_OPTION&nbsp;&nbsp;&nbsp;0x00000020          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_LENTYPE_ERR_OPTION specifies the Axi Ethernet device to enable Length/Type error checking (mismatched type/length field) for received frames. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="e274295c74b82214342722ee5b5d9392"></a><!-- doxytag: member="xaxiethernet.h::XAE_FCS_STRIP_OPTION" ref="e274295c74b82214342722ee5b5d9392" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_FCS_STRIP_OPTION&nbsp;&nbsp;&nbsp;0x00000010          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_FCS_INSERT_OPTION specifies the Axi Ethernet device to generate the FCS field and add PAD automatically for outgoing frames. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="ce9786d16960daabfdb803388b4ff0f3"></a><!-- doxytag: member="xaxiethernet.h::XAE_FLOW_CONTROL_OPTION" ref="ce9786d16960daabfdb803388b4ff0f3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_FLOW_CONTROL_OPTION&nbsp;&nbsp;&nbsp;0x00000008          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_FCS_STRIP_OPTION specifies the Axi Ethernet device to strip FCS and PAD from received frames. Note that PAD from VLAN frames is not stripped. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="c23f3851430f7ea598c544f6afd85e79"></a><!-- doxytag: member="xaxiethernet.h::XAE_HARD_TEMC" ref="c23f3851430f7ea598c544f6afd85e79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_HARD_TEMC&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c4a5559d3b5abff1af1516f98b9d9749"></a><!-- doxytag: member="xaxiethernet.h::XAE_HDR_SIZE" ref="c4a5559d3b5abff1af1516f98b9d9749" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_HDR_SIZE&nbsp;&nbsp;&nbsp;14          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="dd8df5928f5a322246ffcce9750a9442"></a><!-- doxytag: member="xaxiethernet.h::XAE_HDR_VLAN_SIZE" ref="dd8df5928f5a322246ffcce9750a9442" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_HDR_VLAN_SIZE&nbsp;&nbsp;&nbsp;18          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="13bb35c49061f25927af2930f2c5f10c"></a><!-- doxytag: member="xaxiethernet.h::XAE_JUMBO_MTU" ref="13bb35c49061f25927af2930f2c5f10c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_JUMBO_MTU&nbsp;&nbsp;&nbsp;8982          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0c81a1ba1412a469773217a168902aa2"></a><!-- doxytag: member="xaxiethernet.h::XAE_JUMBO_OPTION" ref="0c81a1ba1412a469773217a168902aa2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_JUMBO_OPTION&nbsp;&nbsp;&nbsp;0x00000002          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_VLAN_OPTION specifies the Axi Ethernet device to enable VLAN support for transmit and receive. This driver sets this option to disabled (cleared) by default.
</div>
</div><p>
<a class="anchor" name="7f163c38fd07679c8a358c843a52f19e"></a><!-- doxytag: member="xaxiethernet.h::XAE_LENTYPE_ERR_OPTION" ref="7f163c38fd07679c8a358c843a52f19e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_LENTYPE_ERR_OPTION&nbsp;&nbsp;&nbsp;0x00000040          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_TRANSMITTER_ENABLE_OPTION specifies the Axi Ethernet device transmitter to be enabled. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="39d26bcf35e735803e47fe67ad623ddd"></a><!-- doxytag: member="xaxiethernet.h::XAE_MAC_ADDR_SIZE" ref="39d26bcf35e735803e47fe67ad623ddd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MAC_ADDR_SIZE&nbsp;&nbsp;&nbsp;6          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="050af72e3d42870ff4da0f7d3511a768"></a><!-- doxytag: member="xaxiethernet.h::XAE_MAX_FRAME_SIZE" ref="050af72e3d42870ff4da0f7d3511a768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MAX_FRAME_SIZE&nbsp;&nbsp;&nbsp;(XAE_MTU + XAE_HDR_SIZE + XAE_TRL_SIZE)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aa1d4a2c37669bd618cf201b505c73e4"></a><!-- doxytag: member="xaxiethernet.h::XAE_MAX_JUMBO_FRAME_SIZE" ref="aa1d4a2c37669bd618cf201b505c73e4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MAX_JUMBO_FRAME_SIZE&nbsp;&nbsp;&nbsp;(XAE_JUMBO_MTU + XAE_HDR_SIZE + XAE_TRL_SIZE)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="026a07802956bbf92ecea0326be28a12"></a><!-- doxytag: member="xaxiethernet.h::XAE_MAX_VLAN_FRAME_SIZE" ref="026a07802956bbf92ecea0326be28a12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MAX_VLAN_FRAME_SIZE&nbsp;&nbsp;&nbsp;(XAE_MTU + XAE_HDR_VLAN_SIZE + XAE_TRL_SIZE)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="484436248277bbcece62a29c8789cf43"></a><!-- doxytag: member="xaxiethernet.h::XAE_MDIO_DIV_DFT" ref="484436248277bbcece62a29c8789cf43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MDIO_DIV_DFT&nbsp;&nbsp;&nbsp;29          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default MDIO clock divisor
</div>
</div><p>
<a class="anchor" name="16a49d47cbdf8e84658587ab3dc321ba"></a><!-- doxytag: member="xaxiethernet.h::XAE_MTU" ref="16a49d47cbdf8e84658587ab3dc321ba" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MTU&nbsp;&nbsp;&nbsp;1500          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8275681d6099aeb497580d8c3ef6ce3e"></a><!-- doxytag: member="xaxiethernet.h::XAE_MULTI_MAT_ENTRIES" ref="8275681d6099aeb497580d8c3ef6ce3e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MULTI_MAT_ENTRIES&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Number of storable addresses in the Multicast Address Table
</div>
</div><p>
<a class="anchor" name="bf6e17b27602db32c134aaf5afdd33dd"></a><!-- doxytag: member="xaxiethernet.h::XAE_MULTICAST_OPTION" ref="bf6e17b27602db32c134aaf5afdd33dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_MULTICAST_OPTION&nbsp;&nbsp;&nbsp;0x00000400          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_EXT_MULTICAST_OPTION specifies the Axi Ethernet device to receive frames sent to Ethernet addresses that are programmed into the Multicast Address Table. This driver sets this option to be dependent on HW configuration by default.
</div>
</div><p>
<a class="anchor" name="82ebee74425e2075c7946217ac1da504"></a><!-- doxytag: member="xaxiethernet.h::XAE_PHY_TYPE_1000BASE_X" ref="82ebee74425e2075c7946217ac1da504" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PHY_TYPE_1000BASE_X&nbsp;&nbsp;&nbsp;5          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="043115e2c3d919eb1acaddc361f28ff7"></a><!-- doxytag: member="xaxiethernet.h::XAE_PHY_TYPE_GMII" ref="043115e2c3d919eb1acaddc361f28ff7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PHY_TYPE_GMII&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="4ac0ca7b46aa8c67b25a96f39517c69d"></a><!-- doxytag: member="xaxiethernet.h::XAE_PHY_TYPE_MII" ref="4ac0ca7b46aa8c67b25a96f39517c69d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PHY_TYPE_MII&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="23aa3d4dc1966f51828b1f10e3785e40"></a><!-- doxytag: member="xaxiethernet.h::XAE_PHY_TYPE_RGMII_1_3" ref="23aa3d4dc1966f51828b1f10e3785e40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PHY_TYPE_RGMII_1_3&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6b78dfcbcf5ec2752c092c102b6e1f29"></a><!-- doxytag: member="xaxiethernet.h::XAE_PHY_TYPE_RGMII_2_0" ref="6b78dfcbcf5ec2752c092c102b6e1f29" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PHY_TYPE_RGMII_2_0&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1ac7731fa009b34277258f5691fabd34"></a><!-- doxytag: member="xaxiethernet.h::XAE_PHY_TYPE_SGMII" ref="1ac7731fa009b34277258f5691fabd34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PHY_TYPE_SGMII&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="85d541107aad56649d63d548813e1091"></a><!-- doxytag: member="xaxiethernet.h::XAE_PROMISC_OPTION" ref="85d541107aad56649d63d548813e1091" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_PROMISC_OPTION&nbsp;&nbsp;&nbsp;0x00000001          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
&lt; XAE_PROMISC_OPTION specifies the Axi Ethernet device to accept all incoming packets. This driver sets this option to disabled (cleared) by default. XAE_JUMBO_OPTION specifies the Axi Ethernet device to accept jumbo frames for transmit and receive. This driver sets this option to disabled (cleared) by default.
</div>
</div><p>
<a class="anchor" name="027d60f8fd28b519cad51e450b71c07b"></a><!-- doxytag: member="xaxiethernet.h::XAE_RECEIVER_ENABLE_OPTION" ref="027d60f8fd28b519cad51e450b71c07b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_RECEIVER_ENABLE_OPTION&nbsp;&nbsp;&nbsp;0x00000100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_BROADCAST_OPTION specifies the Axi Ethernet device to receive frames sent to the broadcast Ethernet address. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="171dca954a974c164fe82fdb3736d6d2"></a><!-- doxytag: member="xaxiethernet.h::XAE_RX" ref="171dca954a974c164fe82fdb3736d6d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_RX&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0fcf8494f98bdf4395e204d1cee8324e"></a><!-- doxytag: member="xaxiethernet.h::XAE_SOFT_TEMAC_10_100_1000_MBPS" ref="0fcf8494f98bdf4395e204d1cee8324e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_SOFT_TEMAC_10_100_1000_MBPS&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7969c4f16ffd611a8562aa53b8b238d8"></a><!-- doxytag: member="xaxiethernet.h::XAE_SOFT_TEMAC_10_100_MBPS" ref="7969c4f16ffd611a8562aa53b8b238d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_SOFT_TEMAC_10_100_MBPS&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ab704e33f806e844b0978c23729d23a3"></a><!-- doxytag: member="xaxiethernet.h::XAE_TPID_MAX_ENTRIES" ref="ab704e33f806e844b0978c23729d23a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_TPID_MAX_ENTRIES&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="1e81b6f5f677ed0370507c117b565b20"></a><!-- doxytag: member="xaxiethernet.h::XAE_TRANSMITTER_ENABLE_OPTION" ref="1e81b6f5f677ed0370507c117b565b20" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_TRANSMITTER_ENABLE_OPTION&nbsp;&nbsp;&nbsp;0x00000080          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_RECEIVER_ENABLE_OPTION specifies the Axi Ethernet device receiver to be enabled. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="cba30b0be35698c11eb103a31cd43d36"></a><!-- doxytag: member="xaxiethernet.h::XAE_TRL_SIZE" ref="cba30b0be35698c11eb103a31cd43d36" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_TRL_SIZE&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a451942ad49082bf76752438e3c167c9"></a><!-- doxytag: member="xaxiethernet.h::XAE_TX" ref="a451942ad49082bf76752438e3c167c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_TX&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aacd508700a0767d156cf47e71e1ea76"></a><!-- doxytag: member="xaxiethernet.h::XAE_VLAN_OPTION" ref="aacd508700a0767d156cf47e71e1ea76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VLAN_OPTION&nbsp;&nbsp;&nbsp;0x00000004          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAE_FLOW_CONTROL_OPTION specifies the Axi Ethernet device to recognize received flow control frames. This driver sets this option to enabled (set) by default.
</div>
</div><p>
<a class="anchor" name="c1e4f255f237002ef89f3bc0f7ac6435"></a><!-- doxytag: member="xaxiethernet.h::XAE_VSTRP_ALL" ref="c1e4f255f237002ef89f3bc0f7ac6435" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VSTRP_ALL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="acd260b8f206af87b18f1b71d4b8427e"></a><!-- doxytag: member="xaxiethernet.h::XAE_VSTRP_NONE" ref="acd260b8f206af87b18f1b71d4b8427e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VSTRP_NONE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bf516cd3159320e0c799ff40040552ce"></a><!-- doxytag: member="xaxiethernet.h::XAE_VSTRP_SELECT" ref="bf516cd3159320e0c799ff40040552ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VSTRP_SELECT&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2ca8aa2e2c5fc1906c59c130466e51af"></a><!-- doxytag: member="xaxiethernet.h::XAE_VTAG_ALL" ref="2ca8aa2e2c5fc1906c59c130466e51af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VTAG_ALL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7c0862c33dbb447dbf24503faf13e6ed"></a><!-- doxytag: member="xaxiethernet.h::XAE_VTAG_EXISTED" ref="7c0862c33dbb447dbf24503faf13e6ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VTAG_EXISTED&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c4d258f46096316458c83f93aa546b05"></a><!-- doxytag: member="xaxiethernet.h::XAE_VTAG_NONE" ref="c4d258f46096316458c83f93aa546b05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VTAG_NONE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fa30034861eb0242b65ed65bd3ebe813"></a><!-- doxytag: member="xaxiethernet.h::XAE_VTAG_SELECT" ref="fa30034861eb0242b65ed65bd3ebe813" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAE_VTAG_SELECT&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ce643555d4c75d40b1ddee9dbd814a74"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_AxiDevBaseAddress" ref="ce643555d4c75d40b1ddee9dbd814a74" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_AxiDevBaseAddress          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;Config.AxiDevBaseAddress)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_AxiDevBaseAddress reports the base address of the core connected to the Axi Ethernet's Axi4 Stream interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The base address of the core connected to the Axi Ethernet's streaming interface.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#ce643555d4c75d40b1ddee9dbd814a74">XAxiEthernet_AxiDevBaseAddress(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="56664c785ad43b4458a1109d3a5b3bc5"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetIntStatus" ref="56664c785ad43b4458a1109d3a5b3bc5" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_GetIntStatus          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XAxiEthernet_ReadReg((InstancePtr)-&gt;Config.BaseAddress, XAE_IS_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetIntStatus returns a bit mask of the interrupt status register (ISR). XAxiEthernet_GetIntStatus can be used to query the status without having to have interrupts enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a bit mask of the interrupt status conditions. The mask will be a set of bit wise or'd values from the <code>XAE_INT_*_MASK</code> definitions in xaxitemac_hw.h file.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#56664c785ad43b4458a1109d3a5b3bc5">XAxiEthernet_GetIntStatus(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dc2cf9ec186f1dffaece1552f96fcdd9"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetPhysicalInterface" ref="dc2cf9ec186f1dffaece1552f96fcdd9" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_GetPhysicalInterface          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;Config.PhyType)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetPhysicalInterface returns the type of PHY interface being used by the given instance, specified by <em>InstancePtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The Physical Interface type which is one of XAE_PHY_TYPE_x where x is MII, GMII, RGMII_1_3, RGMII_2_0, SGMII, or 1000BASE_X (defined in <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a>).</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: int XAxiEthernet_GetPhysicalInterface(<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr) </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ee4e2b95cc8d84e227f51e28ff07901"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetTemacType" ref="6ee4e2b95cc8d84e227f51e28ff07901" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_GetTemacType          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((InstancePtr)-&gt;Config.TemacType)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetTemacType returns the Axi Ethernet type of the core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>Returns the values of TemacType, which can be XAE_SOFT_TEMAC_10_100_MBPS (0) for Soft Temac Core with speed 10/100 Mbps. XAE_SOFT_TEMAC_10_100_1000_MBPS (1) for Soft Temac core with speed 10/100/1000 Mbps XAE_HARD_TEMC (2) for Hard Temac Core for Virtex-6</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#6ee4e2b95cc8d84e227f51e28ff07901">XAxiEthernet_GetTemacType(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="bf9a1c5aa83b9ea9dde1fc701d088de4"></a><!-- doxytag: member="xaxiethernet.h::XAXIETHERNET_H" ref="bf9a1c5aa83b9ea9dde1fc701d088de4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAXIETHERNET_H          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="aaef83a7f1fe4d8ca117cf6bc80500a8"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IntClear" ref="aaef83a7f1fe4d8ca117cf6bc80500a8" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IntClear          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xaxiethernet__hw_8h.html#048aa7d7b16bc7fa5e85071bd16147aa">XAxiEthernet_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                        <a class="code" href="xaxiethernet__hw_8h.html#03ae297b3ba90f6f4b7ebe468519e55a">XAE_IS_OFFSET</a>, ((Mask) &amp; <a class="code" href="xaxiethernet__hw_8h.html#8a5e8274f2cbf0ee37aae6283a575568">XAE_INT_ALL_MASK</a>))
</pre></div>XAxiEthernet_IntClear clears pending interrupts specified in <em>Mask</em>. The corresponding pending interrupt for each bit set to 1 in <em>Mask</em>, will be cleared. In other words, XAxiEthernet_IntClear uses the "set a bit to clear it" scheme.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the pending interrupts to clear. The mask can be formed using a set of bit wise or'd values from the <code>XAE_INT_*_MASK</code> definitions in xaxitemac_hw.h file.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void XAxiEthernet_IntClear(<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Mask) </dd></dl>

</div>
</div><p>
<a class="anchor" name="6357e97582bc0e064c5b169d212e41df"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IntDisable" ref="6357e97582bc0e064c5b169d212e41df" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IntDisable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xaxiethernet__hw_8h.html#048aa7d7b16bc7fa5e85071bd16147aa">XAxiEthernet_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,         \
                <a class="code" href="xaxiethernet__hw_8h.html#f0c17d5cc5613f6838922152d42377f4">XAE_IE_OFFSET</a>,                                           \
                <a class="code" href="xaxiethernet__hw_8h.html#136faa5126867cb31bb12cec43fb20a2">XAxiEthernet_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                                <a class="code" href="xaxiethernet__hw_8h.html#f0c17d5cc5613f6838922152d42377f4">XAE_IE_OFFSET</a>) &amp; ~((Mask) &amp; <a class="code" href="xaxiethernet__hw_8h.html#8a5e8274f2cbf0ee37aae6283a575568">XAE_INT_ALL_MASK</a>));
</pre></div>XAxiEthernet_IntDisable disables the interrupts specified in <em>Mask</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be disabled. In other words, XAxiEthernet_IntDisable uses the "set a bit to clear it" scheme.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the interrupts to disable. The mask can be formed using a set of bit wise or'd values from the <code>XAE_INT_*_MASK</code> definitions in xaxitemac_hw.h file</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void XAxiEthernet_IntDisable(<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Mask) </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5476b0e04b0ecd8f9fd027f90ea648f"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IntEnable" ref="b5476b0e04b0ecd8f9fd027f90ea648f" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IntEnable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xaxiethernet__hw_8h.html#048aa7d7b16bc7fa5e85071bd16147aa">XAxiEthernet_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress,        \
                <a class="code" href="xaxiethernet__hw_8h.html#f0c17d5cc5613f6838922152d42377f4">XAE_IE_OFFSET</a>,                                          \
                <a class="code" href="xaxiethernet__hw_8h.html#136faa5126867cb31bb12cec43fb20a2">XAxiEthernet_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                                <a class="code" href="xaxiethernet__hw_8h.html#f0c17d5cc5613f6838922152d42377f4">XAE_IE_OFFSET</a>) | ((Mask) &amp; <a class="code" href="xaxiethernet__hw_8h.html#8a5e8274f2cbf0ee37aae6283a575568">XAE_INT_ALL_MASK</a>));
</pre></div>XAxiEthernet_IntEnable enables the interrupts specified in <em>Mask</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the interrupts to enable. The mask can be formed using a set of bit wise or'd values from the <code>XAE_INT_*_MASK</code> definitions in xaxitemac_hw.h file.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void XAxiEthernet_IntEnable(<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Mask) </dd></dl>

</div>
</div><p>
<a class="anchor" name="492b674e8d7584ed5e73e2b1a886bcc3"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IntPending" ref="492b674e8d7584ed5e73e2b1a886bcc3" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IntPending          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XAxiEthernet_ReadReg((InstancePtr)-&gt;Config.BaseAddress, XAE_IP_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IntPending returns a bit mask of the pending interrupts. Each bit set to 1 in the return value represents a pending interrupt.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a bit mask of the interrupts that are pending. The mask will be a set of bit wise or'd values from the <code>XAE_INT_*_MASK</code> definitions in xaxitemac_hw.h file.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#492b674e8d7584ed5e73e2b1a886bcc3">XAxiEthernet_IntPending(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a09f91114abaefee6e94e8a5f48923e7"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsAvbConfigured" ref="a09f91114abaefee6e94e8a5f48923e7" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsAvbConfigured          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.Avb) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsAvbConfigured returns determines if Ethernet AVB.is configured in the harwdare or not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with Ethernet AVB.</li><li>FALSE if the device is NOT configured with Ethernet AVB.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#a09f91114abaefee6e94e8a5f48923e7">XAxiEthernet_IsAvbConfigured(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fa193e8b9cf3c2807d328829903bf6c"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsDma" ref="6fa193e8b9cf3c2807d328829903bf6c" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsDma          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.AxiDevType == XPAR_AXI_DMA) ? TRUE: FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsDma reports if the device is currently connected to DMA.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the Axi Ethernet device is connected DMA.</li><li>FALSE.if the Axi Ethernet device is NOT connected to DMA</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#6fa193e8b9cf3c2807d328829903bf6c">XAxiEthernet_IsDma(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="51c2a30cc98f11355ce3639139b41d8a"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsExtFuncCap" ref="51c2a30cc98f11355ce3639139b41d8a" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsExtFuncCap          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xaxiethernet__hw_8h.html#136faa5126867cb31bb12cec43fb20a2">XAxiEthernet_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                        <a class="code" href="xaxiethernet__hw_8h.html#10705d0bef4683dbb0fa01dc66ae11ce">XAE_RAF_OFFSET</a>) &amp; <a class="code" href="xaxiethernet__hw_8h.html#a419531d1c8c684132f63d8f83cfed7e">XAE_RAF_NEWFNCENBL_MASK</a>) ?  \
                                TRUE : FALSE)
</pre></div>XAxiEthernet_IsExtFuncCap determines if the device is capable of the new/extend VLAN and multicast features.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is capable and configured with extended Multicast and VLAN Tagging/Stripping and Translation.</li><li>TRUE if the device is NOT capable and NOT configured with extended Multicast and VLAN Tagging/Stripping and Translation.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#51c2a30cc98f11355ce3639139b41d8a">XAxiEthernet_IsExtFuncCap(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="751c51d9ed918ca9dd556d98187eb76e"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsExtMcast" ref="751c51d9ed918ca9dd556d98187eb76e" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsExtMcast          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.ExtMcast) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsExtMcast determines if the device is built with new/extended multicast features.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is built with extended multicast features.</li><li>FALSE if the device is not built with the extended multicast features.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This function indicates when hardware is built with extended Multicast feature.</dd></dl>
C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#751c51d9ed918ca9dd556d98187eb76e">XAxiEthernet_IsExtMcast(XAxiEthernet *InstancePtr)</a>
</div>
</div><p>
<a class="anchor" name="b62015adb15bebd496a5346e3877af55"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsExtMcastEnable" ref="b62015adb15bebd496a5346e3877af55" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsExtMcastEnable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xaxiethernet__hw_8h.html#136faa5126867cb31bb12cec43fb20a2">XAxiEthernet_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                        <a class="code" href="xaxiethernet__hw_8h.html#10705d0bef4683dbb0fa01dc66ae11ce">XAE_RAF_OFFSET</a>) &amp; <a class="code" href="xaxiethernet__hw_8h.html#45b7fd9599441cd2a9fb25b7e53c5c7c">XAE_RAF_EMULTIFLTRENBL_MASK</a>) ? \
                                TRUE : FALSE)
</pre></div>XAxiEthernet_IsExtMcastEnable determines if the extended multicast features is enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the extended multicast features are enabled.</li><li>FALSE if the extended multicast features are NOT enabled</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>: This function indicates when extended Multicast is enabled in HW, extended multicast mode in wrapper can be tested.</dd></dl>
C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#b62015adb15bebd496a5346e3877af55">XAxiEthernet_IsExtMcastEnable(XAxiEthernet *InstancePtr)</a>
</div>
</div><p>
<a class="anchor" name="aedd2fe4a2b3d24152c3f32160e8f994"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsFifo" ref="aedd2fe4a2b3d24152c3f32160e8f994" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsFifo          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.AxiDevType == XPAR_AXI_FIFO) ? TRUE: FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsFifo reports if the device is currently connected to a fifo core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the Axi Ethernet device is connected to a fifo</li><li>FALSE if the Axi Ethernet device is NOT connected to a fifo.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#aedd2fe4a2b3d24152c3f32160e8f994">XAxiEthernet_IsFifo(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5c91a283a8b79c5e0735588ed8064ec"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsRecvFrameDropped" ref="e5c91a283a8b79c5e0735588ed8064ec" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsRecvFrameDropped          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xaxiethernet__hw_8h.html#136faa5126867cb31bb12cec43fb20a2">XAxiEthernet_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,  \
        <a class="code" href="xaxiethernet__hw_8h.html#03ae297b3ba90f6f4b7ebe468519e55a">XAE_IS_OFFSET</a>) &amp; <a class="code" href="xaxiethernet__hw_8h.html#a5ac7291090f44c1a2057589f2660b6c">XAE_INT_RXRJECT_MASK</a>) ? TRUE : FALSE)
</pre></div>XAxiEthernet_IsRecvFrameDropped determines if the device thinks it has dropped a receive frame. The device interrupt status register is read to determine this.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if a frame has been dropped</li><li>FALSE if a frame has NOT been dropped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#e5c91a283a8b79c5e0735588ed8064ec">XAxiEthernet_IsRecvFrameDropped(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="70ae7bc7e8d22aa1c7be7076c83d4015"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsRxFullCsum" ref="70ae7bc7e8d22aa1c7be7076c83d4015" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsRxFullCsum          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.RxCsum) == 0x02) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsRxFullCsum determines if the device is configured with full checksum offloading on the receive channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with full checksum offloading on the receive channel.</li><li>FALSE.if the device is not configured with full checksum offloading on the receive side.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#70ae7bc7e8d22aa1c7be7076c83d4015">XAxiEthernet_IsRxFullCsum(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="e21c088294f79359ed1ee74468100e9a"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsRxPartialCsum" ref="e21c088294f79359ed1ee74468100e9a" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsRxPartialCsum          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.RxCsum) == 0x01) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsRxPartialCsum determines if the device is configured with partial checksum offloading on the receive channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with partial checksum offloading on the receive channel.</li><li>FALSE.if the device is not configured with partial checksum offloading on the receive side.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#e21c088294f79359ed1ee74468100e9a">XAxiEthernet_IsRxPartialCsum(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="4764b3156c37e0b505c4df69b105b770"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsRxVlanStrp" ref="4764b3156c37e0b505c4df69b105b770" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsRxVlanStrp          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.RxVlanStrp) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsRxVlanStrp determines if the device is configured with receive VLAN stripping on the receive channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with VLAN stripping on the Receive channel.</li><li>FALSE if the device is NOT configured with VLAN stripping on the Receive channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#04ad5f292476ee8d62a2cacc66bf8767">XAxiEthernet_IsRxVlanTran(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="16debcb3a008c09bc8c4e29764310cae"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsRxVlanTag" ref="16debcb3a008c09bc8c4e29764310cae" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsRxVlanTag          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.RxVlanTag) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsRxVlanTag determines if the device is configured with receive VLAN tagging on the receive channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with VLAN tagging on the Receive channel.</li><li>FALSE if the device is NOT configured with VLAN tagging on the Receive channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#16debcb3a008c09bc8c4e29764310cae">XAxiEthernet_IsRxVlanTag(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="04ad5f292476ee8d62a2cacc66bf8767"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsRxVlanTran" ref="04ad5f292476ee8d62a2cacc66bf8767" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsRxVlanTran          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.RxVlanTran) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsRxVlanTran determines if the device is configured with receive VLAN translation on the receive channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with VLAN translation on the Receive channel.</li><li>FALSE if the device is NOT configured with VLAN translation on the Receive channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#04ad5f292476ee8d62a2cacc66bf8767">XAxiEthernet_IsRxVlanTran(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="f20d2f840ee7c6defacb6e1a478b38a7"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsSgmiiOverLvdsEnabled" ref="f20d2f840ee7c6defacb6e1a478b38a7" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsSgmiiOverLvdsEnabled          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.EnableSgmiiOverLvds) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsSgmiiOverLvdsEnabled determines if SGMII over LVDS is enabled in the harwdare or not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with SGMII over LVDS.</li><li>FALSE if the device is NOT configured with SGMII over LVDS.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#f20d2f840ee7c6defacb6e1a478b38a7">XAxiEthernet_IsSgmiiOverLvdsEnabled(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c513f6bb939a705f56da5c826d9ec63"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsStarted" ref="6c513f6bb939a705f56da5c826d9ec63" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsStarted          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;IsStarted == XIL_COMPONENT_IS_STARTED) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsStarted reports if the device is in the started or stopped state. To be in the started state, the calling code must have made a successful call to <em>XAxiEthernet_Start</em>. To be in the stopped state, <em>XAxiEthernet_Stop</em> or <em>XAxiEthernet_CfgInitialize</em> function must have been called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the of Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device has been started.</li><li>FALSE.if the device has not been started</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#6c513f6bb939a705f56da5c826d9ec63">XAxiEthernet_IsStarted(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e75a48d11c00b0c39339bd2f2461bdc"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsStatsConfigured" ref="2e75a48d11c00b0c39339bd2f2461bdc" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsStatsConfigured          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.Stats) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsStatsConfigured returns determines if Statistics gathering. is configured in the harwdare or not.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with statistics gathering.</li><li>FALSE if the device is NOT configured with statistics gathering.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#2e75a48d11c00b0c39339bd2f2461bdc">XAxiEthernet_IsStatsConfigured(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="8d1defd403ed40f023650e1e44651c88"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsTxFullCsum" ref="8d1defd403ed40f023650e1e44651c88" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsTxFullCsum          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.TxCsum) == 0x02) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsTxFullCsum determines if the device is configured with full checksum offloading on the transmit channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with full checksum offloading on the transmit side.</li><li>FALSE.if the device is not configured with full checksum offloading on the transmit side.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#8d1defd403ed40f023650e1e44651c88">XAxiEthernet_IsTxFullCsum(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="6e44788bbc239e6cea83d1e07ddb65ed"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsTxPartialCsum" ref="6e44788bbc239e6cea83d1e07ddb65ed" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsTxPartialCsum          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((((InstancePtr)-&gt;Config.TxCsum) == 0x01) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsTxPartialCsum determines if the device is configured with partial checksum offloading on the transmit channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with partial checksum offloading on the transmit side.</li><li>FALSE.if the device is not configured with partial checksum offloading on the transmit side.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#6e44788bbc239e6cea83d1e07ddb65ed">XAxiEthernet_IsTxPartialCsum(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="92ea2563addd13a5d3008a0bd9d069bc"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsTxVlanStrp" ref="92ea2563addd13a5d3008a0bd9d069bc" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsTxVlanStrp          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.TxVlanStrp) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsTxVlanStrp determines if the device is configured with transmit VLAN stripping on the transmit channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with VLAN stripping on the Transmit channel.</li><li>FALSE if the device is NOT configured with VLAN stripping on the Transmit channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#92ea2563addd13a5d3008a0bd9d069bc">XAxiEthernet_IsTxVlanStrp(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d75475a1e85f44562fd614960744b23"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsTxVlanTag" ref="2d75475a1e85f44562fd614960744b23" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsTxVlanTag          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.TxVlanTag) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsTxVlanTag determines if the device is configured with transmit VLAN tagging on the transmit channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with VLAN tagging on the Transmit channel.</li><li>FALSE if the device is NOT configured with VLAN tagging on the Transmit channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#2d75475a1e85f44562fd614960744b23">XAxiEthernet_IsTxVlanTag(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac1bbeb5294915665aae439a33e3b887"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_IsTxVlanTran" ref="ac1bbeb5294915665aae439a33e3b887" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XAxiEthernet_IsTxVlanTran          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(((InstancePtr)-&gt;Config.TxVlanTran) ? TRUE : FALSE)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_IsTxVlanTran determines if the device is configured with transmit VLAN translation on the transmit channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is configured with VLAN translation on the Transmit channel.</li><li>FALSE if the device is NOT configured with VLAN translation on the Transmit channel.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xaxiethernet_8h.html#ac1bbeb5294915665aae439a33e3b887">XAxiEthernet_IsTxVlanTran(XAxiEthernet *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="c6e848552b34aa85f6801ab269521cf3"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_AddExtMulticastGroup" ref="c6e848552b34aa85f6801ab269521cf3" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_AddExtMulticastGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_AddExtMulticastGroup adds an entry to the multicast Ethernet address table. The new entry, represents a group of MAC addresses based on the contents of AddressPtr. AddressPtr is one member of the MAC address set in the newly added entry.<p>
The device must be stopped to use this function.<br>
<br>
<p>
Once an Ethernet address is programmed, the Axi Ethernet device will begin receiving data sent from that address. The Axi Ethernet hardware does not have a control bit to disable multicast filtering. The only way to prevent the Axi Ethernet device from receiving messages from an Ethernet address in the multicast table is to clear it with <a class="el" href="xaxiethernet_8h.html#b4a3a1fdf74706efe50812be6ec78839">XAxiEthernet_ClearExtMulticastGroup()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to add.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS.on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li><li>XST_INVALID_PARAM if the input MAC address is not between 01:00:5E:00:00:00 and 01:00:5E:7F:FF:FF per RFC1112.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine consider all 2**23 possible multicast Ethernet addresses to be 8Mx1 bit or 1M bytes memory area. All defined multicast addresses are from 01.00.5E.00.00.00 to 01.00.5E.7F.FF.FF The most significant 25 bit out of 48 bit are static, so they will not be part of calculation.<p>
The hardware requires to 'index' with bit 22-8, 15 bits in total. The least significant byte/8 bits are considered a group.<p>
This API operates at a group (256 MAC addresses) for hardware to do the first layer address filtering. It is user's responsibility to provision this table appropriately.
</div>
</div><p>
<a class="anchor" name="cfb6c81216c79e4a3a307448e9f60be0"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_CfgInitialize" ref="cfb6c81216c79e4a3a307448e9f60be0" args="(XAxiEthernet *InstancePtr, XAxiEthernet_Config *CfgPtr, u32 VirtualAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_CfgInitialize initializes an AXI Ethernet device along with the <em>InstancePtr</em> that references it.<p>
The PHY is setup independently from the Ethernet core. Use the MII or whatever other interface may be present for setup.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the memory instance to be associated with the AXI Ethernet core instance upon initialization. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>references the structure holding the hardware configuration for the Axi Ethernet core to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the processor address used to access the base address of the AXI Ethernet instance. In systems with an MMU and virtual memory, <em>EffectiveAddress</em> is the virtual address mapped to the physical in <code>ConfigPtr-&gt;Config.BaseAddress</code>. In systems without an active MMU, <em>EffectiveAddress</em> should be set to the same value as <code>ConfigPtr-&gt;Config.BaseAddress</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab45f6c7a4440bc3f58d4ff971e6be7b"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_ClearBadFrmRcvOption" ref="ab45f6c7a4440bc3f58d4ff971e6be7b" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_ClearBadFrmRcvOption           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_ClearBadFrmRcvOption is used to disable the bad frame receive option.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b4a3a1fdf74706efe50812be6ec78839"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_ClearExtMulticastGroup" ref="b4a3a1fdf74706efe50812be6ec78839" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_ClearExtMulticastGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_ClearExtMulticastGroup clears input multicast Ethernet address group from table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to clear.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion, returns XST_SUCCESS.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped</li><li>XST_INVALID_PARAM if input MAC address is not between 01:00:5E:00:00:00 and 01:00:5E:7F:FF:FF per RFC1112.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Please reference XAxiEthernet_AddExtMulticastGroup for multicast address index and bit value calculation.<p>
In table, hardware requires to 'index' with bit 22-8, 15 bits in total. The least significant byte/8 bits are considered a group.<p>
There is a scenario that might introduce issues: When multicast tables are programmed initially to accept 01:00:5E:12:34:56 and 01:00:5E:12:34:78 but later decided to clear 01:00:5E:12:34:78. Without validating all possible combinations at the indexed entry, multicast table might be misconfigured and drop frames.<p>
When clearing a multicast address table entry, note that a whole group of mac addresses will no longer be accepted - this because an entry in the table represents multiple(256) mac addresses.<p>
The device must be stopped to use this function.<br>
<br>
 This API operates at a group (256 MAC addresses) level for hardware to perform the first layer address filtering. It is user's responsibility to provision this table appropriately.
</div>
</div><p>
<a class="anchor" name="d3e7253d626c02a96ac35f981ac11ba2"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_ClearOptions" ref="d3e7253d626c02a96ac35f981ac11ba2" args="(XAxiEthernet *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_ClearOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_ClearOptions clears the options, <em>Options</em> for the Axi Ethernet, specified by <em>InstancePtr</em>. Axi Ethernet should be stopped with <a class="el" href="xaxiethernet_8c.html#4e952a55f342f176ba9ec2b49e2e47cb">XAxiEthernet_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>is a bitmask of OR'd XAE_*_OPTION values for options to clear. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the device has not been stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="338bb9b51764235ed6969faa58503455"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_ClearTpid" ref="338bb9b51764235ed6969faa58503455" args="(XAxiEthernet *InstancePtr, u8 Entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_ClearTpid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_ClearTpid clears the VLAN Tag Protocol Identifier(TPID).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to program this address and must be between 0..XAE_TPID_MAX_ENTRIES.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li><li>XST_NO_FEATURE if the Axi Ethernet does not enable or have the VLAN tag capability.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The device must be stopped to use this function. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41049ca22799d42d1279461be627c72e"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_DisableControlFrameLenCheck" ref="41049ca22799d42d1279461be627c72e" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_DisableControlFrameLenCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_DisableControlFrameLenCheck is used to disable the length check for control frames (pause frames). This means once the API is called, control frames larger than the minimum frame length are accepted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="08b7db7c5a837de18afceb58230351b3"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_DumpExtMulticastGroup" ref="08b7db7c5a837de18afceb58230351b3" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_DumpExtMulticastGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_DumpExtMulticastGroup dumps ALL provisioned acceptable multicast MAC in the Axi Ethernet device's multicast table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Hardware requires to 'index' with bit 22-8, 15 bits in total. The least significant byte/8 bits are considered a set.<p>
This API operates at a set (256 MAC addresses) level.
</div>
</div><p>
<a class="anchor" name="8b71bcdc8be6ae5d6364c59ea0f53aab"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_EnableControlFrameLenCheck" ref="8b71bcdc8be6ae5d6364c59ea0f53aab" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_EnableControlFrameLenCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_EnableControlFrameLenCheck is used to enable the length check for control frames (pause frames). After calling the API, all control frames received will be checked for proper length (less than minimum frame length). By default, upon normal start up, control frame length check is enabled. Hence this API needs to be called only if previously the control frame length check has been disabled by calling the API XAxiEthernet_DisableControlFrameLenCheck.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6932bd79a08811085a47ad1357a4ef89"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetExtMulticastGroup" ref="6932bd79a08811085a47ad1357a4ef89" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_GetExtMulticastGroup           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetExtMulticastGroup returns whether the given Ethernet address group is stored in the table.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if it is an acceptable multicast MAC address and the group is present in the table.</li><li>FALSE if it is not a valid multicast MAC address or the group was not found in the table.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
In the table, hardware requires to 'index' with bit 22-8, 15 bits in total. The least significant byte/8 bits are considered a group. This API operates at a group (256 MAC addresses) level.
</div>
</div><p>
<a class="anchor" name="a5b70a456ac18505132f61f596428ab7"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetMacAddress" ref="a5b70a456ac18505132f61f596428ab7" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetMacAddress gets the MAC address for the Axi Ethernet, specified by <em>InstancePtr</em> into the memory buffer specified by <em>AddressPtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved MAC address. This memory buffer must be at least 6 bytes in length.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine also supports the extended/new VLAN and multicast mode. The XAE_RAF_NEWFNCENBL_MASK bit dictates which offset will be configured.
</div>
</div><p>
<a class="anchor" name="369290833088c56abf0a967f16233266"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetMacPauseAddress" ref="369290833088c56abf0a967f16233266" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetMacPauseAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetMacPauseAddress gets the MAC address used for pause frames for the Axi Ethernet device specified by <em>InstancePtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved MAC address. This memory buffer must be at least 6 bytes in length.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8e8caa9c4ac753744bd08ebf103877c3"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetOperatingSpeed" ref="8e8caa9c4ac753744bd08ebf103877c3" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XAxiEthernet_GetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetOperatingSpeed gets the current operating link speed. This may be the value set by <a class="el" href="xaxiethernet_8c.html#b2d0106f26a1a2e1f2b902dc0a2822c9">XAxiEthernet_SetOperatingSpeed()</a> or a hardware default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the link speed in units of megabits per second (10 / 100 / 1000). Can return a value of 0, in case it does not get a valid speed from EMMC.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f48b8f321b842bfb139b473ad7185874"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetOptions" ref="f48b8f321b842bfb139b473ad7185874" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAxiEthernet_GetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetOptions returns the current option settings.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a bitmask of XAE_*_OPTION constants, each bit specifying an option that is currently active.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="de4816d9067e13fbac2ceb66cf32360d"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetRgmiiStatus" ref="de4816d9067e13fbac2ceb66cf32360d" args="(XAxiEthernet *InstancePtr, u16 *SpeedPtr, int *IsFullDuplexPtr, int *IsLinkUpPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_GetRgmiiStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>SpeedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IsFullDuplexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>IsLinkUpPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetRgmiiStatus get the state of the link when using the RGMII media interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SpeedPtr</em>&nbsp;</td><td>references the location to store the result, which is the auto negotiated link speed in units of Mbits/sec, either 0, 10, 100, or 1000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsFullDuplexPtr</em>&nbsp;</td><td>references the value that is set by this function to indicate full duplex operation. <em>IsFullDuplexPtr</em> is set to TRUE when the RGMII link is operating in full duplex mode, otherwise it is set to FALSE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsLinkUpPtr</em>&nbsp;</td><td>references the value that is set by this function to indicate the link status.<em>IsLinkUpPtr</em> is set to TRUE when the RGMII link up, otherwise it is set to FALSE.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_NO_FEATURE if the Axi Ethernet device is not using an RGMII interface,</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7d57eaf1bb97c34a92cc5e2c8600075"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetSgmiiStatus" ref="b7d57eaf1bb97c34a92cc5e2c8600075" args="(XAxiEthernet *InstancePtr, u16 *SpeedPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_GetSgmiiStatus           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>SpeedPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetSgmiiStatus get the state of the link when using the SGMII media interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SpeedPtr</em>&nbsp;</td><td>references the location to store the result, which is the auto negotiated link speed in units of Mbits/sec, either 0, 10, 100, or 1000.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_NO_FEATURE if the Axi Ethernet device is not using an SGMII interface,</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Currently SGMII PHY does not support half duplex mode. </dd></dl>

</div>
</div><p>
<a class="anchor" name="498bdb032a67313102ac7dee10ae8e7e"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetTpid" ref="498bdb032a67313102ac7dee10ae8e7e" args="(XAxiEthernet *InstancePtr, u16 *TpidPtr, u8 Entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetTpid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>TpidPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetTpid gets the VLAN Tag Protocol Identifier value (TPID).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TpidPtr</em>&nbsp;</td><td>references the location to store the result. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to program this address and must be between 0..XAE_TPID_MAX_ENTRIES.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b13721145a4632d987bd858483c00011"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetVidTable" ref="b13721145a4632d987bd858483c00011" args="(XAxiEthernet *InstancePtr, u32 Entry, u32 *VidPtr, u8 *StripPtr, u8 *TagPtr, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetVidTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>VidPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>StripPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TagPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetVidTable gets VID table content includes new VLAN ID, strip and tag enable bits.<p>
The device must be stopped to use this function.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location/index to program updated VID value, strip, or tag value. The value must be between 0..0xFFF. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VidPtr</em>&nbsp;</td><td>references the location to store the result. This function stores the Vid value indexed by Entry into this location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StripPtr</em>&nbsp;</td><td>references the location to store the result. This function stores the strip enable bit value indexed by Entry into this location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TagPtr</em>&nbsp;</td><td>references the location to store the result. This function stores the tag enable bit value indexed by Entry into this location. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The hardware requires the table to be 'indexed' with Entry and must be 0x000..0xFFF.<p>
Bits layout is bbbb bbbb bbbb b b VLAN ID (12b), | | | VLAN double tag enable bit VLAN strip enable bit
</div>
</div><p>
<a class="anchor" name="fb2a0cbe2263410d25caa0e87428a6d7"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetVStripMode" ref="fb2a0cbe2263410d25caa0e87428a6d7" args="(XAxiEthernet *InstancePtr, u8 *ModePtr, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetVStripMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ModePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetVStripMode gets the VLAN stripping mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ModePtr</em>&nbsp;</td><td>references the location to store the VLAN strip mode returned by this function. Value is b'00, b'01 or b'11. Refer XAE_VTSRAP_* in <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> file for the details. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Mode value shifting is handled in this function. No shifting is required to call this function.
</div>
</div><p>
<a class="anchor" name="9d375eb39bb3a8f724123aa9a9585e47"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetVTagMode" ref="9d375eb39bb3a8f724123aa9a9585e47" args="(XAxiEthernet *InstancePtr, u8 *ModePtr, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetVTagMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ModePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetVTagMode gets VLAN tagging mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ModePtr</em>&nbsp;</td><td>references the location to store the VLAN tag mode. Value is between b'00-b'11. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The device must be stopped to use this function.<br>
<br>
 Mode value shifting is handled in this function. No shifting is required to call this function.
</div>
</div><p>
<a class="anchor" name="00d242e51aeec92bf07528bbf58709ea"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_GetVTagValue" ref="00d242e51aeec92bf07528bbf58709ea" args="(XAxiEthernet *InstancePtr, u32 *VTagValuePtr, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetVTagValue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>VTagValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetVTagValue gets the configured VLAN tagging value.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VTagValuePtr</em>&nbsp;</td><td>references the location to store the result. Format is TPID, one of the following 16 bit values, 0x8100, 0x88a8, 0x9100, 0x9200. Priority, 3 bits CFI, 1 bit VID, 12 bits </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Ethernet VLAN frames' VLAN type/length(2B) and tag control information(2B). Bit layout : bbbb bbbb bbbb bbbb bbb b bbbb bbbb bbbb \ / | | \ VID (12b) / \ / | CFI bit (1b) TPID (16b) priority bit (3b)
</div>
</div><p>
<a class="anchor" name="b25ee3d4c048dccce6e97f59529ed2c3"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_LookupConfig" ref="b25ee3d4c048dccce6e97f59529ed2c3" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a>* XAxiEthernet_LookupConfig           </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_LookupConfig returns a reference to an <a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a> structure based on an unique device id, <em>DeviceId</em>. The return value will refer to an entry in the device configuration table defined in the <a class="el" href="xaxiethernet__g_8c.html">xaxiethernet_g.c</a> file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device for the lookup operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>Returns a reference to a config record in the configuration table (in <a class="el" href="xaxiethernet__g_8c.html">xaxiethernet_g.c</a>) corresponding to <em>DeviceId</em>, or NULL</li><li>NULL if no match is found. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="c186de218bc1df3afe9e1c91c6b749b6"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_MulticastAdd" ref="c186de218bc1df3afe9e1c91c6b749b6" args="(XAxiEthernet *InstancePtr, void *AddressPtr, int Entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_MulticastAdd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_MulticastAdd adds the Ethernet address, <em>AddressPtr</em> to the Axi Ethernet device's multicast filter list, at list index <em>Entry</em>. The address referenced by <em>AddressPtr</em> may be of any unicast, multicast, or broadcast address form. The hardware for the Axi Ethernet device can hold up to XAE_MULTI_MAT_ENTRIES addresses in this filter list.<br>
<br>
<p>
The device must be stopped to use this function.<br>
<br>
<p>
Once an Ethernet address is programmed, the Axi Ethernet device will begin receiving data sent from that address. The Axi Ethernet hardware does not have a control bit to disable multicast filtering. The only way to prevent the Axi Ethernet device from receiving messages from an Ethernet address in the Multicast Address Table (MAT) is to clear it with <a class="el" href="xaxiethernet_8h.html#1db86bd14ba6b769f6fdf34c0e277c10">XAxiEthernet_MulticastClear()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to set. The previous address at the location <em>Entry</em> (if any) is overwritten with the value at <em>AddressPtr</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to program this address and must be between 0 to (XAE_MULTI_MAT_ENTRIES - 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED.if the Axi Ethernet device is not stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine works only with normal multicast filtering feature. A maximum of 4 multicast addresses can be stored in the HW provided multicast table.<p>
To use the extended multicast feature, extended multicast filtering must be enabled by using driver API XAxiEthernet_SetOptions with proper option fields set. Once extended multicast filtering is enabled, the APIs XAxiEthernet_[Add|Clear|Get]ExtMulticastGroup() must be used to manage multicast address groups.
</div>
</div><p>
<a class="anchor" name="1db86bd14ba6b769f6fdf34c0e277c10"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_MulticastClear" ref="1db86bd14ba6b769f6fdf34c0e277c10" args="(XAxiEthernet *InstancePtr, int Entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_MulticastClear           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_MulticastClear clears the Ethernet address stored at index <em>Entry</em> in the Axi Ethernet device's multicast filter list.<br>
<br>
<p>
The device must be stopped to use this function.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the HW storage location used when this address was added. It must be between 0 to (XAE_MULTI_MAT_ENTRIES - 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED.if the Axi Ethernet device is not stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine works only with normal multicast filtering feature. A maximum of 4 multicast addresses can be stored in the HW provided multicast table.<p>
To use the extended multicast feature, extended multicast filtering must be enabled by using driver API XAxiEthernet_SetOptions with proper option fields set. Once extended multicast filtering is enabled, the APIs XAxiEthernet_[Add|Clear|Get]ExtMulticastGroup() must be used to manage multicast address groups.
</div>
</div><p>
<a class="anchor" name="c95ba7bcd0c537eec1787f5ea49488df"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_MulticastGet" ref="c95ba7bcd0c537eec1787f5ea49488df" args="(XAxiEthernet *InstancePtr, void *AddressPtr, int Entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_MulticastGet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_MulticastGet gets the Ethernet address stored at index <em>Entry</em> in the Axi Ethernet device's multicast filter list.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved Ethernet address. This memory buffer must be at least 6 bytes in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location from which to retrieve the address and must be between 0 to (XAE_MULTI_MAT_ENTRIES - 1)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine works only with normal multicast filtering feature. A maximum of 4 multicast addresses can be stored in the HW provided multicast table.<p>
To use the extended multicast feature, extended multicast filtering must be enabled by using driver API XAxiEthernet_SetOptions with proper option fields set. Once extended multicast filtering is enabled, the APIs XAxiEthernet_[Add|Clear|Get]ExtMulticastGroup() must be used to manage multicast address groups.
</div>
</div><p>
<a class="anchor" name="6dc70adcb2c07eb801facc8e2243ea98"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_PhyRead" ref="6dc70adcb2c07eb801facc8e2243ea98" args="(XAxiEthernet *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_PhyRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>PhyDataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2b33bc77237bf039c02d4619a811aed6"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_PhySetMdioDivisor" ref="2b33bc77237bf039c02d4619a811aed6" args="(XAxiEthernet *InstancePtr, u8 Divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_PhySetMdioDivisor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_PhySetMdioDivisor sets the MDIO clock divisor in the Axi Ethernet,specified by <em>InstancePtr</em> to the value, <em>Divisor</em>. This function must be called once after each reset prior to accessing MII PHY registers.<p>
From the Virtex-6(TM) and Spartan-6 (TM) Embedded Tri-Mode Ethernet MAC User's Guide, the following equation governs the MDIO clock to the PHY:<p>
<pre>
			f[HOSTCLK]
	f[MDC] = -----------------------
			(1 + Divisor) * 2
 </pre><p>
where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster access.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the Axi Ethernet instance on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is the divisor value to set within the range of 0 to XAE_MDIO_MC_CLK_DVD_MAX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9394dd066a7497ed9346b26457c28247"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_PhyWrite" ref="9394dd066a7497ed9346b26457c28247" args="(XAxiEthernet *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_PhyWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>PhyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="091a291d11f394e3eaf0b79195666d9f"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_Reset" ref="091a291d11f394e3eaf0b79195666d9f" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_Reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_Reset does not perform a soft reset of the AxiEthernet core. AxiEthernet hardware is reset by the device connected to the AXI4-Stream interface. This function inserts some delay before proceeding to check for MgtRdy bit. The delay is necessary to be at a safe side. It takes a while for the reset process to complete and for any of the AxiEthernet registers to be accessed. It then checks for MgtRdy bit in IS register to know if AxiEthernet reset is completed or not. Subsequently it calls one more driver function to complete the AxiEthernet hardware initialization.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>It is the responsibility of the user to reset the AxiEthernet hardware before using it. AxiEthernet hardware should be reset through the device connected to the AXI4-Stream interface of AxiEthernet. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e513f052386deaf8c5994b768f9647ce"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SendPausePacket" ref="e513f052386deaf8c5994b768f9647ce" args="(XAxiEthernet *InstancePtr, u16 PauseValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SendPausePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>PauseValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SendPausePacket sends a pause packet with the value of <em>PauseValue</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PauseValue</em>&nbsp;</td><td>is the pause value in units of 512 bit times.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3db57c4a261afc854985297afed2373b"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetBadFrmRcvOption" ref="3db57c4a261afc854985297afed2373b" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_SetBadFrmRcvOption           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetBadFrmRcvOption is used to enable the bad frame receive option. If enabled, this option ensures that bad receive frames are allowed and passed to the AXI4-Stream interface as if they are good frames.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2298b2b1af89cf0f0a78d4fda03ed7f"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetMacAddress" ref="b2298b2b1af89cf0f0a78d4fda03ed7f" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetMacAddress sets the MAC address for the Axi Ethernet device, specified by <em>InstancePtr</em> to the MAC address specified by <em>AddressPtr</em>. The Axi Ethernet device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a reference to the 6-byte MAC address to set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device has not stopped,</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This routine also supports the extended/new VLAN and multicast mode. The XAE_RAF_NEWFNCENBL_MASK bit dictates which offset will be configured. </dd></dl>

</div>
</div><p>
<a class="anchor" name="99c4e06d4db500ab7bf6bc20853330e2"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetMacPauseAddress" ref="99c4e06d4db500ab7bf6bc20853330e2" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetMacPauseAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetMacPauseAddress sets the MAC address used for pause frames to <em>AddressPtr</em>. <em>AddressPtr</em> will be the address the Axi Ethernet device will recognize as being for pause frames. Pause frames transmitted with <a class="el" href="xaxiethernet_8h.html#e513f052386deaf8c5994b768f9647ce">XAxiEthernet_SendPausePacket()</a> will also use this address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2d0106f26a1a2e1f2b902dc0a2822c9"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetOperatingSpeed" ref="b2d0106f26a1a2e1f2b902dc0a2822c9" args="(XAxiEthernet *InstancePtr, u16 Speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Speed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetOperatingSpeed sets the current operating link speed. For any traffic to be passed, this speed must match the current MII/GMII/SGMII/RGMII link speed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the Axi Ethernet on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Speed</em>&nbsp;</td><td>is the speed to set in units of Mbps. Valid values are 10, 100, or 1000.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>- XST_SUCCESS on successful setting of speed.<ul>
<li>XST_FAILURE, if the speed cannot be set for the present harwdare configuration.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3265620b9d9b86643abe5ff5e2b7d79"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetOptions" ref="e3265620b9d9b86643abe5ff5e2b7d79" args="(XAxiEthernet *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetOptions enables the options, <em>Options</em> for the Axi Ethernet, specified by <em>InstancePtr</em>. Axi Ethernet should be stopped with <a class="el" href="xaxiethernet_8c.html#4e952a55f342f176ba9ec2b49e2e47cb">XAxiEthernet_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>is a bitmask of OR'd XAE_*_OPTION values for options to set. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the device has not been stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d692528035485610c1bbf6e3fbb4a84"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetTpid" ref="2d692528035485610c1bbf6e3fbb4a84" args="(XAxiEthernet *InstancePtr, u16 Tpid, u8 Entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetTpid           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Tpid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Entry</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetTpid sets the VLAN Tag Protocol Identifier(TPID).<p>
Four values can be configured - 0x8100, 0x9100, 0x9200, 0x88A8.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tpid</em>&nbsp;</td><td>is a hex value to be added to the TPID table. The four values that can be added are 0x8100, 0x9100, 0x9200, 0x88A8. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to program this address and must be between 0..XAE_TPID_MAX_ENTRIES.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED, if the Axi Ethernet device is not stopped.</li><li>XST_NO_FEATURE if the Axi Ethernet does not enable or have the VLAN tag capability.</li><li>XST_INVALID_PARAM if Tpid is not one of supported values.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>The device must be stopped to use this function. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f860a127fcc5756c2dc62337eb1b934"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetVidTable" ref="4f860a127fcc5756c2dc62337eb1b934" args="(XAxiEthernet *InstancePtr, u32 Entry, u32 Vid, u8 Strip, u8 Tag, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetVidTable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Strip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetVidTable sets VID table includes new VLAN ID, strip and tag enable bits.<p>
The device must be stopped to use this function.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location/index to program updated VID value, strip, or tag value. The value must be between 0..0xFFF. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Vid</em>&nbsp;</td><td>is updated/translated Vid value to be programmed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Strip</em>&nbsp;</td><td>is strip enable indication for Vid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tag</em>&nbsp;</td><td>is tag enable indication for Vid. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li><li>XST_NO_FEATURE if the Axi Ethernet does not enable/have extended functionalities.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The hardware requires the table to be 'indexed' with Entry and must be 0x000..0xFFF.<p>
Bits layout is bbbb bbbb bbbb b b VLAN ID (12b), | | | VLAN double tag enable bit VLAN strip enable bit<p>
To disable translation indexed by Entry, Set Vid = Entry.
</div>
</div><p>
<a class="anchor" name="95198cfb6e93a13c115c7c6610a68ded"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetVStripMode" ref="95198cfb6e93a13c115c7c6610a68ded" args="(XAxiEthernet *InstancePtr, u32 Mode, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetVStripMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetVStripMode configures the VLAN strip mode.<p>
Three modes can be configured :<ul>
<li>XAE_VSTRP_NONE for no stripping.</li><li>XAE_VSTRP_ALL to strip one tag from all frames.</li><li>XAE_VSTRP_SELECT to strip one tag from already selected tagged frames based on VID value.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mode</em>&nbsp;</td><td>is the VLAN strip mode. Value must be b'00, b'01, or b'11. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion., returns XST_SUCCESS.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li><li>XST_NO_FEATURE if the Axi Ethernet does not enable or have the TX VLAN strip capability.</li><li>XST_INVALID_PARAM if Mode is not one of supported modes.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The device must be stopped to use this function.<br>
<br>
 The third mode (specified by XAE_VSTRP_SELECT) requires a method for specifying which tagged frames should be stripped. The VLAN translation table 'stripped enabled' is referenced. That configuration is handled in <a class="el" href="xaxiethernet_8h.html#4f860a127fcc5756c2dc62337eb1b934">XAxiEthernet_SetVidTable()</a>.<p>
Mode value shifting is handled in this function. No shifting is required to call this function.
</div>
</div><p>
<a class="anchor" name="44f51417734b0ca355da2e87a67aa0a3"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetVTagMode" ref="44f51417734b0ca355da2e87a67aa0a3" args="(XAxiEthernet *InstancePtr, u32 Mode, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetVTagMode           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetVTagMode configures the VLAN tagging mode.<p>
Four modes can be configured,<ul>
<li>XAE_VTAG_NONE for no tagging.</li><li>XAE_VTAG_ALL to tag all frames.</li><li>XAE_VTAG_EXISTED to tag already tagged frames.</li><li>XAE_VTAG_SELECT to tag selected already tagged frames based on VID value.</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mode</em>&nbsp;</td><td>is the VLAN tag mode. Value must be between b'00-b'11. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS. on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li><li>XST_NO_FEATURE if the Axi Ethernet does not enable or have the TX VLAN tag capability.</li><li>XST_INVALID_PARAM if Mode is not one of supported modes.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The device must be stopped to use this function.<br>
<br>
<p>
The fourth mode (specified by XAE_VTAG_SELECT) requires a method for specifying which tagged frames should receive an additional VLAN tag. The VLAN translation table 'tag enabled' is referenced. That configuration is handled in <a class="el" href="xaxiethernet_8h.html#4f860a127fcc5756c2dc62337eb1b934">XAxiEthernet_SetVidTable()</a>.<p>
Mode value shifting is handled in this function. No shifting is required to call this function.
</div>
</div><p>
<a class="anchor" name="43d59456dc8e08f671745c70e48e9a59"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_SetVTagValue" ref="43d59456dc8e08f671745c70e48e9a59" args="(XAxiEthernet *InstancePtr, u32 VTagValue, int Dir)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetVTagValue           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>VTagValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Dir</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetVTagValue configures the VLAN tagging value.<p>
The device must be stopped to use this function.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VTagValue</em>&nbsp;</td><td>is the VLAN tag value to be configured. A 32bit value. TPID, one of the following 16 bit values, 0x8100, 0x88a8, 0x9100, 0x9200. Priority, 3 bits CFI, 1 bit VID, 12 bits </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Dir</em>&nbsp;</td><td>must be either XAE_TX or XAE_RX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion, returns .</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device is not stopped.</li><li>XST_NO_FEATURE if the Axi Ethernet does not enable/have TX VLAN tag capability.</li><li>XST_INVALID_PARAM, if the TPID is not one the four supported values.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
The four supported TPID values are 0x8100, 0x88a8, 0x9100, 0x9200. XAxiEthernet_SetVTagValue performs verification on TPID only.<p>
Ethernet VLAN frames' VLAN type/length(2B) and tag control information(2B). Bit layout : bbbb bbbb bbbb bbbb bbb b bbbb bbbb bbbb \ / | | \ VID (12b) / \ / | CFI bit (1b) TPID (16b) priority bit (3b)
</div>
</div><p>
<a class="anchor" name="2cfa48d42e55238f6f30aff6d658e4fe"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_Start" ref="2cfa48d42e55238f6f30aff6d658e4fe" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_Start           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_Start starts the Axi Ethernet device as follows:<ul>
<li>Enable transmitter if XAE_TRANSMIT_ENABLE_OPTION is set</li><li>Enable receiver if XAE_RECEIVER_ENABLE_OPTION is set</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e952a55f342f176ba9ec2b49e2e47cb"></a><!-- doxytag: member="xaxiethernet.h::XAxiEthernet_Stop" ref="4e952a55f342f176ba9ec2b49e2e47cb" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_Stop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_Stop gracefully stops the Axi Ethernet device as follows:<ul>
<li>Disable all interrupts from this device</li><li>Disable the receiver</li></ul>
<p>
XAxiEthernet_Stop does not modify any of the current device options.<p>
Since the transmitter is not disabled, frames currently in internal buffers or in process by a DMA engine are allowed to be transmitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
