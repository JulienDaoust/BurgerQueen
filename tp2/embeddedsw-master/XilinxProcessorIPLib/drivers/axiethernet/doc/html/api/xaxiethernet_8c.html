<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xaxiethernet.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xaxiethernet.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
The APIs in this file takes care of the primary functionalities of the driver. The APIs in this driver take care of the following:<ul>
<li>Starting or stopping the Axi Ethernet device</li><li>Initializing and resetting the Axi Ethernet device</li><li>Setting MAC address and speed/duplex of the device</li><li>Provide means for controlling the PHY and communicating with it.</li><li>Turn on/off various features/options provided by the Axi Ethernet device. See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a detailed description of the driver. <pre>
 MODIFICATION HISTORY:</pre></li></ul>
<p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a asa  6/30/10 First release based on the ll temac driver
 1.02a asa  2/16/11 Made changes in XAxiEthernet_Reset to insert delays.
 3.02a srt  4/13/13 Removed Warnings (CR 704998).</pre><p>
<pre> </pre>
<p>
<code>#include &quot;<a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#2073b83b66f7ef2415b829f70603ac35">xdbg_stmnt</a> (int indent_on=0;) xdbg_stmnt(u32 _xaxiethernet_rir_value</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#73871df4ff59ae908c63c51db94f1a90">XAxiEthernet_CfgInitialize</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, <a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a> *CfgPtr, u32 EffectiveAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#2cfa48d42e55238f6f30aff6d658e4fe">XAxiEthernet_Start</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#4e952a55f342f176ba9ec2b49e2e47cb">XAxiEthernet_Stop</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#091a291d11f394e3eaf0b79195666d9f">XAxiEthernet_Reset</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#b2298b2b1af89cf0f0a78d4fda03ed7f">XAxiEthernet_SetMacAddress</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#a5b70a456ac18505132f61f596428ab7">XAxiEthernet_GetMacAddress</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#e3265620b9d9b86643abe5ff5e2b7d79">XAxiEthernet_SetOptions</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#d3e7253d626c02a96ac35f981ac11ba2">XAxiEthernet_ClearOptions</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#f48b8f321b842bfb139b473ad7185874">XAxiEthernet_GetOptions</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#8e8caa9c4ac753744bd08ebf103877c3">XAxiEthernet_GetOperatingSpeed</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#b2d0106f26a1a2e1f2b902dc0a2822c9">XAxiEthernet_SetOperatingSpeed</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u16 Speed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#3db57c4a261afc854985297afed2373b">XAxiEthernet_SetBadFrmRcvOption</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#ab45f6c7a4440bc3f58d4ff971e6be7b">XAxiEthernet_ClearBadFrmRcvOption</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#41049ca22799d42d1279461be627c72e">XAxiEthernet_DisableControlFrameLenCheck</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#8b71bcdc8be6ae5d6364c59ea0f53aab">XAxiEthernet_EnableControlFrameLenCheck</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#2b33bc77237bf039c02d4619a811aed6">XAxiEthernet_PhySetMdioDivisor</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u8 Divisor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#6dc70adcb2c07eb801facc8e2243ea98">XAxiEthernet_PhyRead</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xaxiethernet_8c.html#9394dd066a7497ed9346b26457c28247">XAxiEthernet_PhyWrite</a> (<a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="73871df4ff59ae908c63c51db94f1a90"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_CfgInitialize" ref="73871df4ff59ae908c63c51db94f1a90" args="(XAxiEthernet *InstancePtr, XAxiEthernet_Config *CfgPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet___config.html">XAxiEthernet_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_CfgInitialize initializes an AXI Ethernet device along with the <em>InstancePtr</em> that references it.<p>
The PHY is setup independently from the Ethernet core. Use the MII or whatever other interface may be present for setup.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the memory instance to be associated with the AXI Ethernet core instance upon initialization. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>references the structure holding the hardware configuration for the Axi Ethernet core to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the processor address used to access the base address of the AXI Ethernet instance. In systems with an MMU and virtual memory, <em>EffectiveAddress</em> is the virtual address mapped to the physical in <code>ConfigPtr-&gt;Config.BaseAddress</code>. In systems without an active MMU, <em>EffectiveAddress</em> should be set to the same value as <code>ConfigPtr-&gt;Config.BaseAddress</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab45f6c7a4440bc3f58d4ff971e6be7b"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_ClearBadFrmRcvOption" ref="ab45f6c7a4440bc3f58d4ff971e6be7b" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_ClearBadFrmRcvOption           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_ClearBadFrmRcvOption is used to disable the bad frame receive option.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3e7253d626c02a96ac35f981ac11ba2"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_ClearOptions" ref="d3e7253d626c02a96ac35f981ac11ba2" args="(XAxiEthernet *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_ClearOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_ClearOptions clears the options, <em>Options</em> for the Axi Ethernet, specified by <em>InstancePtr</em>. Axi Ethernet should be stopped with <a class="el" href="xaxiethernet_8c.html#4e952a55f342f176ba9ec2b49e2e47cb">XAxiEthernet_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>is a bitmask of OR'd XAE_*_OPTION values for options to clear. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the device has not been stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41049ca22799d42d1279461be627c72e"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_DisableControlFrameLenCheck" ref="41049ca22799d42d1279461be627c72e" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_DisableControlFrameLenCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_DisableControlFrameLenCheck is used to disable the length check for control frames (pause frames). This means once the API is called, control frames larger than the minimum frame length are accepted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b71bcdc8be6ae5d6364c59ea0f53aab"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_EnableControlFrameLenCheck" ref="8b71bcdc8be6ae5d6364c59ea0f53aab" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_EnableControlFrameLenCheck           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_EnableControlFrameLenCheck is used to enable the length check for control frames (pause frames). After calling the API, all control frames received will be checked for proper length (less than minimum frame length). By default, upon normal start up, control frame length check is enabled. Hence this API needs to be called only if previously the control frame length check has been disabled by calling the API XAxiEthernet_DisableControlFrameLenCheck.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5b70a456ac18505132f61f596428ab7"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_GetMacAddress" ref="a5b70a456ac18505132f61f596428ab7" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_GetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetMacAddress gets the MAC address for the Axi Ethernet, specified by <em>InstancePtr</em> into the memory buffer specified by <em>AddressPtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved MAC address. This memory buffer must be at least 6 bytes in length.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine also supports the extended/new VLAN and multicast mode. The XAE_RAF_NEWFNCENBL_MASK bit dictates which offset will be configured.
</div>
</div><p>
<a class="anchor" name="8e8caa9c4ac753744bd08ebf103877c3"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_GetOperatingSpeed" ref="8e8caa9c4ac753744bd08ebf103877c3" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XAxiEthernet_GetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetOperatingSpeed gets the current operating link speed. This may be the value set by <a class="el" href="xaxiethernet_8c.html#b2d0106f26a1a2e1f2b902dc0a2822c9">XAxiEthernet_SetOperatingSpeed()</a> or a hardware default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns the link speed in units of megabits per second (10 / 100 / 1000). Can return a value of 0, in case it does not get a valid speed from EMMC.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f48b8f321b842bfb139b473ad7185874"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_GetOptions" ref="f48b8f321b842bfb139b473ad7185874" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XAxiEthernet_GetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_GetOptions returns the current option settings.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returns a bitmask of XAE_*_OPTION constants, each bit specifying an option that is currently active.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6dc70adcb2c07eb801facc8e2243ea98"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_PhyRead" ref="6dc70adcb2c07eb801facc8e2243ea98" args="(XAxiEthernet *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 *PhyDataPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_PhyRead           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>PhyDataPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2b33bc77237bf039c02d4619a811aed6"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_PhySetMdioDivisor" ref="2b33bc77237bf039c02d4619a811aed6" args="(XAxiEthernet *InstancePtr, u8 Divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_PhySetMdioDivisor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_PhySetMdioDivisor sets the MDIO clock divisor in the Axi Ethernet,specified by <em>InstancePtr</em> to the value, <em>Divisor</em>. This function must be called once after each reset prior to accessing MII PHY registers.<p>
From the Virtex-6(TM) and Spartan-6 (TM) Embedded Tri-Mode Ethernet MAC User's Guide, the following equation governs the MDIO clock to the PHY:<p>
<pre>
 			f[HOSTCLK]
	f[MDC] = -----------------------
			(1 + Divisor) * 2
 </pre><p>
where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster access.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the Axi Ethernet instance on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is the divisor value to set within the range of 0 to XAE_MDIO_MC_CLK_DVD_MAX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9394dd066a7497ed9346b26457c28247"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_PhyWrite" ref="9394dd066a7497ed9346b26457c28247" args="(XAxiEthernet *InstancePtr, u32 PhyAddress, u32 RegisterNum, u16 PhyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_PhyWrite           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>PhyAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>RegisterNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>PhyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="091a291d11f394e3eaf0b79195666d9f"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_Reset" ref="091a291d11f394e3eaf0b79195666d9f" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_Reset           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_Reset does not perform a soft reset of the AxiEthernet core. AxiEthernet hardware is reset by the device connected to the AXI4-Stream interface. This function inserts some delay before proceeding to check for MgtRdy bit. The delay is necessary to be at a safe side. It takes a while for the reset process to complete and for any of the AxiEthernet registers to be accessed. It then checks for MgtRdy bit in IS register to know if AxiEthernet reset is completed or not. Subsequently it calls one more driver function to complete the AxiEthernet hardware initialization.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>It is the responsibility of the user to reset the AxiEthernet hardware before using it. AxiEthernet hardware should be reset through the device connected to the AXI4-Stream interface of AxiEthernet. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3db57c4a261afc854985297afed2373b"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_SetBadFrmRcvOption" ref="3db57c4a261afc854985297afed2373b" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_SetBadFrmRcvOption           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetBadFrmRcvOption is used to enable the bad frame receive option. If enabled, this option ensures that bad receive frames are allowed and passed to the AXI4-Stream interface as if they are good frames.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2298b2b1af89cf0f0a78d4fda03ed7f"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_SetMacAddress" ref="b2298b2b1af89cf0f0a78d4fda03ed7f" args="(XAxiEthernet *InstancePtr, void *AddressPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetMacAddress           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>AddressPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetMacAddress sets the MAC address for the Axi Ethernet device, specified by <em>InstancePtr</em> to the MAC address specified by <em>AddressPtr</em>. The Axi Ethernet device must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a reference to the 6-byte MAC address to set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the Axi Ethernet device has not stopped,</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>This routine also supports the extended/new VLAN and multicast mode. The XAE_RAF_NEWFNCENBL_MASK bit dictates which offset will be configured. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b2d0106f26a1a2e1f2b902dc0a2822c9"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_SetOperatingSpeed" ref="b2d0106f26a1a2e1f2b902dc0a2822c9" args="(XAxiEthernet *InstancePtr, u16 Speed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetOperatingSpeed           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Speed</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetOperatingSpeed sets the current operating link speed. For any traffic to be passed, this speed must match the current MII/GMII/SGMII/RGMII link speed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the Axi Ethernet on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Speed</em>&nbsp;</td><td>is the speed to set in units of Mbps. Valid values are 10, 100, or 1000.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>- XST_SUCCESS on successful setting of speed.<ul>
<li>XST_FAILURE, if the speed cannot be set for the present harwdare configuration.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e3265620b9d9b86643abe5ff5e2b7d79"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_SetOptions" ref="e3265620b9d9b86643abe5ff5e2b7d79" args="(XAxiEthernet *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XAxiEthernet_SetOptions           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_SetOptions enables the options, <em>Options</em> for the Axi Ethernet, specified by <em>InstancePtr</em>. Axi Ethernet should be stopped with <a class="el" href="xaxiethernet_8c.html#4e952a55f342f176ba9ec2b49e2e47cb">XAxiEthernet_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>is a bitmask of OR'd XAE_*_OPTION values for options to set. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS on successful completion.</li><li>XST_DEVICE_IS_STARTED if the device has not been stopped.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xaxiethernet_8h.html">xaxiethernet.h</a> for a description of the available options. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2cfa48d42e55238f6f30aff6d658e4fe"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_Start" ref="2cfa48d42e55238f6f30aff6d658e4fe" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_Start           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_Start starts the Axi Ethernet device as follows:<ul>
<li>Enable transmitter if XAE_TRANSMIT_ENABLE_OPTION is set</li><li>Enable receiver if XAE_RECEIVER_ENABLE_OPTION is set</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e952a55f342f176ba9ec2b49e2e47cb"></a><!-- doxytag: member="xaxiethernet.c::XAxiEthernet_Stop" ref="4e952a55f342f176ba9ec2b49e2e47cb" args="(XAxiEthernet *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XAxiEthernet_Stop           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_axi_ethernet.html">XAxiEthernet</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XAxiEthernet_Stop gracefully stops the Axi Ethernet device as follows:<ul>
<li>Disable all interrupts from this device</li><li>Disable the receiver</li></ul>
<p>
XAxiEthernet_Stop does not modify any of the current device options.<p>
Since the transmitter is not disabled, frames currently in internal buffers or in process by a DMA engine are allowed to be transmitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Axi Ethernet instance to be worked on. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2073b83b66f7ef2415b829f70603ac35"></a><!-- doxytag: member="xaxiethernet.c::xdbg_stmnt" ref="2073b83b66f7ef2415b829f70603ac35" args="(int indent_on=0;) xdbg_stmnt(u32 _xaxiethernet_rir_value" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xdbg_stmnt           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>indent_on</em> = <code>0;</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved.
