<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver spi v4_1: xspi.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xspi.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xspi__l_8h.html">xspi_l.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_spi.html">XSpi</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#ac73788f9de392e303cc87e84835ac3aa">XSPI_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#aa9075007c45d749e3b9bd24a37f9d908">XSpi_IntrGlobalEnable</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a5035851f7c130da994d9deec67c89b5f">XSpi_IntrGlobalDisable</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr),  XSP_DGIER_OFFSET, 0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a2210a78f1a4bc86250be33e8093e686c">XSpi_IsIntrGlobalEnabled</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a01dc10ba2ca5c1e5ff30ecd0cadac140">XSpi_IntrGetStatus</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_IISR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#ab883b734cc9b78985dae611df2f4725a">XSpi_IntrClear</a>(InstancePtr, ClearMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a85f2b8305794c31bc41ebd35ffeb4892">XSpi_IntrEnable</a>(InstancePtr, EnableMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a48c1f7712f55bbb65d7b68c92b818f78">XSpi_IntrDisable</a>(InstancePtr, DisableMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a049583711085eb8c9c47b2ef7907bf43">XSpi_IntrGetEnabled</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr),  XSP_IIER_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>(InstancePtr, Mask)&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET, (Mask))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#af65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_SR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a91ec4e1ee207bcb26d5aaf84e0324a9e">XSpi_SetXipControlReg</a>(InstancePtr, Mask)&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET, (Mask))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#aac0eb471df51c6af1a3a0a68b68d3808">XSpi_GetXipControlReg</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a3b64cb823a81025224b87a5d26a4fa39">XSpi_GetXipStatusReg</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_SR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#ae93befb10305b5abccc5483b73e60060">XSpi_SetSlaveSelectReg</a>(InstancePtr, Mask)&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr), XSP_SSR_OFFSET, (Mask))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a5c8ab7387ce196ce3309dc68bd15e489">XSpi_GetSlaveSelectReg</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XSpi_ReadReg((InstancePtr)-&gt;BaseAddr, XSP_SSR_OFFSET)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a1ddf2c25474dac11bd30c9f938bd753d">XSpi_Enable</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a642e3f4be4784f5823c368a0afdfe078">XSpi_Disable</a>(InstancePtr)</td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a> The following options may be specified or retrieved for the device and enable/disable additional features of the SPI. Each of the options are bit fields, so more than one may be specified. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#ac2c043a14b04e38a61b1979ccaa8a200">XSP_MASTER_OPTION</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#aae8f6e43593b5e57c47c4834f69a01a9">XSP_CLK_ACTIVE_LOW_OPTION</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#abac3788ad6ebce692e4b3382c623c329">XSP_CLK_PHASE_1_OPTION</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a1124f7ede8e4ebe96f2c764b0dadfea1">XSP_LOOPBACK_OPTION</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#aeb7ff246ee212e9fa1379769aae76f47">XSP_MANUAL_SSELECT_OPTION</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#aa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a> )(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#aa1fb3e31ba804cc87dc309847fb02471">XSpi_Initialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#abb66639f19a883edad862d7cd0e77ad2">XSpi_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a48d8cea3864b01b7eed7320e83beacf1">XSpi_CfgInitialize</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a87fdaad742a2669200c9b2617e5c86ea">XSpi_Start</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#ad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a343938fcdf672bec329d876a146178cd">XSpi_Reset</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a162523a3e9b29f063701db303ac8cf17">XSpi_SetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 SlaveMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a8043891b8f68a3291bd035be74aa6b94">XSpi_GetSlaveSelect</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a4c44c082ef2d2b9cf4ba3db8bcebd954">XSpi_Transfer</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#abc09f4d503de2a772e5079ac46fc62b6">XSpi_SetStatusHandler</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, void *CallBackRef, <a class="el" href="xspi_8h.html#aa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a> FuncPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#af3863f11d27469d8797424319601c980">XSpi_InterruptHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a11b6ebdb6f69c6939176e05600b10e3e">XSpi_SelfTest</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a8a40aee30eb6f0240b75e6ccd7596a53">XSpi_GetStats</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, <a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> *StatsPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#af243ac522e14869af82545ffc11d5821">XSpi_ClearStats</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#a67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xspi_8h.html#af55cfd2072ed2047c0fe0b65bd0fcf6a">XSpi_GetOptions</a> (<a class="el" href="struct_x_spi.html">XSpi</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="aae8f6e43593b5e57c47c4834f69a01a9"></a><!-- doxytag: member="xspi.h::XSP_CLK_ACTIVE_LOW_OPTION" ref="aae8f6e43593b5e57c47c4834f69a01a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CLK_ACTIVE_LOW_OPTION&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="abac3788ad6ebce692e4b3382c623c329"></a><!-- doxytag: member="xspi.h::XSP_CLK_PHASE_1_OPTION" ref="abac3788ad6ebce692e4b3382c623c329" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_CLK_PHASE_1_OPTION&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1124f7ede8e4ebe96f2c764b0dadfea1"></a><!-- doxytag: member="xspi.h::XSP_LOOPBACK_OPTION" ref="a1124f7ede8e4ebe96f2c764b0dadfea1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_LOOPBACK_OPTION&nbsp;&nbsp;&nbsp;0x8</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb7ff246ee212e9fa1379769aae76f47"></a><!-- doxytag: member="xspi.h::XSP_MANUAL_SSELECT_OPTION" ref="aeb7ff246ee212e9fa1379769aae76f47" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_MANUAL_SSELECT_OPTION&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2c043a14b04e38a61b1979ccaa8a200"></a><!-- doxytag: member="xspi.h::XSP_MASTER_OPTION" ref="ac2c043a14b04e38a61b1979ccaa8a200" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSP_MASTER_OPTION&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<pre>
 The Master option configures the SPI device as a master. By default, the
 device is a slave.</pre><pre> The Active Low Clock option configures the device's clock polarity. Setting
 this option means the clock is active low and the SCK signal idles high. By
 default, the clock is active high and SCK idles low.</pre><pre> The Clock Phase option configures the SPI device for one of two transfer
 formats.  A clock phase of 0, the default, means data if valid on the first
 SCK edge (rising or falling) after the slave select (SS) signal has been
 asserted. A clock phase of 1 means data is valid on the second SCK edge
 (rising or falling) after SS has been asserted.</pre><pre> The Loopback option configures the SPI device for loopback mode.  Data is
 looped back from the transmitter to the receiver.</pre><pre> The Manual Slave Select option, which is default, causes the device not
 to automatically drive the slave select.  The driver selects the device
 at the start of a transfer and deselects it at the end of a transfer.
 If this option is off, then the device automatically toggles the slave
 select signal between bytes in a transfer.
 </pre>
</div>
</div>
<a class="anchor" id="a642e3f4be4784f5823c368a0afdfe078"></a><!-- doxytag: member="xspi.h::XSpi_Disable" ref="a642e3f4be4784f5823c368a0afdfe078" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_Disable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xspi_8h.html#a3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>((InstancePtr), \
        <a class="code" href="xspi_8h.html#a7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>((InstancePtr)) &amp; ~<a class="code" href="xspi__l_8h.html#a1c10904273bbeb8fb8fc502c5cc9cdf6">XSP_CR_ENABLE_MASK</a>)
</pre></div><p>Disable the device. Preserves the current contents of the control register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a642e3f4be4784f5823c368a0afdfe078">XSpi_Disable(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a1ddf2c25474dac11bd30c9f938bd753d"></a><!-- doxytag: member="xspi.h::XSpi_Enable" ref="a1ddf2c25474dac11bd30c9f938bd753d" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_Enable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{ \
        u16 Control; \
        Control = <a class="code" href="xspi_8h.html#a7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg</a>((InstancePtr)); \
        Control |= <a class="code" href="xspi__l_8h.html#a1c10904273bbeb8fb8fc502c5cc9cdf6">XSP_CR_ENABLE_MASK</a>; \
        Control &amp;= ~<a class="code" href="xspi__l_8h.html#a2d045067441152dbf5729d4dce64032b">XSP_CR_TRANS_INHIBIT_MASK</a>; \
        <a class="code" href="xspi_8h.html#a3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg</a>((InstancePtr), Control); \
}
</pre></div><p>Enable the device and uninhibit master transactions. Preserves the current contents of the control register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a1ddf2c25474dac11bd30c9f938bd753d">XSpi_Enable(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a7988663ef9d2523ef167413fd6e8ab87"></a><!-- doxytag: member="xspi.h::XSpi_GetControlReg" ref="a7988663ef9d2523ef167413fd6e8ab87" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetControlReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the contents of the control register. Use the XSP_CR_* constants defined above to interpret the bit-mask returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the control register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xspi_8h.html#a7988663ef9d2523ef167413fd6e8ab87">XSpi_GetControlReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a5c8ab7387ce196ce3309dc68bd15e489"></a><!-- doxytag: member="xspi.h::XSpi_GetSlaveSelectReg" ref="a5c8ab7387ce196ce3309dc68bd15e489" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetSlaveSelectReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg((InstancePtr)-&gt;BaseAddr, XSP_SSR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the contents of the slave select register. Each bit in the mask corresponds to a slave select line. Only one slave should be selected at any one time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 32-bit value in the slave select register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xspi_8h.html#a5c8ab7387ce196ce3309dc68bd15e489">XSpi_GetSlaveSelectReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="af65c9e65699c1746d205a77554d40adb"></a><!-- doxytag: member="xspi.h::XSpi_GetStatusReg" ref="af65c9e65699c1746d205a77554d40adb" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetStatusReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_SR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the contents of the status register. Use the XSP_SR_* constants defined above to interpret the bit-mask returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An 32-bit value representing the contents of the status register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u8 <a class="el" href="xspi_8h.html#af65c9e65699c1746d205a77554d40adb">XSpi_GetStatusReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="aac0eb471df51c6af1a3a0a68b68d3808"></a><!-- doxytag: member="xspi.h::XSpi_GetXipControlReg" ref="aac0eb471df51c6af1a3a0a68b68d3808" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetXipControlReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the contents of the XIP control register. Use the XSP_CR_XIP_* constants defined above to interpret the bit-mask returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the control register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xspi_8h.html#aac0eb471df51c6af1a3a0a68b68d3808">XSpi_GetXipControlReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a3b64cb823a81025224b87a5d26a4fa39"></a><!-- doxytag: member="xspi.h::XSpi_GetXipStatusReg" ref="a3b64cb823a81025224b87a5d26a4fa39" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_GetXipStatusReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_SR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the contents of the status register. Use the XSP_SR_XIP_* constants defined above to interpret the bit-mask returned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An 32-bit value representing the contents of the status register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u8 <a class="el" href="xspi_8h.html#a3b64cb823a81025224b87a5d26a4fa39">XSpi_GetXipStatusReg(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ac73788f9de392e303cc87e84835ac3aa"></a><!-- doxytag: member="xspi.h::XSPI_H" ref="ac73788f9de392e303cc87e84835ac3aa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSPI_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab883b734cc9b78985dae611df2f4725a"></a><!-- doxytag: member="xspi.h::XSpi_IntrClear" ref="ab883b734cc9b78985dae611df2f4725a" args="(InstancePtr, ClearMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrClear</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ClearMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xspi__l_8h.html#a32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="code" href="xspi__l_8h.html#a2bc4dc18547b8bdd05c5eb2b73c9ff7d">XSP_IISR_OFFSET</a>,      \
                <a class="code" href="xspi_8h.html#a01dc10ba2ca5c1e5ff30ecd0cadac140">XSpi_IntrGetStatus</a>(InstancePtr) | (ClearMask))
</pre></div><p>This function clears the specified interrupts in the Interrupt status Register. The interrupt is cleared by writing to this register with the bits to be cleared set to a one and all others bits to zero. Setting a bit which is zero within this register causes an interrupt to be generated.</p>
<p>This function writes only the specified value to the register such that some status bits may be set and others cleared. It is the caller's responsibility to get the value of the register prior to setting the value to prevent an destructive behavior.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ClearMask</em>&nbsp;</td><td>is the Bitmask for interrupts to be cleared. Bit positions of "1" clears the interrupt. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#ab883b734cc9b78985dae611df2f4725a">XSpi_IntrClear(XSpi *InstancePtr, u32 ClearMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a48c1f7712f55bbb65d7b68c92b818f78"></a><!-- doxytag: member="xspi.h::XSpi_IntrDisable" ref="a48c1f7712f55bbb65d7b68c92b818f78" args="(InstancePtr, DisableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrDisable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DisableMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xspi__l_8h.html#a32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="code" href="xspi__l_8h.html#ace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>,       \
                <a class="code" href="xspi__l_8h.html#a5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr),                 \
                        <a class="code" href="xspi__l_8h.html#ace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>) &amp; (~ ((DisableMask) &amp; <a class="code" href="xspi__l_8h.html#af2c321040c3a93daa19aa3fcc77c86e8">XSP_INTR_ALL</a> )))
</pre></div><p>Disable the specified Interrupts in the Interrupt Enable Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DisableMask</em>&nbsp;</td><td>is the bitmask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a48c1f7712f55bbb65d7b68c92b818f78">XSpi_IntrDisable(XSpi *InstancePtr, u32 DisableMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a85f2b8305794c31bc41ebd35ffeb4892"></a><!-- doxytag: member="xspi.h::XSpi_IntrEnable" ref="a85f2b8305794c31bc41ebd35ffeb4892" args="(InstancePtr, EnableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrEnable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnableMask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xspi__l_8h.html#a32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="code" href="xspi__l_8h.html#ace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>,       \
                (<a class="code" href="xspi__l_8h.html#a5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr),                \
                        <a class="code" href="xspi__l_8h.html#ace876b867131a62e5407d440c73d6693">XSP_IIER_OFFSET</a>)) | (((EnableMask) &amp; <a class="code" href="xspi__l_8h.html#af2c321040c3a93daa19aa3fcc77c86e8">XSP_INTR_ALL</a> )))
</pre></div><p>This function sets the contents of the Interrupt Enable Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EnableMask</em>&nbsp;</td><td>is the bitmask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSP_INTR_* bits defined in <a class="el" href="xspi__l_8h.html">xspi_l.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a85f2b8305794c31bc41ebd35ffeb4892">XSpi_IntrEnable(XSpi *InstancePtr, u32 EnableMask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a049583711085eb8c9c47b2ef7907bf43"></a><!-- doxytag: member="xspi.h::XSpi_IntrGetEnabled" ref="a049583711085eb8c9c47b2ef7907bf43" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGetEnabled</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr),  XSP_IIER_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the contents of the Interrupt Enable Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The contents read from the Interrupt Enable Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xspi_8h.html#a049583711085eb8c9c47b2ef7907bf43">XSpi_IntrGetEnabled(XSpi *InstancePtr)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a01dc10ba2ca5c1e5ff30ecd0cadac140"></a><!-- doxytag: member="xspi.h::XSpi_IntrGetStatus" ref="a01dc10ba2ca5c1e5ff30ecd0cadac140" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGetStatus</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_ReadReg(((InstancePtr)-&gt;BaseAddr), XSP_IISR_OFFSET)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the contents of the Interrupt Status Register. This register indicates the status of interrupt sources for the device. The status is independent of whether interrupts are enabled such that the status register may also be polled when interrupts are not enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A status which contains the value read from the Interrupt Status Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xspi_8h.html#a01dc10ba2ca5c1e5ff30ecd0cadac140">XSpi_IntrGetStatus(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a5035851f7c130da994d9deec67c89b5f"></a><!-- doxytag: member="xspi.h::XSpi_IntrGlobalDisable" ref="a5035851f7c130da994d9deec67c89b5f" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGlobalDisable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr),  XSP_DGIER_OFFSET, 0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro disables all interrupts for the device by writing to the Global interrupt enable register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a5035851f7c130da994d9deec67c89b5f">XSpi_IntrGlobalDisable(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="aa9075007c45d749e3b9bd24a37f9d908"></a><!-- doxytag: member="xspi.h::XSpi_IntrGlobalEnable" ref="aa9075007c45d749e3b9bd24a37f9d908" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IntrGlobalEnable</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xspi__l_8h.html#a32e741800118678aa060ef2a13661e31">XSpi_WriteReg</a>(((InstancePtr)-&gt;BaseAddr),  <a class="code" href="xspi__l_8h.html#a3a66b8345fe53a19c2da1a8162dc366d">XSP_DGIER_OFFSET</a>,     \
                        <a class="code" href="xspi__l_8h.html#a492a1b3f6bb367fbb9e88b514722b13c">XSP_GINTR_ENABLE_MASK</a>)
</pre></div><p>This macro writes to the global interrupt enable register to enable interrupts from the device.</p>
<p>Interrupts enabled using <a class="el" href="xspi_8h.html#a85f2b8305794c31bc41ebd35ffeb4892">XSpi_IntrEnable()</a> will not occur until the global interrupt enable bit is set by using this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#aa9075007c45d749e3b9bd24a37f9d908">XSpi_IntrGlobalEnable(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a2210a78f1a4bc86250be33e8093e686c"></a><!-- doxytag: member="xspi.h::XSpi_IsIntrGlobalEnabled" ref="a2210a78f1a4bc86250be33e8093e686c" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_IsIntrGlobalEnabled</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(<a class="code" href="xspi__l_8h.html#a5e55891344ab473841b6eefc2bda35a2">XSpi_ReadReg</a>(((InstancePtr)-&gt;BaseAddr), <a class="code" href="xspi__l_8h.html#a3a66b8345fe53a19c2da1a8162dc366d">XSP_DGIER_OFFSET</a>) ==  \
                <a class="code" href="xspi__l_8h.html#a492a1b3f6bb367fbb9e88b514722b13c">XSP_GINTR_ENABLE_MASK</a>)
</pre></div><p>This function determines if interrupts are enabled at the global level by reading the global interrupt register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if global interrupts are enabled.</li>
<li>FALSE if global interrupts are disabled.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xspi_8h.html#a2210a78f1a4bc86250be33e8093e686c">XSpi_IsIntrGlobalEnabled(XSpi *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a3a33f7848a49e60041668c726eb14110"></a><!-- doxytag: member="xspi.h::XSpi_SetControlReg" ref="a3a33f7848a49e60041668c726eb14110" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_SetControlReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET, (Mask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the contents of the control register. Use the XSP_CR_* constants defined above to create the bit-mask to be written to the register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32-bit value to write to the control register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a3a33f7848a49e60041668c726eb14110">XSpi_SetControlReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="ae93befb10305b5abccc5483b73e60060"></a><!-- doxytag: member="xspi.h::XSpi_SetSlaveSelectReg" ref="ae93befb10305b5abccc5483b73e60060" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_SetSlaveSelectReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr), XSP_SSR_OFFSET, (Mask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the contents of the slave select register. Each bit in the mask corresponds to a slave select line. Only one slave should be selected at any one time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32-bit value to write to the slave select register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#ae93befb10305b5abccc5483b73e60060">XSpi_SetSlaveSelectReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a91ec4e1ee207bcb26d5aaf84e0324a9e"></a><!-- doxytag: member="xspi.h::XSpi_SetXipControlReg" ref="a91ec4e1ee207bcb26d5aaf84e0324a9e" args="(InstancePtr, Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSpi_SetXipControlReg</td>
          <td>(</td>
          <td class="paramtype">InstancePtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mask&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;XSpi_WriteReg(((InstancePtr)-&gt;BaseAddr), XSP_CR_OFFSET, (Mask))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the contents of the XIP control register. Use the XSP_CR_XIP_* constants defined above to create the bit-mask to be written to the register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32-bit value to write to the control register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xspi_8h.html#a91ec4e1ee207bcb26d5aaf84e0324a9e">XSpi_SetXipControlReg(XSpi *InstancePtr, u32 Mask)</a>; </dd></dl>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aa9c3c5101d73a626380c46bcc906069e"></a><!-- doxytag: member="xspi.h::XSpi_StatusHandler" ref="aa9c3c5101d73a626380c46bcc906069e" args=")(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xspi_8h.html#aa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a>)(void *CallBackRef, u32 StatusEvent, unsigned int ByteCount)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The handler data type allows the user to define a callback function to handle the asynchronous processing of the SPI driver. The application using this driver is expected to define a handler of this type to support interrupt driven mode. The handler executes in an interrupt context such that minimal processing should be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>A callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusEvent</em>&nbsp;</td><td>Indicates one or more status events that occurred. See the <a class="el" href="xspi_8c.html#abc09f4d503de2a772e5079ac46fc62b6">XSpi_SetStatusHandler()</a> for details on the status events that can be passed in the callback. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>Indicates how many bytes of data were successfully transferred. This may be less than the number of bytes requested if the status event indicates an error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a48d8cea3864b01b7eed7320e83beacf1"></a><!-- doxytag: member="xspi.h::XSpi_CfgInitialize" ref="a48d8cea3864b01b7eed7320e83beacf1" args="(XSpi *InstancePtr, XSpi_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_spi.html">XSpi</a> instance such that the driver is ready to use.</p>
<p>The state of the device after initialization is:</p>
<ul>
<li>Device is disabled</li>
<li>Slave mode</li>
<li>Active high clock polarity</li>
<li>Clock phase 0</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific SPI device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_DEVICE_IS_STARTED if the device is started. It must be stopped to re-initialize.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af243ac522e14869af82545ffc11d5821"></a><!-- doxytag: member="xspi.h::XSpi_ClearStats" ref="af243ac522e14869af82545ffc11d5821" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the statistics for the SPI device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Statistics are not updated in polled mode of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="af55cfd2072ed2047c0fe0b65bd0fcf6a"></a><!-- doxytag: member="xspi.h::XSpi_GetOptions" ref="af55cfd2072ed2047c0fe0b65bd0fcf6a" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSpi_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the options for the SPI device. The options control how the device behaves relative to the SPI bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>Options contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSP_*_OPTIONS in the file <a class="el" href="xspi_8h.html">xspi.h</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8043891b8f68a3291bd035be74aa6b94"></a><!-- doxytag: member="xspi.h::XSpi_GetSlaveSelect" ref="a8043891b8f68a3291bd035be74aa6b94" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSpi_GetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets the current slave select bit mask for the SPI device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value returned is a 32-bit mask with a 1 in the bit position of the slave currently selected. The value may be zero if no slaves are selected.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API is used to get the current slave select bit mask that was set using the XSpi_SetSlaveSelect API. This API deos not read the register from the core and returns the slave select register stored in the instance pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a40aee30eb6f0240b75e6ccd7596a53"></a><!-- doxytag: member="xspi.h::XSpi_GetStats" ref="a8a40aee30eb6f0240b75e6ccd7596a53" args="(XSpi *InstancePtr, XSpi_Stats *StatsPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> *&nbsp;</td>
          <td class="paramname"> <em>StatsPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets a copy of the statistics for an SPI device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatsPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_spi___stats.html">XSpi_Stats</a> structure which will get a copy of current statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Statistics are not updated in polled mode of operation. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1fb3e31ba804cc87dc309847fb02471"></a><!-- doxytag: member="xspi.h::XSpi_Initialize" ref="aa1fb3e31ba804cc87dc309847fb02471" args="(XSpi *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_spi.html">XSpi</a> instance such that the driver is ready to use.</p>
<p>The state of the device after initialization is:</p>
<ul>
<li>Device is disabled</li>
<li>Slave mode</li>
<li>Active high clock polarity</li>
<li>Clock phase 0</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_spi.html">XSpi</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_spi.html">XSpi</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_DEVICE_IS_STARTED if the device is started. It must be stopped to re-initialize.</li>
<li>XST_DEVICE_NOT_FOUND if the device was not found in the configuration such that initialization could not be accomplished.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af3863f11d27469d8797424319601c980"></a><!-- doxytag: member="xspi.h::XSpi_InterruptHandler" ref="af3863f11d27469d8797424319601c980" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interrupt handler for SPI interrupts. This function must be connected by the user to an interrupt source. This function does not save and restore the processor context such that the user must provide this processing.</p>
<p>The interrupts that are handled are:</p>
<ul>
<li>Mode Fault Error. This interrupt is generated if this device is selected as a slave when it is configured as a master. The driver aborts any data transfer that is in progress by resetting FIFOs (if present) and resetting its buffer pointers. The upper layer software is informed of the error.</li>
</ul>
<ul>
<li>Data Transmit Register (FIFO) Empty. This interrupt is generated when the transmit register or FIFO is empty. The driver uses this interrupt during a transmission to continually send/receive data until there is no more data to send/receive.</li>
</ul>
<ul>
<li>Data Transmit Register (FIFO) Underrun. This interrupt is generated when the SPI device, when configured as a slave, attempts to read an empty DTR/FIFO. An empty DTR/FIFO usually means that software is not giving the device data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Data Receive Register (FIFO) Overrun. This interrupt is generated when the SPI device attempts to write a received byte to an already full DRR/FIFO. A full DRR/FIFO usually means software is not emptying the data in a timely manner. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Slave Mode Fault Error. This interrupt is generated if a slave device is selected as a slave while it is disabled. No action is taken by the driver other than to inform the upper layer software of the error.</li>
</ul>
<ul>
<li>Command Error. This interrupt occurs when the first byte in the Tx FIFO, after the CS is asserted, doesn't match any command in the Lookup table. This interrupt is valid only for axi_qspi.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The slave select register is being set to deselect the slave when a transfer is complete. This is being done regardless of whether it is a slave or a master since the hardware does not drive the slave select as a slave. </p>

</div>
</div>
<a class="anchor" id="abb66639f19a883edad862d7cd0e77ad2"></a><!-- doxytag: member="xspi.h::XSpi_LookupConfig" ref="abb66639f19a883edad862d7cd0e77ad2" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_spi___config.html">XSpi_Config</a>* XSpi_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>contains the ID of the device to look up the configuration for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<p>A pointer to the configuration found or NULL if the specified device ID was not found. See <a class="el" href="xspi_8h.html">xspi.h</a> for the definition of <a class="el" href="struct_x_spi___config.html">XSpi_Config</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a343938fcdf672bec329d876a146178cd"></a><!-- doxytag: member="xspi.h::XSpi_Reset" ref="a343938fcdf672bec329d876a146178cd" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the SPI device by writing to the Software Reset register. Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Refer to the XSpi_Initialize function for more details. This is a hard reset of the device. Any data transfer that is in progress is aborted.</p>
<p>The upper layer software is responsible for re-configuring (if necessary) and restarting the SPI device after the reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a11b6ebdb6f69c6939176e05600b10e3e"></a><!-- doxytag: member="xspi.h::XSpi_SelfTest" ref="a11b6ebdb6f69c6939176e05600b10e3e" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Runs a self-test on the driver/device. The self-test is destructive in that a reset of the device is performed in order to check the reset values of the registers and to get the device into a known state. A simple loopback test is also performed to verify that transmit and receive are working properly. The device is changed to master mode for the loopback test, since only a master can initiate a data transfer.</p>
<p>Upon successful return from the self-test, the device is reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_REGISTER_ERROR indicates a register did not read or write correctly.</li>
<li>XST_LOOPBACK_ERROR if a loopback error occurred.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a67c2076b133a55b6f80343642a1ace41"></a><!-- doxytag: member="xspi.h::XSpi_SetOptions" ref="a67c2076b133a55b6f80343642a1ace41" args="(XSpi *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the options for the SPI device driver. The options control how the device behaves relative to the SPI bus. The device must be idle rather than busy transferring data before setting these device options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>contains the specified options to be set. This is a bit mask where a 1 means to turn the option on, and a 0 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XSP_*_OPTIONS in the file <a class="el" href="xspi_8h.html">xspi.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-XST_SUCCESS if options are successfully set.<ul>
<li>XST_DEVICE_BUSY if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
<li>XST_SPI_SLAVE_ONLY if the caller attempted to configure a slave-only device as a master.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function makes use of internal resources that are shared between the <a class="el" href="xspi_8c.html#ad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop()</a> and <a class="el" href="xspi_8h.html#a67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is required to provide protection of this shared data (typically using a semaphore). </p>

</div>
</div>
<a class="anchor" id="a162523a3e9b29f063701db303ac8cf17"></a><!-- doxytag: member="xspi.h::XSpi_SetSlaveSelect" ref="a162523a3e9b29f063701db303ac8cf17" args="(XSpi *InstancePtr, u32 SlaveMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_SetSlaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SlaveMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Selects or deselect the slave with which the master communicates. Each slave that can be selected is represented in the slave select register by a bit. The argument passed to this function is the bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected.</p>
<p>The user is not allowed to deselect the slave while a transfer is in progress. If no transfer is in progress, the user can select a new slave, which implicitly deselects the current slave. In order to explicitly deselect the current slave, a zero can be passed in as the argument to the function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveMask</em>&nbsp;</td><td>is a 32-bit mask with a 1 in the bit position of the slave being selected. Only one slave can be selected. The SlaveMask can be zero if the slave is being deselected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the slave is selected or deselected successfully.</li>
<li>XST_DEVICE_BUSY if a transfer is in progress, slave cannot be changed</li>
<li>XST_SPI_TOO_MANY_SLAVES if more than one slave is being selected.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function only sets the slave which will be selected when a transfer occurs. The slave is not selected when the SPI is idle. The slave select has no affect when the device is configured as a slave. </p>

</div>
</div>
<a class="anchor" id="abc09f4d503de2a772e5079ac46fc62b6"></a><!-- doxytag: member="xspi.h::XSpi_SetStatusHandler" ref="abc09f4d503de2a772e5079ac46fc62b6" args="(XSpi *InstancePtr, void *CallBackRef, XSpi_StatusHandler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSpi_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xspi_8h.html#aa9c3c5101d73a626380c46bcc906069e">XSpi_StatusHandler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to the higher layer software. The handler executes in an interrupt context, so it must minimize the amount of processing performed such as transferring data to a thread context. One of the following status events is passed to the status handler. </p>
<pre><ul>
<li>XST_SPI_MODE_FAULT	A mode fault error occurred, meaning another
				master tried to select this device as a slave
				when this device was configured to be a master.
				Any transfer in progress is aborted.</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_TRANSFER_DONE	The requested data transfer is done</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_TRANSMIT_UNDERRUN	As a slave device, the master clocked
				data but there were none available in the
				transmit register/FIFO. This typically means the
				slave application did not issue a transfer
				request fast enough, or the processor/driver
				could not fill the transmit register/FIFO fast
				enough.</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_RECEIVE_OVERRUN	The SPI device lost data. Data was received
				but the receive data register/FIFO was full.
				This indicates that the device is receiving data
				faster than the processor/driver can consume it.</li>
</ul>
</pre><pre><ul>
<li>XST_SPI_SLAVE_MODE_FAULT	A slave SPI device was selected as a slave while
				it was disabled.  This indicates the master is
				already transferring data (which is being
				dropped until the slave application issues a
				transfer).

 <dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.
 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back
		when the callback function is invoked.
 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
The handler is called within interrupt context, so it should do its work
 quickly and queue potentially time-consuming work to a task-level thread.
</li>
</ul>
</pre>
</div>
</div>
<a class="anchor" id="a87fdaad742a2669200c9b2617e5c86ea"></a><!-- doxytag: member="xspi.h::XSpi_Start" ref="a87fdaad742a2669200c9b2617e5c86ea" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables interrupts for the SPI device. If the Spi driver is used in interrupt mode, it is up to the user to connect the SPI interrupt handler to the interrupt controller before this function is called. If the Spi driver is used in polled mode the user has to disable the Global Interrupts after this function is called. If the device is configured with FIFOs, the FIFOs are reset at this time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started</li>
<li>XST_DEVICE_IS_STARTED if the device was already started.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4bb67cfcfe73844ffb1917b11d5284c"></a><!-- doxytag: member="xspi.h::XSpi_Stop" ref="ad4bb67cfcfe73844ffb1917b11d5284c" args="(XSpi *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function stops the SPI device by disabling interrupts and disabling the device itself. Interrupts are disabled only within the device itself. If desired, the caller is responsible for disabling interrupts in the interrupt controller and disconnecting the interrupt handler from the interrupt controller.</p>
<p>In interrupt mode, if the device is in progress of transferring data on the SPI bus, this function returns a status indicating the device is busy. The user will be notified via the status handler when the transfer is complete, and at that time can again try to stop the device. As a master, we do not allow the device to be stopped while a transfer is in progress because the slave may be left in a bad state. As a slave, we do not allow the device to be stopped while a transfer is in progress because the master is not done with its transfer yet.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the device is successfully started.</li>
<li>XST_DEVICE_BUSY if a transfer is in progress and cannot be stopped.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function makes use of internal resources that are shared between the <a class="el" href="xspi_8c.html#ad4bb67cfcfe73844ffb1917b11d5284c">XSpi_Stop()</a> and <a class="el" href="xspi_8h.html#a67c2076b133a55b6f80343642a1ace41">XSpi_SetOptions()</a> functions. So if one task might be setting device options while another is trying to stop the device, the user is is required to provide protection of this shared data (typically using a semaphore). </p>

</div>
</div>
<a class="anchor" id="a4c44c082ef2d2b9cf4ba3db8bcebd954"></a><!-- doxytag: member="xspi.h::XSpi_Transfer" ref="a4c44c082ef2d2b9cf4ba3db8bcebd954" args="(XSpi *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr, unsigned int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSpi_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_spi.html">XSpi</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>SendBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RecvBufPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfers the specified data on the SPI bus. If the SPI device is configured to be a master, this function initiates bus communication and sends/receives the data to/from the selected SPI slave. If the SPI device is configured to be a slave, this function prepares the data to be sent/received when selected by a master. For every byte sent, a byte is received.</p>
<p>This function/driver operates in interrupt mode and polled mode.</p>
<ul>
<li>In interrupt mode this function is non-blocking and the transfer is initiated by this function and completed by the interrupt service routine.</li>
<li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li>
</ul>
<p>The caller has the option of providing two different buffers for send and receive, or one buffer for both send and receive, or no buffer for receive. The receive buffer must be at least as big as the send buffer to prevent unwanted memory writes. This implies that the byte count passed in as an argument must be the smaller of the two buffers if they differ in size. Here are some sample usages: </p>
<pre>
	XSpi_Transfer(InstancePtr, SendBuf, RecvBuf, ByteCount)
	The caller wishes to send and receive, and provides two different
	buffers for send and receive.</pre><pre>	XSpi_Transfer(InstancePtr, SendBuf, NULL, ByteCount)
	The caller wishes only to send and does not care about the received
	data. The driver ignores the received data in this case.</pre><pre>	XSpi_Transfer(InstancePtr, SendBuf, SendBuf, ByteCount)
	The caller wishes to send and receive, but provides the same buffer
	for doing both. The driver sends the data and overwrites the send
	buffer with received data as it transfers the data.</pre><pre>	XSpi_Transfer(InstancePtr, RecvBuf, RecvBuf, ByteCount)
	The caller wishes to only receive and does not care about sending
	data.  In this case, the caller must still provide a send buffer, but
	it can be the same as the receive buffer if the caller does not care
	what it sends. The device must send N bytes of data if it wishes to
	receive N bytes of data.
 </pre><p> In interrupt mode, though this function takes a buffer as an argument, the driver can only transfer a limited number of bytes at time. It transfers only one byte at a time if there are no FIFOs, or it can transfer the number of bytes up to the size of the FIFO if FIFOs exist.</p>
<ul>
<li>In interrupt mode a call to this function only starts the transfer, the subsequent transfer of the data is performed by the interrupt service routine until the entire buffer has been transferred.The status callback function is called when the entire buffer has been sent/received.</li>
<li>In polled mode this function is blocking and the control exits this function only after all the requested data is transferred.</li>
</ul>
<p>As a master, the SetSlaveSelect function must be called prior to this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_spi.html">XSpi</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SendBufPtr</em>&nbsp;</td><td>is a pointer to a buffer of data which is to be sent. This buffer must not be NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RecvBufPtr</em>&nbsp;</td><td>is a pointer to a buffer which will be filled with received data. This argument can be NULL if the caller does not wish to receive data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>contains the number of bytes to send/receive. The number of bytes received always equals the number of bytes sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>-XST_SUCCESS if the buffers are successfully handed off to the driver for transfer. Otherwise, returns:<ul>
<li>XST_DEVICE_IS_STOPPED if the device must be started before transferring data.</li>
<li>XST_DEVICE_BUSY indicates that a data transfer is already in progress. This is determined by the driver.</li>
<li>XST_SPI_NO_SLAVE indicates the device is configured as a master and a slave has not yet been selected.</li>
</ul>
</dd></dl>
<p>This function is not thread-safe. The higher layer software must ensure that no two threads are transferring data on the SPI bus at the same time. </p>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
