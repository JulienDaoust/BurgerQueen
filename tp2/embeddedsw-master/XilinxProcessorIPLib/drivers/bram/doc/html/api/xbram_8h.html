<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver bram v4_0: xbram.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xbram.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xbram__hw_8h.html">xbram_hw.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_bram___config.html">XBram_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_bram.html">XBram</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#a8ae16f138ed82f6a96a7de60091a8bda">XBRAM_H</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_bram___config.html">XBram_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#a83b0781dcc957aaf3ff895495497408e">XBram_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#a3ce9315dffb9dcef3c85b6471d7ac6bf">XBram_CfgInitialize</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr, <a class="el" href="struct_x_bram___config.html">XBram_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#aedbdefb6cda5c212f03271143ccf7a98">XBram_SelfTest</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr, u8 IntMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#a4210a263bd85db259a74c20cd0b0176c">XBram_InterruptEnable</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#a9ce680e885511fdd26b6818b71b145c4">XBram_InterruptDisable</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#aa4ac1ca5c9c05eabbdea77f35ba9ac5a">XBram_InterruptClear</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#afec7418ceae662672c03a938290da9dd">XBram_InterruptGetEnabled</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xbram_8h.html#a3880bb684ad362c6bd289f3e76a98b59">XBram_InterruptGetStatus</a> (<a class="el" href="struct_x_bram.html">XBram</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a8ae16f138ed82f6a96a7de60091a8bda"></a><!-- doxytag: member="xbram.h::XBRAM_H" ref="a8ae16f138ed82f6a96a7de60091a8bda" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XBRAM_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3ce9315dffb9dcef3c85b6471d7ac6bf"></a><!-- doxytag: member="xbram.h::XBram_CfgInitialize" ref="a3ce9315dffb9dcef3c85b6471d7ac6bf" args="(XBram *InstancePtr, XBram_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XBram_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_bram___config.html">XBram_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the <a class="el" href="struct_x_bram.html">XBram</a> instance provided by the caller based on the given configuration data.</p>
<p>Nothing is done except to initialize the InstancePtr.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to an <a class="el" href="struct_x_bram.html">XBram</a> instance. The memory the pointer references must be pre-allocated by the caller. Further calls to manipulate the driver through the <a class="el" href="struct_x_bram.html">XBram</a> API must be made with this pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific BRAM device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS Initialization was successful.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4ac1ca5c9c05eabbdea77f35ba9ac5a"></a><!-- doxytag: member="xbram.h::XBram_InterruptClear" ref="aa4ac1ca5c9c05eabbdea77f35ba9ac5a" args="(XBram *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XBram_InterruptClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear pending interrupts with the provided mask. This function should be called after the software has serviced the interrupts that are pending. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the BRAM instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to clear pending interrupts for. Bit positions of 1 are cleared. This mask is formed by OR'ing bits from XBRAM_IR* bits which are contained in <a class="el" href="xbram__hw_8h.html">xbram_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ce680e885511fdd26b6818b71b145c4"></a><!-- doxytag: member="xbram.h::XBram_InterruptDisable" ref="a9ce680e885511fdd26b6818b71b145c4" args="(XBram *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XBram_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable interrupts. This function allows each specific interrupt to be disabled. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the BRAM instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to disable. Bits set to 1 are disabled. This mask is formed by OR'ing bits from XBRAM_IR* bits which are contained in <a class="el" href="xbram__hw_8h.html">xbram_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4210a263bd85db259a74c20cd0b0176c"></a><!-- doxytag: member="xbram.h::XBram_InterruptEnable" ref="a4210a263bd85db259a74c20cd0b0176c" args="(XBram *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XBram_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable interrupts. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the BRAM instance to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to enable. Bit positions of 1 are enabled. This mask is formed by OR'ing bits from XBRAM_IR* bits which are contained in <a class="el" href="xbram__hw_8h.html">xbram_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afec7418ceae662672c03a938290da9dd"></a><!-- doxytag: member="xbram.h::XBram_InterruptGetEnabled" ref="afec7418ceae662672c03a938290da9dd" args="(XBram *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XBram_InterruptGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the interrupt enable mask. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the BRAM instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A mask of bits made from XBRAM_IR* bits which are contained in <a class="el" href="xbram__hw_8h.html">xbram_hw.h</a>.</dd>
<dd>
None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3880bb684ad362c6bd289f3e76a98b59"></a><!-- doxytag: member="xbram.h::XBram_InterruptGetStatus" ref="a3880bb684ad362c6bd289f3e76a98b59" args="(XBram *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XBram_InterruptGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the status of interrupt signals. Any bit in the mask set to 1 indicates that the channel associated with the bit has asserted an interrupt condition. This function will assert if the hardware device has not been built with interrupt capabilities.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is the BRAM instance to operate on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to a mask of bits made from XBRAM_IR* bits which are contained in <a class="el" href="xbram__hw_8h.html">xbram_hw.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The interrupt status indicates the status of the device irregardless if the interrupts from the devices have been enabled or not through <a class="el" href="xbram_8h.html#a4210a263bd85db259a74c20cd0b0176c">XBram_InterruptEnable()</a>. </p>

</div>
</div>
<a class="anchor" id="a83b0781dcc957aaf3ff895495497408e"></a><!-- doxytag: member="xbram.h::XBram_LookupConfig" ref="a83b0781dcc957aaf3ff895495497408e" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_bram___config.html">XBram_Config</a>* XBram_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lookup the device configuration based on the unique device ID. The table ConfigTable contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the device identifier to lookup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>A pointer of data type <a class="el" href="struct_x_bram___config.html">XBram_Config</a> which points to the device configuration if DeviceID is found.</li>
</ul>
</dd></dl>
<ul>
<li>NULL if DeviceID is not found.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aedbdefb6cda5c212f03271143ccf7a98"></a><!-- doxytag: member="xbram.h::XBram_SelfTest" ref="aedbdefb6cda5c212f03271143ccf7a98" args="(XBram *InstancePtr, u8 IntMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XBram_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_bram.html">XBram</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>IntMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Run a self-test on the driver/device. Unless fault injection is implemented in hardware, this function only does a minimal test in which available registers (if any) are written and read.</p>
<p>With fault injection, all possible single-bit and double-bit errors are injected, and checked to the extent possible, given the implemented hardware.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_bram.html">XBram</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IntMask</em>&nbsp;</td><td>is the interrupt mask to use. When testing with interrupts, this should be set to allow interrupt generation, otherwise it should be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if fault injection/detection is working properly OR if ECC is Not Enabled in the HW.</li>
<li>XST_FAILURE if the injected fault is not correctly detected or the Control Base Address is Zero when ECC is enabled.</li>
</ul>
If the BRAM device is not present in the hardware a bus error could be generated. Other indicators of a bus error, such as registers in bridges or buses, may be necessary to determine if this function caused a bus error.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
