<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver devcfg v3_1: xdevcfg.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xdevcfg.c File Reference</h1><code>#include &quot;<a class="el" href="xdevcfg_8h.html">xdevcfg.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#afcaaa8ac67cf7316c54d1cba36e83e08">XDcfg_CfgInitialize</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, <a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *ConfigPtr, u32 EffectiveAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#abb2094cb7d36f83c4c150a3b18e8aad0">XDcfg_EnablePCAP</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a7f73a84f734f2e1996a029d8e5934b9c">XDcfg_DisablePCAP</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#acc8c10b5cc877595c1ade09e1a589296">XDcfg_SetControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#aeb69ef133b53618e896a4776b9e8f337">XDcfg_ClearControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a81a254369eea778c17c212cc95056c26">XDcfg_GetControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a1e0516cd9cdc5066e98e3c3c195c1d3c">XDcfg_SetLockRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#ad3df072e27abfff9beb69cb09567a8c1">XDcfg_GetLockRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a89e1eef15fcfe06cd0e8d8dd7e804ad1">XDcfg_SetConfigRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a3b46b8db6ea49d8c066fefe0d137b2c9">XDcfg_GetConfigRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#ae7a3e8052f73c370990b77dae5751a36">XDcfg_SetStatusRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#aaacacd5169ad7a79f09d08858f58dc8e">XDcfg_GetStatusRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a332a5c7c856e8f6637cafaa3ec69eaca">XDcfg_SetRomShadowRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a5573651d2f14ff760e36d551a49fa919">XDcfg_GetSoftwareIdRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a2739b6bce23b6e02a9076c0eba8664d4">XDcfg_SetMiscControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#aee0dfc6838f33d700fc4b8a5549b0473">XDcfg_GetMiscControlRegister</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#ab3412c2881ffaa15fd3615770a4225a7">XDcfg_IsDmaBusy</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#afda6d24be18657370c15e1e893a0ab05">XDcfg_InitiateDma</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, u32 SourcePtr, u32 DestPtr, u32 SrcWordLength, u32 DestWordLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xdevcfg_8c.html#a5a7a69cfe6e10770f82089bdd277955d">XDcfg_Transfer</a> (<a class="el" href="struct_x_dcfg.html">XDcfg</a> *InstancePtr, void *SourcePtr, u32 SrcWordLength, void *DestPtr, u32 DestWordLength, u32 TransferType)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file contains the implementation of the interface functions for <a class="el" href="struct_x_dcfg.html">XDcfg</a> driver. Refer to the header file <a class="el" href="xdevcfg_8h.html">xdevcfg.h</a> for more detailed information.</p>
<pre>
 MODIFICATION HISTORY:</pre><pre> Ver   Who Date     Changes
 ----- --- -------- ---------------------------------------------
 1.00a hvm 02/07/11 First release
 2.00a nm  05/31/12 Updated the driver for CR 660835 so that input length for
		     source/destination to the XDcfg_InitiateDma, XDcfg_Transfer
		     APIs is words (32 bit) and not bytes.
 		     Updated the notes for XDcfg_InitiateDma/XDcfg_Transfer APIs
		     to add information that 2 LSBs of the Source/Destination
		     address when equal to 2’b01 indicate the last DMA command
		     of an overall transfer.
		     Updated the XDcfg_Transfer function to use the
		     Destination Address passed to this API for secure transfers
		     instead of using 0xFFFFFFFF for CR 662197. This issue was
		     resulting in the failure of secure transfers of
		     non-bitstream images.
 2.01a nm  08/27/12 Updated the XDcfg_Transfer API to clear the
		     QUARTER_PCAP_RATE_EN bit in the control register for
		     non secure writes for CR 675543.
 2.02a nm  01/31/13 Fixed CR# 679335.
 		     Added Setting and Clearing the internal PCAP loopback.
		     Removed code for enabling/disabling AES engine as BootROM
		     locks down this setting.
		     Fixed CR# 681976.
		     Skip Checking the PCFG_INIT in case of non-secure DMA
		     loopback.
		     Fixed CR# 699558.
		     XDcfg_Transfer fails to transfer data in loopback mode.
 2.03a nm  04/19/13 Fixed CR# 703728.
		     Updated the register definitions as per the latest TRM
		     version UG585 (v1.4) November 16, 2012.
 3.0   kpc 21/02/14 Implemented new function XDcfg_ClearControlRegister
 </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="afcaaa8ac67cf7316c54d1cba36e83e08"></a><!-- doxytag: member="xdevcfg.c::XDcfg_CfgInitialize" ref="afcaaa8ac67cf7316c54d1cba36e83e08" args="(XDcfg *InstancePtr, XDcfg_Config *ConfigPtr, u32 EffectiveAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XDcfg_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg___config.html">XDcfg_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the Device Config Interface driver. This function must be called before other functions of the driver are called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is the config structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the base address for the device. It could be a virtual address if address translation is supported in the system, otherwise it is the physical address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if initialization was successful.</li>
<li>XST_DEVICE_IS_STARTED if the device has already been started.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The very first APB access to the Device Configuration Interface block needs to be a write to the UNLOCK register with the value of 0x757BDF0D. This step is to be done once after reset, any other APB access has to come after this. The APB access is considered illegal if the step is not done or if it is done incorrectly. Furthermore, if any of efuse_sec_cfg[5:0] is high, the following additional actions would be carried out. In other words, if all bits are low, the following steps are not done. 1. AES is disabled 2. All APB writes disabled 3. SoC debug fully enabled </dd></dl>

</div>
</div>
<a class="anchor" id="aeb69ef133b53618e896a4776b9e8f337"></a><!-- doxytag: member="xdevcfg.c::XDcfg_ClearControlRegister" ref="aeb69ef133b53618e896a4776b9e8f337" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_ClearControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function Clears the specified bit positions of the Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32 bit value which holds the bit positions to be cleared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f73a84f734f2e1996a029d8e5934b9c"></a><!-- doxytag: member="xdevcfg.c::XDcfg_DisablePCAP" ref="a7f73a84f734f2e1996a029d8e5934b9c" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_DisablePCAP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The functions disables the PCAP interface by clearing the PCAP mode bit in the control register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="abb2094cb7d36f83c4c150a3b18e8aad0"></a><!-- doxytag: member="xdevcfg.c::XDcfg_EnablePCAP" ref="abb2094cb7d36f83c4c150a3b18e8aad0" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_EnablePCAP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The functions enables the PCAP interface by setting the PCAP mode bit in the control register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Enable FPGA programming from PCAP interface. Enabling this bit disables all the external interfaces from programming of FPGA except for ICAP. The user needs to ensure that the FPGA is programmed through either PCAP or ICAP. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b46b8db6ea49d8c066fefe0d137b2c9"></a><!-- doxytag: member="xdevcfg.c::XDcfg_GetConfigRegister" ref="a3b46b8db6ea49d8c066fefe0d137b2c9" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetConfigRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Configuration Register with the given value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Config Register. Use the XDCFG_CFG_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a81a254369eea778c17c212cc95056c26"></a><!-- doxytag: member="xdevcfg.c::XDcfg_GetControlRegister" ref="a81a254369eea778c17c212cc95056c26" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Control Register. Use the XDCFG_CTRL_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3df072e27abfff9beb69cb09567a8c1"></a><!-- doxytag: member="xdevcfg.c::XDcfg_GetLockRegister" ref="ad3df072e27abfff9beb69cb09567a8c1" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetLockRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Lock Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Lock Register. Use the XDCFG_CR_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aee0dfc6838f33d700fc4b8a5549b0473"></a><!-- doxytag: member="xdevcfg.c::XDcfg_GetMiscControlRegister" ref="aee0dfc6838f33d700fc4b8a5549b0473" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetMiscControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Miscellaneous Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32 Bit boot software ID.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This register is locked for write once the system enters usermode. Hence API to reading the register only is provided. </dd></dl>

</div>
</div>
<a class="anchor" id="a5573651d2f14ff760e36d551a49fa919"></a><!-- doxytag: member="xdevcfg.c::XDcfg_GetSoftwareIdRegister" ref="a5573651d2f14ff760e36d551a49fa919" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetSoftwareIdRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Software ID Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32 Bit boot software ID.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This register is locked for write once the system enters usermode. Hence API for reading the register only is provided. </dd></dl>

</div>
</div>
<a class="anchor" id="aaacacd5169ad7a79f09d08858f58dc8e"></a><!-- doxytag: member="xdevcfg.c::XDcfg_GetStatusRegister" ref="aaacacd5169ad7a79f09d08858f58dc8e" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_GetStatusRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function reads the contents of the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Status Register. Use the XDCFG_STATUS_*_MASK constants defined in <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="afda6d24be18657370c15e1e893a0ab05"></a><!-- doxytag: member="xdevcfg.c::XDcfg_InitiateDma" ref="afda6d24be18657370c15e1e893a0ab05" args="(XDcfg *InstancePtr, u32 SourcePtr, u32 DestPtr, u32 SrcWordLength, u32 DestWordLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_InitiateDma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SourcePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SrcWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DestWordLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates the DMA transfer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SourcePtr</em>&nbsp;</td><td>contains a pointer to the source memory where the data is to be transferred from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the source transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>contains a pointer to the destination memory where the data is to be transferred to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the Destination transfer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the caller function to ensure that correct values are passed to this function.</dd></dl>
<p>The 2 LSBs of the SourcePtr (Source)/ DestPtr (Destination) address when equal to 2’b01 indicates the last DMA command of an overall transfer. </p>

</div>
</div>
<a class="anchor" id="ab3412c2881ffaa15fd3615770a4225a7"></a><!-- doxytag: member="xdevcfg.c::XDcfg_IsDmaBusy" ref="ab3412c2881ffaa15fd3615770a4225a7" args="(XDcfg *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_IsDmaBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function checks if DMA command queue is full.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS is the DMA is busy XST_FAILURE if the DMA is idle</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The DMA queue has a depth of two. </dd></dl>

</div>
</div>
<a class="anchor" id="a89e1eef15fcfe06cd0e8d8dd7e804ad1"></a><!-- doxytag: member="xdevcfg.c::XDcfg_SetConfigRegister" ref="a89e1eef15fcfe06cd0e8d8dd7e804ad1" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetConfigRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Configuration Register with the given value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="acc8c10b5cc877595c1ade09e1a589296"></a><!-- doxytag: member="xdevcfg.c::XDcfg_SetControlRegister" ref="acc8c10b5cc877595c1ade09e1a589296" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the 32 bit mask data to be written to the Register. The mask definitions are defined in the <a class="el" href="xdevcfg__hw_8h.html">xdevcfg_hw.h</a> file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e0516cd9cdc5066e98e3c3c195c1d3c"></a><!-- doxytag: member="xdevcfg.c::XDcfg_SetLockRegister" ref="a1e0516cd9cdc5066e98e3c3c195c1d3c" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetLockRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Lock Register. These bits can only be set to a 1. They will be cleared after a Power On Reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2739b6bce23b6e02a9076c0eba8664d4"></a><!-- doxytag: member="xdevcfg.c::XDcfg_SetMiscControlRegister" ref="a2739b6bce23b6e02a9076c0eba8664d4" args="(XDcfg *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetMiscControlRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the bit mask for the feature in Miscellaneous Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the feature to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a332a5c7c856e8f6637cafaa3ec69eaca"></a><!-- doxytag: member="xdevcfg.c::XDcfg_SetRomShadowRegister" ref="a332a5c7c856e8f6637cafaa3ec69eaca" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetRomShadowRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the ROM Shadow Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This register is can only be written and is used to control the RAM shadow of 32 bit 4K page ROM pages in user mode </dd></dl>

</div>
</div>
<a class="anchor" id="ae7a3e8052f73c370990b77dae5751a36"></a><!-- doxytag: member="xdevcfg.c::XDcfg_SetStatusRegister" ref="ae7a3e8052f73c370990b77dae5751a36" args="(XDcfg *InstancePtr, u32 Data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XDcfg_SetStatusRegister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the contents of the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Data</em>&nbsp;</td><td>is the 32 bit data to be written to the Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a7a69cfe6e10770f82089bdd277955d"></a><!-- doxytag: member="xdevcfg.c::XDcfg_Transfer" ref="a5a7a69cfe6e10770f82089bdd277955d" args="(XDcfg *InstancePtr, void *SourcePtr, u32 SrcWordLength, void *DestPtr, u32 DestWordLength, u32 TransferType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XDcfg_Transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_dcfg.html">XDcfg</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>SourcePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>SrcWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>DestPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>DestWordLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>TransferType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function starts the DMA transfer. This function only starts the operation and returns before the operation may be completed. If the interrupt is enabled, an interrupt will be generated when the operation is completed, otherwise it is necessary to poll the Status register to determine when it is completed. It is the responsibility of the caller to determine when the operation is completed by handling the generated interrupt or polling the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_dcfg.html">XDcfg</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SourcePtr</em>&nbsp;</td><td>contains a pointer to the source memory where the data is to be transferred from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SrcWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the source transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestPtr</em>&nbsp;</td><td>contains a pointer to the destination memory where the data is to be transferred to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DestWordLength</em>&nbsp;</td><td>is the number of words (32 bit) to be transferred for the Destination transfer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TransferType</em>&nbsp;</td><td>contains the type of PCAP transfer being requested. The definitions can be found in the <a class="el" href="xdevcfg_8h.html">xdevcfg.h</a> file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS.if DMA transfer initiated successfully</li>
<li>XST_DEVICE_BUSY if DMA is busy</li>
<li>XST_INVALID_PARAM if invalid Source / Destination address is sent or an invalid Source / Destination length is sent</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>It is the responsibility of the caller to ensure that the cache is flushed and invalidated both before the DMA operation is started and after the DMA operation completes if the memory pointed to is cached. The caller must also ensure that the pointers contain physical address rather than a virtual address if address translation is being used.</dd></dl>
<p>The 2 LSBs of the SourcePtr (Source)/ DestPtr (Destination) address when equal to 2’b01 indicates the last DMA command of an overall transfer. </p>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
