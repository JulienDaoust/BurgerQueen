<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver iic v3_0: xiic.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xiic.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiic__l_8h.html">xiic_l.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_iic___config.html">XIic_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_iic_stats.html">XIicStats</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_iic.html">XIic</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ab870d9c998ba5ab84b0ae511b1cb7578">XIIC_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ace6af337aea33e4f162897b40591e0ac">XII_ADDR_TO_SEND_TYPE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ab3f6ec08afcad8f35f9ee2c9e2531366">XII_ADDR_TO_RESPOND_TYPE</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a> The following options may be specified or retrieved for the device and enable/disable additional features of the IIC bus. Each of the options are bit fields such that more than one may be specified. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a44d0ebf5153203223cb5563aaa10a301">XII_GENERAL_CALL_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#aeef2d22ea6248066e075044748f78a0a">XII_REPEATED_START_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ae6c2745bbe258e992bcbe4d0724e4072">XII_SEND_10_BIT_OPTION</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td colspan="2"><div class="groupHeader">Status events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpfe694ef0d5388fbe12e4790ff0a37ef4"></a> The following status events occur during IIC bus processing and are passed to the status callback. Each event is only valid during the appropriate processing of the IIC bus. Each of these events are bit fields such that more than one may be specified. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a37e4df461ec4c6ecb22d05e4dfabd841">XII_BUS_NOT_BUSY_EVENT</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a5843af7de7006ae82767f16bb78ee84e">XII_ARB_LOST_EVENT</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ab5762b506d3e39139007bb6968cdef80">XII_SLAVE_NO_ACK_EVENT</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a35a6e58757aa1de945b5ed48640e91cf">XII_MASTER_READ_EVENT</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ab24f56a64912a6f65c6c87005c9ce892">XII_MASTER_WRITE_EVENT</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ab0181a51cd40861af2b60cd879f2dd86">XII_GENERAL_CALL_EVENT</a>&nbsp;&nbsp;&nbsp;0x00000020</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a85db866c44d23a4c6e985f2c6c647053">XIic_Handler</a> )(void *CallBackRef, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ac96e3f6975be1bdb8fe5956812855962">XIic_StatusHandler</a> )(void *CallBackRef, int StatusEvent)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ad36c610ec3139cef71f3795f9ce81308">XIic_Initialize</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_iic___config.html">XIic_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a76cccfe2cae68849eb4278db5337110e">XIic_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ae1d05b288ae1f48c484d0fd308e72f8c">XIic_CfgInitialize</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, <a class="el" href="struct_x_iic___config.html">XIic_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#aaa989e0128057bf11803825d774d496f">XIic_Stop</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a237935ed7fb41369f52d1d8a4f6fe2a6">XIic_Reset</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ad944f42c3d9972fc2c986a7eed726297">XIic_SetAddress</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, int AddressType, int Address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a3e8f77e5df8d92a4b27627e03b5e1807">XIic_GetAddress</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, int AddressType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#afe4e886e72abb9d860a6cb83c84c74a1">XIic_SetGpOutput</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 OutputValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a4108f79d22b71e2455844a8487b1a776">XIic_GetGpOutput</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *OutputValuePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#aa4b84f9d58cbd40d2633140d79e2aed4">XIic_IsSlave</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a86b4b2b307df26df2ecac39337c78bed">XIic_SetRecvHandler</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, void *CallBackRef, <a class="el" href="xiic_8h.html#a85db866c44d23a4c6e985f2c6c647053">XIic_Handler</a> FuncPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ad33428830e9016ef50c1deae59d1e604">XIic_SetSendHandler</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, void *CallBackRef, <a class="el" href="xiic_8h.html#a85db866c44d23a4c6e985f2c6c647053">XIic_Handler</a> FuncPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#aa74a6884f6dfc826a10768d7d0333991">XIic_SetStatusHandler</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, void *CallBackRef, <a class="el" href="xiic_8h.html#ac96e3f6975be1bdb8fe5956812855962">XIic_StatusHandler</a> FuncPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a50c5aa4448e8993c80ef7b6a87b1aaea">XIic_InterruptHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a337bf0d322d4a7d9b4f8baa30e00ab45">XIic_MasterRecv</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *RxMsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a977382e8a20bd5e690229f82af2e7603">XIic_MasterSend</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *TxMsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a4d7985d95cd029ab0b0f2a5ccc614793">XIic_DynMasterRecv</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *RxMsgPtr, u8 ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ac4c6388d0db3b08ddcd47f0b2459ff3c">XIic_DynMasterSend</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *TxMsgPtr, u8 ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a6f86310d413cbe343462b6488f1cf8ab">XIic_DynamicInitialize</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a543dde34d5a2f34269641ec3ab1bfdfe">XIic_SlaveInclude</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a25dc714d97f71049154461e1ff16bcad">XIic_SlaveRecv</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *RxMsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a24873473751e355c82bb074a0d42ddbc">XIic_SlaveSend</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u8 *TxMsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ae7a801efedbe489ba0e984dbf8f6daa4">XIic_GetStats</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, <a class="el" href="struct_x_iic_stats.html">XIicStats</a> *StatsPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#af56beeeacad67c0d24ad330ce5c42f90">XIic_ClearStats</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#a0a4d9b646c26bcf932561699d69d52b1">XIic_SelfTest</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#af4f74d08f52c1a9e6e1e0ee4035fe8eb">XIic_IsIicBusy</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#ae108a8105a28ba4410b3bd682a87a459">XIic_SetOptions</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#af15dd70c4f1bb34a9e35c1ca85cee841">XIic_GetOptions</a> (<a class="el" href="struct_x_iic.html">XIic</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiic_8h.html#aa8c54559d0b1cf0d86c51a0f1d3151eb">XIic_MultiMasterInclude</a> (void)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="ab3f6ec08afcad8f35f9ee2c9e2531366"></a><!-- doxytag: member="xiic.h::XII_ADDR_TO_RESPOND_TYPE" ref="ab3f6ec08afcad8f35f9ee2c9e2531366" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_ADDR_TO_RESPOND_TYPE&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This device's bus address as slave </p>

</div>
</div>
<a class="anchor" id="ace6af337aea33e4f162897b40591e0ac"></a><!-- doxytag: member="xiic.h::XII_ADDR_TO_SEND_TYPE" ref="ace6af337aea33e4f162897b40591e0ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_ADDR_TO_SEND_TYPE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bus address of slave device </p>

</div>
</div>
<a class="anchor" id="a5843af7de7006ae82767f16bb78ee84e"></a><!-- doxytag: member="xiic.h::XII_ARB_LOST_EVENT" ref="a5843af7de7006ae82767f16bb78ee84e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_ARB_LOST_EVENT&nbsp;&nbsp;&nbsp;0x00000002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Arbitration was lost </p>

</div>
</div>
<a class="anchor" id="a37e4df461ec4c6ecb22d05e4dfabd841"></a><!-- doxytag: member="xiic.h::XII_BUS_NOT_BUSY_EVENT" ref="a37e4df461ec4c6ecb22d05e4dfabd841" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_BUS_NOT_BUSY_EVENT&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bus transitioned to not busy </p>

</div>
</div>
<a class="anchor" id="ab0181a51cd40861af2b60cd879f2dd86"></a><!-- doxytag: member="xiic.h::XII_GENERAL_CALL_EVENT" ref="ab0181a51cd40861af2b60cd879f2dd86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_GENERAL_CALL_EVENT&nbsp;&nbsp;&nbsp;0x00000020</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>General call to all slaves </p>

</div>
</div>
<a class="anchor" id="a44d0ebf5153203223cb5563aaa10a301"></a><!-- doxytag: member="xiic.h::XII_GENERAL_CALL_OPTION" ref="a44d0ebf5153203223cb5563aaa10a301" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_GENERAL_CALL_OPTION&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<pre>
 XII_GENERAL_CALL_OPTION	The general call option allows an IIC slave to
				recognized the general call address. The status
				handler is called as usual indicating the device
				has been addressed as a slave with a general
				call. It is the application's responsibility to
				perform any special processing for the general
				call.</pre><pre> XII_REPEATED_START_OPTION	The repeated start option allows multiple
				messages to be sent/received on the IIC bus
				without rearbitrating for the bus.  The messages
				are sent as a series of messages such that the
				option must be enabled before the 1st message of
				the series, to prevent an stop condition from
				being generated on the bus, and disabled before
				the last message of the series, to allow the
				stop condition to be generated.</pre><pre> XII_SEND_10_BIT_OPTION	The send 10 bit option allows 10 bit addresses
				to be sent on the bus when the device is a
				master. The device can be configured to respond
				as to 7 bit addresses even though it may be
				communicating with other devices that support 10
				bit addresses.  When this option is not enabled,
				only 7 bit addresses are sent on the bus.</pre><pre> </pre>
</div>
</div>
<a class="anchor" id="a35a6e58757aa1de945b5ed48640e91cf"></a><!-- doxytag: member="xiic.h::XII_MASTER_READ_EVENT" ref="a35a6e58757aa1de945b5ed48640e91cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_MASTER_READ_EVENT&nbsp;&nbsp;&nbsp;0x00000008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Master reading from slave </p>

</div>
</div>
<a class="anchor" id="ab24f56a64912a6f65c6c87005c9ce892"></a><!-- doxytag: member="xiic.h::XII_MASTER_WRITE_EVENT" ref="ab24f56a64912a6f65c6c87005c9ce892" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_MASTER_WRITE_EVENT&nbsp;&nbsp;&nbsp;0x00000010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Master writing to slave </p>

</div>
</div>
<a class="anchor" id="aeef2d22ea6248066e075044748f78a0a"></a><!-- doxytag: member="xiic.h::XII_REPEATED_START_OPTION" ref="aeef2d22ea6248066e075044748f78a0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_REPEATED_START_OPTION&nbsp;&nbsp;&nbsp;0x00000002</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae6c2745bbe258e992bcbe4d0724e4072"></a><!-- doxytag: member="xiic.h::XII_SEND_10_BIT_OPTION" ref="ae6c2745bbe258e992bcbe4d0724e4072" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_SEND_10_BIT_OPTION&nbsp;&nbsp;&nbsp;0x00000004</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5762b506d3e39139007bb6968cdef80"></a><!-- doxytag: member="xiic.h::XII_SLAVE_NO_ACK_EVENT" ref="ab5762b506d3e39139007bb6968cdef80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XII_SLAVE_NO_ACK_EVENT&nbsp;&nbsp;&nbsp;0x00000004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slave did not ACK (had error) </p>

</div>
</div>
<a class="anchor" id="ab870d9c998ba5ab84b0ae511b1cb7578"></a><!-- doxytag: member="xiic.h::XIIC_H" ref="ab870d9c998ba5ab84b0ae511b1cb7578" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIIC_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a85db866c44d23a4c6e985f2c6c647053"></a><!-- doxytag: member="xiic.h::XIic_Handler" ref="a85db866c44d23a4c6e985f2c6c647053" args=")(void *CallBackRef, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiic_8h.html#a85db866c44d23a4c6e985f2c6c647053">XIic_Handler</a>)(void *CallBackRef, int ByteCount)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback function data type is defined to handle the asynchronous processing of sent and received data of the IIC driver. The application using this driver is expected to define a handler of this type to support interrupt driven mode. The handlers are called in an interrupt context such that minimal processing should be performed. The handler data type is utilized for both send and receive handlers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>indicates the number of bytes remaining to be sent or received. A value of zero indicates that the requested number of bytes were sent or received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac96e3f6975be1bdb8fe5956812855962"></a><!-- doxytag: member="xiic.h::XIic_StatusHandler" ref="ac96e3f6975be1bdb8fe5956812855962" args=")(void *CallBackRef, int StatusEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiic_8h.html#ac96e3f6975be1bdb8fe5956812855962">XIic_StatusHandler</a>)(void *CallBackRef, int StatusEvent)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This callback function data type is defined to handle the asynchronous processing of status events of the IIC driver. The application using this driver is expected to define a handler of this type to support interrupt driven mode. The handler is called in an interrupt context such that minimal processing should be performed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is unimportant to the driver component, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusEvent</em>&nbsp;</td><td>indicates one or more status events that occurred. See the definition of the status events above. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ae1d05b288ae1f48c484d0fd308e72f8c"></a><!-- doxytag: member="xiic.h::XIic_CfgInitialize" ref="ae1d05b288ae1f48c484d0fd308e72f8c" args="(XIic *InstancePtr, XIic_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_iic___config.html">XIic_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>Config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_iic.html">XIic</a> instance. The initialization entails:</p>
<ul>
<li>Initialize the driver to allow access to the device registers and initialize other subcomponents necessary for the operation of the device.</li>
<li>Default options to:<ul>
<li>7-bit slave addressing</li>
<li>Send messages as a slave device</li>
<li>Repeated start off</li>
<li>General call recognition disabled</li>
</ul>
</li>
<li>Clear messageing and error statistics</li>
</ul>
<p>The <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> function must be called after this function before the device is ready to send and receive data on the IIC bus.</p>
<p>Before <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> is called, the interrupt control must connect the ISR routine to the interrupt handler. This is done by the user, and not <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> to allow the user to use an interrupt controller of their choice.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Config</em>&nbsp;</td><td>is a reference to a structure containing information about a specific IIC device. This function can initialize multiple instance objects with the use of multiple calls giving different Config information on each call. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use Config-&gt;BaseAddress for this parameters, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS when successful</li>
<li>XST_DEVICE_IS_STARTED indicates the device is started (i.e. interrupts enabled and messaging is possible). Must stop before re-initialization is allowed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af56beeeacad67c0d24ad330ce5c42f90"></a><!-- doxytag: member="xiic.h::XIic_ClearStats" ref="af56beeeacad67c0d24ad330ce5c42f90" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_ClearStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the statistics for the IIC device by zeroing all counts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f86310d413cbe343462b6488f1cf8ab"></a><!-- doxytag: member="xiic.h::XIic_DynamicInitialize" ref="a6f86310d413cbe343462b6488f1cf8ab" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_DynamicInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d7985d95cd029ab0b0f2a5ccc614793"></a><!-- doxytag: member="xiic.h::XIic_DynMasterRecv" ref="a4d7985d95cd029ab0b0f2a5ccc614793" args="(XIic *InstancePtr, u8 *RxMsgPtr, u8 ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_DynMasterRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RxMsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives data as a master from a slave device on the IIC bus. If the bus is busy, it will indicate so and then enable an interrupt such that the status handler will be called when the bus is no longer busy. The slave address which has been set with the <a class="el" href="xiic_8c.html#ad944f42c3d9972fc2c986a7eed726297">XIic_SetAddress()</a> function is the address from which data is received. Receiving data on the bus performs a read operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Iic instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RxMsgPtr</em>&nbsp;</td><td>is a pointer to the data to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of message bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>- XST_SUCCESS indicates the message reception processes has been initiated.<ul>
<li>XST_IIC_BUS_BUSY indicates the bus was in use and that the BusNotBusy interrupt is enabled which will update the EventStatus when the bus is no longer busy.</li>
<li>XST_IIC_GENERAL_CALL_ADDRESS indicates the slave address is set to the general call address. This is not allowed for Master receive mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The receive FIFO threshold is a zero based count such that 1 must be subtracted from the desired count to get the correct value. When receiving data it is also necessary to not receive the last byte with the prior bytes because the acknowledge must be setup before the last byte is received. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4c6388d0db3b08ddcd47f0b2459ff3c"></a><!-- doxytag: member="xiic.h::XIic_DynMasterSend" ref="ac4c6388d0db3b08ddcd47f0b2459ff3c" args="(XIic *InstancePtr, u8 *TxMsgPtr, u8 ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_DynMasterSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TxMsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends data as a Dynamic master on the IIC bus. If the bus is busy, it will indicate so and then enable an interrupt such that the status handler will be called when the bus is no longer busy. The slave address is sent by using <a class="el" href="xiic__l_8h.html#a81d32f9fd29736e9f9c7ef345527386b">XIic_DynSend7BitAddress()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>points to the Iic instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxMsgPtr</em>&nbsp;</td><td>points to the data to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of message bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS if successful else XST_FAILURE.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3e8f77e5df8d92a4b27627e03b5e1807"></a><!-- doxytag: member="xiic.h::XIic_GetAddress" ref="a3e8f77e5df8d92a4b27627e03b5e1807" args="(XIic *InstancePtr, int AddressType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XIic_GetAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>AddressType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the addresses for the IIC device driver. The addresses include the device address that the device responds to as a slave, or the slave address to communicate with on the bus. The address returned has the same format whether 7 or 10 bits.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressType</em>&nbsp;</td><td>indicates which address, the address which this responds to on the IIC bus as a slave, or the slave address to communicate with when this device is a master. One of the following values must be contained in this argument. </p>
<pre>
   XII_ADDR_TO_SEND_TYPE	Slave being addressed as a master
   XII_ADDR_TO_RESPOND_TYPE	Slave address to respond to as a slave
 </pre><p> If neither of the two valid arguments are used, the function returns the address of the slave device</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The address retrieved.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a4108f79d22b71e2455844a8487b1a776"></a><!-- doxytag: member="xiic.h::XIic_GetGpOutput" ref="a4108f79d22b71e2455844a8487b1a776" args="(XIic *InstancePtr, u8 *OutputValuePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_GetGpOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>OutputValuePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the contents of the General Purpose Output register for the IIC device driver. Note that the number of bits in this register is parameterizable in the hardware such that it may not exist. This function checks to ensure that it does exist to prevent bus errors.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputValuePtr</em>&nbsp;</td><td>contains the value which was read from the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given data is read from the GPO register.</li>
<li>XST_NO_FEATURE if the hardware is configured such that this register does not contain any bits to read or write.</li>
</ul>
</dd></dl>
<p>The OutputValuePtr is also an output as it contains the value read.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af15dd70c4f1bb34a9e35c1ca85cee841"></a><!-- doxytag: member="xiic.h::XIic_GetOptions" ref="af15dd70c4f1bb34a9e35c1ca85cee841" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIic_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the current options for the IIC device. Options control the how the device behaves on the IIC bus. See SetOptions for more information on options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The options of the IIC device. See <a class="el" href="xiic_8h.html">xiic.h</a> for a list of available options.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>Options enabled will have a 1 in its appropriate bit position. </p>

</div>
</div>
<a class="anchor" id="ae7a801efedbe489ba0e984dbf8f6daa4"></a><!-- doxytag: member="xiic.h::XIic_GetStats" ref="ae7a801efedbe489ba0e984dbf8f6daa4" args="(XIic *InstancePtr, XIicStats *StatsPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_GetStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_iic_stats.html">XIicStats</a> *&nbsp;</td>
          <td class="paramname"> <em>StatsPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gets a copy of the statistics for an IIC device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatsPtr</em>&nbsp;</td><td>is a pointer to a <a class="el" href="struct_x_iic_stats.html">XIicStats</a> structure which will get a copy of current statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad36c610ec3139cef71f3795f9ce81308"></a><!-- doxytag: member="xiic.h::XIic_Initialize" ref="ad36c610ec3139cef71f3795f9ce81308" args="(XIic *InstancePtr, u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_Initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_iic.html">XIic</a> instance. The initialization entails:</p>
<ul>
<li>Check the device has an entry in the configuration table.</li>
<li>Initialize the driver to allow access to the device registers and initialize other subcomponents necessary for the operation of the device.</li>
<li>Default options to:<ul>
<li>7-bit slave addressing</li>
<li>Send messages as a slave device</li>
<li>Repeated start off</li>
<li>General call recognition disabled</li>
</ul>
</li>
<li>Clear messageing and error statistics</li>
</ul>
<p>The <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> function must be called after this function before the device is ready to send and receive data on the IIC bus.</p>
<p>Before <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> is called, the interrupt control must connect the ISR routine to the interrupt handler. This is done by the user, and not <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> to allow the user to use an interrupt controller of their choice.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique id of the device controlled by this <a class="el" href="struct_x_iic.html">XIic</a> instance. Passing in a device id associates the generic <a class="el" href="struct_x_iic.html">XIic</a> instance to a specific device, as chosen by the caller or application developer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS when successful</li>
<li>XST_DEVICE_NOT_FOUND indicates the given device id isn't found</li>
<li>XST_DEVICE_IS_STARTED indicates the device is started (i.e. interrupts enabled and messaging is possible). Must stop before re-initialization is allowed.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a50c5aa4448e8993c80ef7b6a87b1aaea"></a><!-- doxytag: member="xiic.h::XIic_InterruptHandler" ref="a50c5aa4448e8993c80ef7b6a87b1aaea" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_InterruptHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is the interrupt handler for the <a class="el" href="struct_x_iic.html">XIic</a> driver. This function should be connected to the interrupt system.</p>
<p>Only one interrupt source is handled for each interrupt allowing higher priority system interrupts quicker response time.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af4f74d08f52c1a9e6e1e0ee4035fe8eb"></a><!-- doxytag: member="xiic.h::XIic_IsIicBusy" ref="af4f74d08f52c1a9e6e1e0ee4035fe8eb" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIic_IsIicBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4b84f9d58cbd40d2633140d79e2aed4"></a><!-- doxytag: member="xiic.h::XIic_IsSlave" ref="aa4b84f9d58cbd40d2633140d79e2aed4" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIic_IsSlave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A function to determine if the device is currently addressed as a slave.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is addressed as slave.</li>
<li>FALSE if the device is NOT addressed as slave.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a76cccfe2cae68849eb4278db5337110e"></a><!-- doxytag: member="xiic.h::XIic_LookupConfig" ref="a76cccfe2cae68849eb4278db5337110e" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_iic___config.html">XIic_Config</a>* XIic_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. The table IicConfigTable contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID to look for</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the configuration data of the device, or NULL if no match is found.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a337bf0d322d4a7d9b4f8baa30e00ab45"></a><!-- doxytag: member="xiic.h::XIic_MasterRecv" ref="a337bf0d322d4a7d9b4f8baa30e00ab45" args="(XIic *InstancePtr, u8 *RxMsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_MasterRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RxMsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives data as a master from a slave device on the IIC bus. If the bus is busy, it will indicate so and then enable an interrupt such that the status handler will be called when the bus is no longer busy. The slave address which has been set with the <a class="el" href="xiic_8c.html#ad944f42c3d9972fc2c986a7eed726297">XIic_SetAddress()</a> function is the address from which data is received. Receiving data on the bus performs a read operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Iic instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RxMsgPtr</em>&nbsp;</td><td>is a pointer to the data to be transmitted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of message bytes to be sent</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS indicates the message reception processes has been initiated.</li>
<li>XST_IIC_BUS_BUSY indicates the bus was in use and that the BusNotBusy interrupt is enabled which will update the EventStatus when the bus is no longer busy.</li>
<li>XST_IIC_GENERAL_CALL_ADDRESS indicates the slave address is set to the the general call address. This is not allowed for Master receive mode. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a977382e8a20bd5e690229f82af2e7603"></a><!-- doxytag: member="xiic.h::XIic_MasterSend" ref="a977382e8a20bd5e690229f82af2e7603" args="(XIic *InstancePtr, u8 *TxMsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_MasterSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TxMsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends data as a master on the IIC bus. If the bus is busy, it will indicate so and then enable an interrupt such that the status handler will be called when the bus is no longer busy. The slave address which has been set with the <a class="el" href="xiic_8c.html#ad944f42c3d9972fc2c986a7eed726297">XIic_SetAddress()</a> function is the address to which the specific data is sent. Sending data on the bus performs a write operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>points to the Iic instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxMsgPtr</em>&nbsp;</td><td>points to the data to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of message bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS indicates the message transmission has been initiated.</li>
<li>XST_IIC_BUS_BUSY indicates the bus was in use and that the BusNotBusy interrupt is enabled which will update the EventStatus when the bus is no longer busy.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8c54559d0b1cf0d86c51a0f1d3151eb"></a><!-- doxytag: member="xiic.h::XIic_MultiMasterInclude" ref="aa8c54559d0b1cf0d86c51a0f1d3151eb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_MultiMasterInclude </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function includes multi-master code such that multi-master events are handled properly. Multi-master events include a loss of arbitration and the bus transitioning from busy to not busy. This function allows the multi-master processing to be optional. This function must be called prior to allowing any multi-master events to occur, such as after the driver is initialized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a237935ed7fb41369f52d1d8a4f6fe2a6"></a><!-- doxytag: member="xiic.h::XIic_Reset" ref="a237935ed7fb41369f52d1d8a4f6fe2a6" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the IIC device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The complete IIC core is Reset on giving a software reset to the IIC core. Some previous versions of the core only reset the Interrupt Logic/Registers, please refer to the HW specification for futher details about this. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a4d9b646c26bcf932561699d69d52b1"></a><!-- doxytag: member="xiic.h::XIic_SelfTest" ref="a0a4d9b646c26bcf932561699d69d52b1" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Runs a limited self-test on the driver/device. This test does a read/write test of the Interrupt Registers There is no loopback capabilities for the device such that this test does not send or receive data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if no errors are found</li>
<li>XST_FAILURE if errors are found</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad944f42c3d9972fc2c986a7eed726297"></a><!-- doxytag: member="xiic.h::XIic_SetAddress" ref="ad944f42c3d9972fc2c986a7eed726297" args="(XIic *InstancePtr, int AddressType, int Address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_SetAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>AddressType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>Address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the bus addresses. The addresses include the device address that the device responds to as a slave, or the slave address to communicate with on the bus. The IIC device hardware is built to allow either 7 or 10 bit slave addressing only at build time rather than at run time. When this device is a master, slave addressing can be selected at run time to match addressing modes for other bus devices.</p>
<p>Addresses are represented as hex values with no adjustment for the data direction bit as the software manages address bit placement. Example: For a 7 address written to the device of 1010 011X where X is the transfer direction (send/recv), the address parameter for this function needs to be 01010011 or 0x53 where the correct bit alllignment will be handled for 7 as well as 10 bit devices. This is especially important as the bit placement is not handled the same depending on which options are used such as repeated start.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressType</em>&nbsp;</td><td>indicates which address is being modified, the address which this device responds to on the IIC bus as a slave, or the slave address to communicate with when this device is a master. One of the following values must be contained in this argument. </p>
<pre>
   XII_ADDR_TO_SEND_TYPE	Slave being addressed by a this master
   XII_ADDR_TO_RESPOND_TYPE	Address to respond to as a slave device
 </pre></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Address</em>&nbsp;</td><td>contains the address to be set, 7 bit or 10 bit address. A ten bit address must be within the range: 0 - 1023 and a 7 bit address must be within the range 0 - 127.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS is returned if the address was successfully set.</li>
<li>XST_IIC_NO_10_BIT_ADDRESSING indicates only 7 bit addressing supported.</li>
<li>XST_INVALID_PARAM indicates an invalid parameter was specified.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>Upper bits of 10-bit address is written only when current device is built as a ten bit device. </p>

</div>
</div>
<a class="anchor" id="afe4e886e72abb9d860a6cb83c84c74a1"></a><!-- doxytag: member="xiic.h::XIic_SetGpOutput" ref="afe4e886e72abb9d860a6cb83c84c74a1" args="(XIic *InstancePtr, u8 OutputValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_SetGpOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>OutputValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the contents of the General Purpose Output register for the IIC device driver. Note that the number of bits in this register is parameterizable in the hardware such that it may not exist. This function checks to ensure that it does exist to prevent bus errors, but does not ensure that the number of bits in the register are sufficient for the value being written (won't cause a bus error).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutputValue</em>&nbsp;</td><td>contains the value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given data is written to the GPO register.</li>
<li>XST_NO_FEATURE if the hardware is configured such that this register does not contain any bits to read or write.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae108a8105a28ba4410b3bd682a87a459"></a><!-- doxytag: member="xiic.h::XIic_SetOptions" ref="ae108a8105a28ba4410b3bd682a87a459" args="(XIic *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>NewOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the options for the IIC device driver. The options control how the device behaves relative to the IIC bus. If an option applies to how messages are sent or received on the IIC bus, it must be set prior to calling functions which send or receive data.</p>
<p>To set multiple options, the values must be ORed together. To not change existing options, read/modify/write with the current options using <a class="el" href="xiic_8h.html#af15dd70c4f1bb34a9e35c1ca85cee841">XIic_GetOptions()</a>.</p>
<p><b>USAGE EXAMPLE:</b></p>
<p>Read/modify/write to enable repeated start: </p>
<pre>
   u8 Options;
   Options = XIic_GetOptions(&amp;Iic);
   XIic_SetOptions(&amp;Iic, Options | XII_REPEATED_START_OPTION);
 </pre><p>Disabling General Call: </p>
<pre>
   Options = XIic_GetOptions(&amp;Iic);
   XIic_SetOptions(&amp;Iic, Options &amp;= ~XII_GENERAL_CALL_OPTION);
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NewOptions</em>&nbsp;</td><td>are the options to be set. See <a class="el" href="xiic_8h.html">xiic.h</a> for a list of the available options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>Sending or receiving messages with repeated start enabled, and then disabling repeated start, will not take effect until another master transaction is completed. i.e. After using repeated start, the bus will continue to be throttled after repeated start is disabled until a master transaction occurs allowing the IIC to release the bus. <br/>
<br/>
 Options enabled will have a 1 in its appropriate bit position. </p>

</div>
</div>
<a class="anchor" id="a86b4b2b307df26df2ecac39337c78bed"></a><!-- doxytag: member="xiic.h::XIic_SetRecvHandler" ref="a86b4b2b307df26df2ecac39337c78bed" args="(XIic *InstancePtr, void *CallBackRef, XIic_Handler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_SetRecvHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiic_8h.html#a85db866c44d23a4c6e985f2c6c647053">XIic_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the receive callback function, the receive handler, which the driver calls when it finishes receiving data. The number of bytes used to signal when the receive is complete is the number of bytes set in the XIic_Recv function.</p>
<p>The handler executes in an interrupt context such that it must minimize the amount of processing performed such as transferring data to a thread context.</p>
<p>The number of bytes received is passed to the handler as an argument.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The handler is called within interrupt context . </dd></dl>

</div>
</div>
<a class="anchor" id="ad33428830e9016ef50c1deae59d1e604"></a><!-- doxytag: member="xiic.h::XIic_SetSendHandler" ref="ad33428830e9016ef50c1deae59d1e604" args="(XIic *InstancePtr, void *CallBackRef, XIic_Handler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_SetSendHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiic_8h.html#a85db866c44d23a4c6e985f2c6c647053">XIic_Handler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the send callback function, the send handler, which the driver calls when it receives confirmation of sent data. The handler executes in an interrupt context such that it must minimize the amount of processing performed such as transferring data to a thread context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>the pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The handler is called within interrupt context . </dd></dl>

</div>
</div>
<a class="anchor" id="aa74a6884f6dfc826a10768d7d0333991"></a><!-- doxytag: member="xiic.h::XIic_SetStatusHandler" ref="aa74a6884f6dfc826a10768d7d0333991" args="(XIic *InstancePtr, void *CallBackRef, XIic_StatusHandler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiic_8h.html#ac96e3f6975be1bdb8fe5956812855962">XIic_StatusHandler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the status callback function, the status handler, which the driver calls when it encounters conditions which are not data related. The handler executes in an interrupt context such that it must minimize the amount of processing performed such as transferring data to a thread context. The status events that can be returned are described in <a class="el" href="xiic_8h.html">xiic.h</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>points to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The handler is called within interrupt context . </dd></dl>

</div>
</div>
<a class="anchor" id="a543dde34d5a2f34269641ec3ab1bfdfe"></a><!-- doxytag: member="xiic.h::XIic_SlaveInclude" ref="a543dde34d5a2f34269641ec3ab1bfdfe" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIic_SlaveInclude </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function includes slave code such that slave events will be processsed. It is necessary to allow slave code to be optional to reduce the size of the driver. This function may be called at any time but must be prior to being selected as a slave on the IIC bus. This function may be called prior to the Cfg_Initialize() function and must be called before any functions in this file are called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>None.</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a25dc714d97f71049154461e1ff16bcad"></a><!-- doxytag: member="xiic.h::XIic_SlaveRecv" ref="a25dc714d97f71049154461e1ff16bcad" args="(XIic *InstancePtr, u8 *RxMsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_SlaveRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RxMsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends data as a slave on the IIC bus and should not be called until an event has occurred that indicates the device has been selected by a master attempting read from the slave (XII_MASTER_READ_EVENT).</p>
<p>If more data is received than specified a No Acknowledge will be sent to signal the Master to stop sending data. Any received data is read to prevent the slave device from throttling the bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Iic instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RxMsgPtr</em>&nbsp;</td><td>is a pointer to the data to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of message bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS indicates the message transmission has been initiated.</li>
<li>XST_IIC_NOT_SLAVE indicates the device has not been selected to be a slave on the IIC bus such that data cannot be received. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a24873473751e355c82bb074a0d42ddbc"></a><!-- doxytag: member="xiic.h::XIic_SlaveSend" ref="a24873473751e355c82bb074a0d42ddbc" args="(XIic *InstancePtr, u8 *TxMsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_SlaveSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TxMsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends data as a slave on the IIC bus and should not be called until an event has occurred that indicates the device has been selected by a master attempting read from the slave (XII_MASTER_READ_EVENT).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxMsgPtr</em>&nbsp;</td><td>is a pointer to the data to be transmitted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of message bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS indicates the message transmission has been initiated.</li>
<li>XST_IIC_NOT_SLAVE indicates the device has not been selected to be a slave on the IIC bus such that data cannot be sent.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f4e497710a9c3719f27d40faa74a10f"></a><!-- doxytag: member="xiic.h::XIic_Start" ref="a5f4e497710a9c3719f27d40faa74a10f" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function starts the IIC device and driver by enabling the proper interrupts such that data may be sent and received on the IIC bus. This function must be called before the functions to send and receive data.</p>
<p>Before <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> is called, the interrupt control must connect the ISR routine to the interrupt handler. This is done by the user, and not <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> to allow the user to use an interrupt controller of their choice.</p>
<p>Start enables:</p>
<ul>
<li>IIC device</li>
<li>Interrupts:<ul>
<li>Addressed as slave to allow messages from another master</li>
<li>Arbitration Lost to detect Tx arbitration errors</li>
<li>Global IIC interrupt</li>
</ul>
</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>XST_SUCCESS always.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The device interrupt is connected to the interrupt controller, but no "messaging" interrupts are enabled. Addressed as Slave is enabled to reception of messages when this devices address is written to the bus. The correct messaging interrupts are enabled when sending or receiving via the IicSend() and IicRecv() functions. No action is required by the user to control any IIC interrupts as the driver completely manages all 8 interrupts. Start and Stop control the ability to use the device. Stopping the device completely stops all device interrupts from the processor. </p>

</div>
</div>
<a class="anchor" id="aaa989e0128057bf11803825d774d496f"></a><!-- doxytag: member="xiic.h::XIic_Stop" ref="aaa989e0128057bf11803825d774d496f" args="(XIic *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIic_Stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic.html">XIic</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function stops the IIC device and driver such that data is no longer sent or received on the IIC bus. This function stops the device by disabling interrupts. This function only disables interrupts within the device such that the caller is responsible for disconnecting the interrupt handler of the device from the interrupt source and disabling interrupts at other levels.</p>
<p>Due to bus throttling that could hold the bus between messages when using repeated start option, stop will not occur when the device is actively sending or receiving data from the IIC bus or the bus is being throttled by this device, but instead return XST_IIC_BUS_BUSY.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic.html">XIic</a> instance to be worked on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS indicates all IIC interrupts are disabled. No messages can be received or transmitted until <a class="el" href="xiic_8c.html#a5f4e497710a9c3719f27d40faa74a10f">XIic_Start()</a> is called.</li>
<li>XST_IIC_BUS_BUSY indicates this device is currently engaged in message traffic and cannot be stopped.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
