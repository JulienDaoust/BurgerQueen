<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xscaler.h File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xscaler.h File Reference</h1>
<p>
<code>#include &quot;stdio.h&quot;</code><br>
<code>#include &quot;math.h&quot;</code><br>
<code>#include &quot;stdlib.h&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<code>#include &quot;<a class="el" href="xscaler__hw_8h.html">xscaler_hw.h</a>&quot;</code><br>
<code>#include &quot;xil_types.h&quot;</code><br>
<code>#include &quot;xstatus.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_scaler___config.html">XScaler_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_scaler.html">XScaler</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_scaler_coeff_bank.html">XScalerCoeffBank</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a></td></tr>

<tr><td colspan="2"><br><h2>Minimum and Maximum Tap Numbers</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#6deb8957fbdf87e83b74ebeca0de4f2f">XSCL_MIN_TAP_NUM</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#98be07bbaae9bd2f42ff42ba7f74e082">XSCL_MAX_TAP_NUM</a>&nbsp;&nbsp;&nbsp;12</td></tr>

<tr><td colspan="2"><br><h2>Minimum and Maximum Phase Numbers</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#f8192f6c419f513f7dda3187ce27b05d">XSCL_MIN_PHASE_NUM</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#2734fd47030181f4164a55a11508bf7c">XSCL_MAX_PHASE_NUM</a>&nbsp;&nbsp;&nbsp;64</td></tr>

<tr><td colspan="2"><br><h2>Coefficient Precision</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#027b12daec1d3a341b165b9a30179df9">XSCL_COEFF_PRECISION</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td colspan="2"><br><h2>Maximum Coefficient Set Number</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#5cb488407d0ae228b3ef6e02a5269ba1">XSCL_MAX_COEFF_SET_NUM</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td colspan="2"><br><h2>The number of coefficient Bins</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#34514a6a241c077925def186c8f574b9">XSCL_NUM_COEF_BINS</a>&nbsp;&nbsp;&nbsp;19</td></tr>

<tr><td colspan="2"><br><h2>The size of a coefficient Bin in 16-bit integers.</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#2a936cd14f72583cfd0bc403ae56ef46">XSCL_COEF_BIN_SIZE</a>&nbsp;&nbsp;&nbsp;XScaler_CoefTapOffset(XSCL_MAX_TAP_NUM + 1)</td></tr>

<tr><td colspan="2"><br><h2>Shrink factor constants</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#5e9e52e7e44ce46818ece0cc020b4f14">XSCL_SHRINK_FACTOR</a>&nbsp;&nbsp;&nbsp;0x100000</td></tr>

<tr><td colspan="2"><br><h2>Macros for operating a Scaler device</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#11b1c70d6b01a8580d0927a5b7608306">XScaler_Enable</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#2a6fff5d653283fd1f7c2f847a627eb1">XScaler_Disable</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#36a6a3558f50268cc8d0eb8c0c49fbd4">XScaler_IsEnabled</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#d9e172e8a8d4297bd6335bf56e737f63">XScaler_CheckDone</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#691e8f66bcfa68f9f5b579e5ba9c419c">XScaler_EnableRegUpdate</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#3c037ab5c5ad13c876710f922f7f462f">XScaler_DisableRegUpdate</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#ec93141b509d2de3eb24bba0be1a11fb">XScaler_CoeffLoadReady</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#6f2543d3a5403ef7500313e5cba33725">XScaler_GetError</a>(InstancePtr)&nbsp;&nbsp;&nbsp;XScaler_ReadReg((InstancePtr)-&gt;Config.BaseAddress, (XSCL_ERROR_OFFSET))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#6387eceaded147af9969660ff9db3d37">XScaler_Reset</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#7399e42eebd2fa8a023b2fe388bd379b">XScaler_IsResetDone</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber</a>(N)&nbsp;&nbsp;&nbsp;((N) * ((N) + 1) / 2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#6896596b825bad380377dbb656b072b8">XScaler_CoefTapOffset</a>(Tap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#d6cdd2b14967aa84aefcd7fddc954dfd">XScaler_CoefPhaseOffset</a>(Tap, Phase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#a76376ee856a3d0a2c4384e8fc643e10">XScaler_IntrEnable</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#93b65ea252a3870965ff562579585569">XScaler_IntrDisable</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#f994f67d5c003a5ef3205a3716384a44">XScaler_IntrClear</a>(InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#b7ef99aaa97948b596f75ef7b779ad71">XSCALER_H</a></td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#4d0c468a8fe706f8959f18a9d21fdfff">XScaler_CallBack</a> (void *CallBackRef)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#15c509c2050d8b9fd555d07e7553ff74">XScaler_CfgInitialize</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler___config.html">XScaler_Config</a> *CfgPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#9ecf963404e7cdbb8bff372e8f3eabe7">XScaler_SetAperture</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *AperturePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#05d4fd7d79fb73ff82a13a81ac7c58ed">XScaler_GetAperture</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *AperturePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#76bd8e1ac73b7a0eb116206f97fe8502">XScaler_SetPhaseNum</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u16 VertPhaseNum, u16 HoriPhaseNum)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#52861252f27f173a530bb0c3758ab4d0">XScaler_GetPhaseNum</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u16 *VertPhaseNumPtr, u16 *HoriPhaseNumPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#5a13eaec4e81070651fd5d38cecca772">XScaler_SetStartFraction</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *StartFractionPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#5956eef6c759a3e38a15b670a3bea159">XScaler_GetStartFraction</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *StartFractionPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">s16 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#6770efd9131c5c73d78c38c6c3c5cc81">XScaler_CoefValueLookup</a> (u32 InSize, u32 OutSize, u32 Tap, u32 Phase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#38beb0d182b0e794be3a56d7e5bb91f9">XScaler_LoadCoeffBank</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_coeff_bank.html">XScalerCoeffBank</a> *CoeffBankPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#538a5c851ce9b06c883dcd89f8746d19">XScaler_SetActiveCoeffSet</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u8 VertSetIndex, u8 HoriSetIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#bc47b324dca847f1319cece8f261ce25">XScaler_GetActiveCoeffSet</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u8 *VertSetIndexPtr, u8 *HoriSetIndexPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#9223c7dbff7bbc1d126fd64f87af8767">XScaler_GetCoeffBankSharingInfo</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u8 *ChromaFormat, u8 *ChromaLumaShareCoeff, u8 *HoriVertShareCoeff)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#fe44e79802fd28186ccd2f2d83653cad">XScaler_GetVersion</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_scaler___config.html">XScaler_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#16813d03b87858b533742efe30f18daa">XScaler_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#6fa8567138c2521f1eb9516fe1335ac3">XScaler_IntrHandler</a> (void *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8h.html#bd9fccf4a3c562830e9f26140aaec73f">XScaler_SetCallBack</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, void *CallBackFunc, void *CallBackRef)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="d9e172e8a8d4297bd6335bf56e737f63"></a><!-- doxytag: member="xscaler.h::XScaler_CheckDone" ref="d9e172e8a8d4297bd6335bf56e737f63" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_CheckDone          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                                        (<a class="code" href="xscaler__hw_8h.html#1ef15601863381aafc7e1a31189643de">XSCL_STATUS_OFFSET</a>)) &amp; \
                (<a class="code" href="xscaler__hw_8h.html#b633c20c23143da97a8a4de45efe0021">XSCL_STS_COEF_W_RDY_MASK</a>) ? TRUE : FALSE
</pre></div>This macro checks if a Scaler operation is finished<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the Scaler operation is finished.</li><li>FALSE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: boolean <a class="el" href="xscaler_8h.html#d9e172e8a8d4297bd6335bf56e737f63">XScaler_CheckDone(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec93141b509d2de3eb24bba0be1a11fb"></a><!-- doxytag: member="xscaler.h::XScaler_CoeffLoadReady" ref="ec93141b509d2de3eb24bba0be1a11fb" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_CoeffLoadReady          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                                        (<a class="code" href="xscaler__hw_8h.html#1ef15601863381aafc7e1a31189643de">XSCL_STATUS_OFFSET</a>)) &amp; \
                (<a class="code" href="xscaler__hw_8h.html#b633c20c23143da97a8a4de45efe0021">XSCL_STS_COEF_W_RDY_MASK</a>) ? TRUE : FALSE
</pre></div>This macro checks if a Scaler device is ready to accept the coefficients the software is going to load.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the Scaler device is ready for the coefficient load.</li><li>FALSE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: boolean <a class="el" href="xscaler_8h.html#ec93141b509d2de3eb24bba0be1a11fb">XScaler_CoeffLoadReady(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6cdd2b14967aa84aefcd7fddc954dfd"></a><!-- doxytag: member="xscaler.h::XScaler_CoefPhaseOffset" ref="d6cdd2b14967aa84aefcd7fddc954dfd" args="(Tap, Phase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_CoefPhaseOffset          </td>
          <td>(</td>
          <td class="paramtype">Tap,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Phase&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">(((Phase) &lt; 32) ? \
                (Tap) * (<a class="code" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber</a>((Phase) - 1) - 1) : \
                ((Phase) == 32) ? \
                        (Tap) * (<a class="code" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber</a>(16) - 1) : \
                        (Tap) * (<a class="code" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber</a>(16) - 1 + 32))
</pre></div>This macro calculates the offset of the first coefficient Phase from the beginning of a coefficient Tap given the currently used Phase and Tap numbers for scaling operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tap</em>&nbsp;</td><td>indicates the number of Taps used for the scaling operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Phase</em>&nbsp;</td><td>indicates the number of Phases used for the scaling operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The offset of the first coefficient Phase from the beginning of a coefficient Tap. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xscaler_8h.html#d6cdd2b14967aa84aefcd7fddc954dfd">XScaler_CoefPhaseOffset(u32 Tap, u32 Phase)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="6896596b825bad380377dbb656b072b8"></a><!-- doxytag: member="xscaler.h::XScaler_CoefTapOffset" ref="6896596b825bad380377dbb656b072b8" args="(Tap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_CoefTapOffset          </td>
          <td>(</td>
          <td class="paramtype">Tap&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber</a>((Tap) - 1) - 1) * \
                (<a class="code" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber</a>(16) - 1 + 32 + 64))
</pre></div>This macro calculates the offset of a coefficient Tap from the beginning of a coefficient Bin.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tap</em>&nbsp;</td><td>indicates the index of the coefficient tap in the coefficient Bin.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The offset of the coefficient TAP from the beginning of a coefficient Bin. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xscaler_8h.html#6896596b825bad380377dbb656b072b8">XScaler_CoefTapOffset(u32 Tap)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a6fff5d653283fd1f7c2f847a627eb1"></a><!-- doxytag: member="xscaler.h::XScaler_Disable" ref="2a6fff5d653283fd1f7c2f847a627eb1" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_Disable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>), \
                        ((<a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                        (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>)) &amp; (~(<a class="code" href="xscaler__hw_8h.html#72794ba6b74a4a904adda7d3219fac84">XSCL_CTL_SW_EN_MASK</a>)))))
</pre></div>This macro disables a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#2a6fff5d653283fd1f7c2f847a627eb1">XScaler_Disable(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="3c037ab5c5ad13c876710f922f7f462f"></a><!-- doxytag: member="xscaler.h::XScaler_DisableRegUpdate" ref="3c037ab5c5ad13c876710f922f7f462f" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_DisableRegUpdate          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>), \
                        ((<a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                        (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>))) &amp; (~(<a class="code" href="xscaler__hw_8h.html#cd1ba8ed7d6126b98c11832176f2f7b9">XSCL_CTL_RUE_MASK</a>))))
</pre></div>This macro tells a Scaler device not to pick up the register value changes until <a class="el" href="xscaler_8h.html#691e8f66bcfa68f9f5b579e5ba9c419c">XScaler_EnableRegUpdate()</a> is invoked again. This is very useful when multiple registers need to be updated. All register updates could be made with no tight time constraints with the help of this macro.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#3c037ab5c5ad13c876710f922f7f462f">XScaler_DisableRegUpdate(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="11b1c70d6b01a8580d0927a5b7608306"></a><!-- doxytag: member="xscaler.h::XScaler_Enable" ref="11b1c70d6b01a8580d0927a5b7608306" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_Enable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>), \
                        ((<a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>))) | (<a class="code" href="xscaler__hw_8h.html#72794ba6b74a4a904adda7d3219fac84">XSCL_CTL_SW_EN_MASK</a>)))
</pre></div>This macro enables a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#11b1c70d6b01a8580d0927a5b7608306">XScaler_Enable(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="691e8f66bcfa68f9f5b579e5ba9c419c"></a><!-- doxytag: member="xscaler.h::XScaler_EnableRegUpdate" ref="691e8f66bcfa68f9f5b579e5ba9c419c" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_EnableRegUpdate          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>), \
                        ((<a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                        (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>))) | (<a class="code" href="xscaler__hw_8h.html#cd1ba8ed7d6126b98c11832176f2f7b9">XSCL_CTL_RUE_MASK</a>)))
</pre></div>This macro tells a Scaler device to pick up the register value changes made so far.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#691e8f66bcfa68f9f5b579e5ba9c419c">XScaler_EnableRegUpdate(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f2543d3a5403ef7500313e5cba33725"></a><!-- doxytag: member="xscaler.h::XScaler_GetError" ref="6f2543d3a5403ef7500313e5cba33725" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_GetError          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;XScaler_ReadReg((InstancePtr)-&gt;Config.BaseAddress, (XSCL_ERROR_OFFSET))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro checks the error status of a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The error type, if any. Use XSCL_STSERR_* defined in <a class="el" href="xscaler__hw_8h.html">xscaler_hw.h</a> to interpret the value.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xscaler_8h.html#6f2543d3a5403ef7500313e5cba33725">XScaler_GetError(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="b7ef99aaa97948b596f75ef7b779ad71"></a><!-- doxytag: member="xscaler.h::XSCALER_H" ref="b7ef99aaa97948b596f75ef7b779ad71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCALER_H          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f994f67d5c003a5ef3205a3716384a44"></a><!-- doxytag: member="xscaler.h::XScaler_IntrClear" ref="f994f67d5c003a5ef3205a3716384a44" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_IntrClear          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#1ef15601863381aafc7e1a31189643de">XSCL_STATUS_OFFSET</a>), (<a class="code" href="xscaler__hw_8h.html#65ce0d708b68d348a87a0ec81990faaa">XSCL_IXR_COEF_W_RDY_MASK</a>))
</pre></div>This macro clears/acknowledges Coef_FIFO_Ready interrupt of a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#f994f67d5c003a5ef3205a3716384a44">XScaler_IntrClear(XScaler *InstancePtr)</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="93b65ea252a3870965ff562579585569"></a><!-- doxytag: member="xscaler.h::XScaler_IntrDisable" ref="93b65ea252a3870965ff562579585569" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_IntrDisable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#708a719de7bf763b425f8eb7a77f73d1">XSCL_IRQ_EN_OFFSET</a>), 0)
</pre></div>This macro disables the Coef_FIFO_Ready interrupt on a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#93b65ea252a3870965ff562579585569">XScaler_IntrDisable(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="a76376ee856a3d0a2c4384e8fc643e10"></a><!-- doxytag: member="xscaler.h::XScaler_IntrEnable" ref="a76376ee856a3d0a2c4384e8fc643e10" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_IntrEnable          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#708a719de7bf763b425f8eb7a77f73d1">XSCL_IRQ_EN_OFFSET</a>),(<a class="code" href="xscaler__hw_8h.html#65ce0d708b68d348a87a0ec81990faaa">XSCL_IXR_COEF_W_RDY_MASK</a>)) \
</pre></div>This macro enables the Coef_FIFO_Ready interrupt on a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#a76376ee856a3d0a2c4384e8fc643e10">XScaler_IntrEnable(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="36a6a3558f50268cc8d0eb8c0c49fbd4"></a><!-- doxytag: member="xscaler.h::XScaler_IsEnabled" ref="36a6a3558f50268cc8d0eb8c0c49fbd4" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_IsEnabled          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>)) &amp; (<a class="code" href="xscaler__hw_8h.html#72794ba6b74a4a904adda7d3219fac84">XSCL_CTL_SW_EN_MASK</a>) ? TRUE : FALSE
</pre></div>This macro checks if a Scaler device is enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>- TRUE if the Scaler device is enabled.<ul>
<li>FALSE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: boolean <a class="el" href="xscaler_8h.html#36a6a3558f50268cc8d0eb8c0c49fbd4">XScaler_IsEnabled(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="7399e42eebd2fa8a023b2fe388bd379b"></a><!-- doxytag: member="xscaler.h::XScaler_IsResetDone" ref="7399e42eebd2fa8a023b2fe388bd379b" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_IsResetDone          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#71879103578af25139e64893eeb4697d">XScaler_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                                        (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>)) &amp; \
                                        (<a class="code" href="xscaler__hw_8h.html#1146f8faa2cf957ec30f5d9006462bd9">XSCL_CTL_RESET_MASK</a>) ? FALSE : TRUE
</pre></div>This macro checks if the reset on a Scaler device is done.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the reset is done;</li><li>FALSE otherwise.</li></ul>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: boolean <a class="el" href="xscaler_8h.html#7399e42eebd2fa8a023b2fe388bd379b">XScaler_IsResetDone(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="6387eceaded147af9969660ff9db3d37"></a><!-- doxytag: member="xscaler.h::XScaler_Reset" ref="6387eceaded147af9969660ff9db3d37" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_Reset          </td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xscaler__hw_8h.html#932189ed3aeff002acff68afc90548ea">XScaler_WriteReg</a>((InstancePtr)-&gt;Config.BaseAddress, \
                (<a class="code" href="xscaler__hw_8h.html#e56be419a3a532f1aa5a3b4b2830e1bf">XSCL_CTL_OFFSET</a>), (<a class="code" href="xscaler__hw_8h.html#1146f8faa2cf957ec30f5d9006462bd9">XSCL_CTL_RESET_MASK</a>))
</pre></div>This macro resets a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xscaler_8h.html#6387eceaded147af9969660ff9db3d37">XScaler_Reset(XScaler *InstancePtr)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="f25a61c418f9fd6f356e25944c3cf9df"></a><!-- doxytag: member="xscaler.h::XScaler_TriangularNumber" ref="f25a61c418f9fd6f356e25944c3cf9df" args="(N)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XScaler_TriangularNumber          </td>
          <td>(</td>
          <td class="paramtype">N&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((N) * ((N) + 1) / 2)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro calculates the N-th Triangular number: 1 + 2 + ... + N<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>N</em>&nbsp;</td><td>indicates the positive integer number to calculate the N-th Triangular number.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The N-th triangular number.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xscaler_8h.html#f25a61c418f9fd6f356e25944c3cf9df">XScaler_TriangularNumber(u32 N)</a>; </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a936cd14f72583cfd0bc403ae56ef46"></a><!-- doxytag: member="xscaler.h::XSCL_COEF_BIN_SIZE" ref="2a936cd14f72583cfd0bc403ae56ef46" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_COEF_BIN_SIZE&nbsp;&nbsp;&nbsp;XScaler_CoefTapOffset(XSCL_MAX_TAP_NUM + 1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="027b12daec1d3a341b165b9a30179df9"></a><!-- doxytag: member="xscaler.h::XSCL_COEFF_PRECISION" ref="027b12daec1d3a341b165b9a30179df9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_COEFF_PRECISION&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Coefficient Precision 
</div>
</div><p>
<a class="anchor" name="5cb488407d0ae228b3ef6e02a5269ba1"></a><!-- doxytag: member="xscaler.h::XSCL_MAX_COEFF_SET_NUM" ref="5cb488407d0ae228b3ef6e02a5269ba1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_MAX_COEFF_SET_NUM&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum Coefficient Set Number 
</div>
</div><p>
<a class="anchor" name="2734fd47030181f4164a55a11508bf7c"></a><!-- doxytag: member="xscaler.h::XSCL_MAX_PHASE_NUM" ref="2734fd47030181f4164a55a11508bf7c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_MAX_PHASE_NUM&nbsp;&nbsp;&nbsp;64          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum Phase Number 
</div>
</div><p>
<a class="anchor" name="98be07bbaae9bd2f42ff42ba7f74e082"></a><!-- doxytag: member="xscaler.h::XSCL_MAX_TAP_NUM" ref="98be07bbaae9bd2f42ff42ba7f74e082" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_MAX_TAP_NUM&nbsp;&nbsp;&nbsp;12          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum Tap Number 
</div>
</div><p>
<a class="anchor" name="f8192f6c419f513f7dda3187ce27b05d"></a><!-- doxytag: member="xscaler.h::XSCL_MIN_PHASE_NUM" ref="f8192f6c419f513f7dda3187ce27b05d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_MIN_PHASE_NUM&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum Phase Number 
</div>
</div><p>
<a class="anchor" name="6deb8957fbdf87e83b74ebeca0de4f2f"></a><!-- doxytag: member="xscaler.h::XSCL_MIN_TAP_NUM" ref="6deb8957fbdf87e83b74ebeca0de4f2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_MIN_TAP_NUM&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum Tap Number 
</div>
</div><p>
<a class="anchor" name="34514a6a241c077925def186c8f574b9"></a><!-- doxytag: member="xscaler.h::XSCL_NUM_COEF_BINS" ref="34514a6a241c077925def186c8f574b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_NUM_COEF_BINS&nbsp;&nbsp;&nbsp;19          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of coefficient Bins 
</div>
</div><p>
<a class="anchor" name="5e9e52e7e44ce46818ece0cc020b4f14"></a><!-- doxytag: member="xscaler.h::XSCL_SHRINK_FACTOR" ref="5e9e52e7e44ce46818ece0cc020b4f14" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSCL_SHRINK_FACTOR&nbsp;&nbsp;&nbsp;0x100000          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For calculating HSF/VSF values 
</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="4d0c468a8fe706f8959f18a9d21fdfff"></a><!-- doxytag: member="xscaler.h::XScaler_CallBack" ref="4d0c468a8fe706f8959f18a9d21fdfff" args="(void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(*) <a class="el" href="xscaler_8h.html#4d0c468a8fe706f8959f18a9d21fdfff">XScaler_CallBack</a>(void *CallBackRef)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback type for interrupts<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EventMask</em>&nbsp;</td><td>indicates which events are happening. They could be either normal events or errors. The value is created by "OR'ing" XSCL_IXR_* constants defined in <a class="el" href="xscaler__hw_8h.html">xscaler_hw.h</a> </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="15c509c2050d8b9fd555d07e7553ff74"></a><!-- doxytag: member="xscaler.h::XScaler_CfgInitialize" ref="15c509c2050d8b9fd555d07e7553ff74" args="(XScaler *InstancePtr, XScaler_Config *CfgPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XScaler_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler___config.html">XScaler_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function initializes a Scaler device. This function must be called prior to using a Scaler device. Initialization of a Scaler includes setting up the instance data, and ensuring the hardware is in a quiescent state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>points to the configuration structure associated with the Scaler device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the base address of the device. If address translation is being used, then this parameter must reflect the virtual base address. Otherwise, the physical address should be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6770efd9131c5c73d78c38c6c3c5cc81"></a><!-- doxytag: member="xscaler.h::XScaler_CoefValueLookup" ref="6770efd9131c5c73d78c38c6c3c5cc81" args="(u32 InSize, u32 OutSize, u32 Tap, u32 Phase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16* XScaler_CoefValueLookup           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>InSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>OutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Tap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Phase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the pointer to the coefficients for a scaling operation given input/output sizes and the Tap and Phase numbers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InSize</em>&nbsp;</td><td>indicates the size (width or height) of the input video. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutSize</em>&nbsp;</td><td>indicates the size (width or height) of the output video. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tap</em>&nbsp;</td><td>indicates the Tap number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Phase</em>&nbsp;</td><td>indicates the Phase number.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The points to the coefficients ready for the scaling operation.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc47b324dca847f1319cece8f261ce25"></a><!-- doxytag: member="xscaler.h::XScaler_GetActiveCoeffSet" ref="bc47b324dca847f1319cece8f261ce25" args="(XScaler *InstancePtr, u8 *VertSetIndexPtr, u8 *HoriSetIndexPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetActiveCoeffSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>VertSetIndexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>HoriSetIndexPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function fetches the indexes of active vertical and horizontal coefficient sets being used by a Scaler device.<p>
Each coefficient set contains 4 banks: Horizontal Luma, Horizontal Chroma, Vertical Luma and Vertical Chroma. The horizontal part is independent from the vertical part and the Scaler device supports using the horizontal part of one coefficient set w/ the vertical part of a different coefficient set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertSetIndexPtr</em>&nbsp;</td><td>points to the index of the active coefficient set in which the vertical part is being used by the Scaler device after this function returns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriSetIndexPtr</em>&nbsp;</td><td>points to the index of the active coefficient set in which the horizontal part is being used by the Scaler device after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="05d4fd7d79fb73ff82a13a81ac7c58ed"></a><!-- doxytag: member="xscaler.h::XScaler_GetAperture" ref="05d4fd7d79fb73ff82a13a81ac7c58ed" args="(XScaler *InstancePtr, XScalerAperture *AperturePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetAperture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *&nbsp;</td>
          <td class="paramname"> <em>AperturePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets aperture of a Scaler device. The aperture setting consists of input video aperture and output video size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AperturePtr</em>&nbsp;</td><td>points to the aperture structure to store the current Scaler device setting after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9223c7dbff7bbc1d126fd64f87af8767"></a><!-- doxytag: member="xscaler.h::XScaler_GetCoeffBankSharingInfo" ref="9223c7dbff7bbc1d126fd64f87af8767" args="(XScaler *InstancePtr, u8 *ChromaFormat, u8 *ChromaLumaShareCoeff, u8 *HoriVertShareCoeff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetCoeffBankSharingInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ChromaFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ChromaLumaShareCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>HoriVertShareCoeff</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function fetches the color space format and coefficient bank sharing decisions made on a Scaler device at build-time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChromaFormat</em>&nbsp;</td><td>points to an 8-bit variable that will be assigned with the Chroma format chosen for the Scaler device at the build time after this function returns. Please use XSCL_CHROMA_FORMAT_* defined in <a class="el" href="xscaler__hw_8h.html">xscaler_hw.h</a> to interpret the variable value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChromaLumaShareCoeff</em>&nbsp;</td><td>points to an 8-bit variable that will be assigned by this function with the decision value on coefficient bank sharing between Chroma and Luma filter operations. The decision is made for the Scaler device at build time and can NOT be changed at run-time. Value 0 indicates that each of Chroma and Luma filter operations has its own coefficient bank. Value 1 indicates that Chroma and Luma filter operations share one common coefficient bank. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriVertShareCoeff</em>&nbsp;</td><td>points to an 8-bit variable that will be assigned by this function with the decision value on coefficient bank sharing between Horizontal and Vertical filter operations. The decision is made for the Scaler device at build time and can NOT be changed at run-time. Value 0 indicates that each of Horizontal and Vertical filter operations has its own coefficient bank. Value 1 indicates that Horizontal and Vertical filter operations share one common coefficient bank.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
!!!IMPORTANT!!!<p>
The application of this function is responsible for loading the correct number of coefficient banks in the proper sequence order. The number of coefficient banks to load and the proper loading sequence totally depends on the values of the output parameters of this function. Please use the table below as reference.<p>
<pre>
 ChromaFormat ChromaLumaShareCoeff HoriVertShareCoeff # of      sequence
                                                      coeff     of
                                                      banks     loading
                                                      to load   coeff
                                                                banks
 ------------ -------------------- ------------------ --------  -------------
 YUV420       1                    1                  1         1.Single bank
 ------------ -------------------- ------------------ --------  -------------
 YUV420       1                    0                  2         1.Hori bank
                                                                2.Vert bank
 ------------ -------------------- ------------------ --------  -------------
 YUV420       0                    1                  2         1.Luma bank
                                                                2.Chroma bank
 ------------ -------------------- ------------------ --------  -------------
 YUV420       0                    0                  4         1.Hori Luma
                                                                2.Hori Chroma
                                                                3.Vert Luma
                                                                4.Vert Chroma
 ------------ -------------------- ------------------ --------  -------------
 YUV422       1                    1                  1         1.Single bank
 ------------ -------------------- ------------------ --------  -------------
 YUV422       1                    0                  2         1.Hori bank
                                                                2.Vert bank
 ------------ -------------------- ------------------ --------  -------------
 YUV422       0                    1                  2         1.Luma bank
                                                                2.Chroma bank
 ------------ -------------------- ------------------ --------  -------------
 YUV422       0                    0                  4         1.Hori Luma
                                                                2.Hori Chroma
                                                                3.Vert Luma
                                                                4.Vert Chroma
 ------------ -------------------- ------------------ --------  -------------
 YUV444       Always 1             1                  1         1.Single bank
 ------------ -------------------- ------------------ --------  -------------
 YUV444       Always 1             0                  2         1.Hori bank
                                                                2.Vert bank
 ------------ -------------------- ------------------ --------  -------------
 </pre> 
</div>
</div><p>
<a class="anchor" name="52861252f27f173a530bb0c3758ab4d0"></a><!-- doxytag: member="xscaler.h::XScaler_GetPhaseNum" ref="52861252f27f173a530bb0c3758ab4d0" args="(XScaler *InstancePtr, u16 *VertPhaseNumPtr, u16 *HoriPhaseNumPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetPhaseNum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>VertPhaseNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>HoriPhaseNumPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets the numbers of vertical and horizontal phases currently used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertPhaseNumPtr</em>&nbsp;</td><td>will point to the number of vertical phases used after this function returns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriPhaseNumPtr</em>&nbsp;</td><td>will point to the number of horizontal phases used after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5956eef6c759a3e38a15b670a3bea159"></a><!-- doxytag: member="xscaler.h::XScaler_GetStartFraction" ref="5956eef6c759a3e38a15b670a3bea159" args="(XScaler *InstancePtr, XScalerStartFraction *StartFractionPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetStartFraction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *&nbsp;</td>
          <td class="paramname"> <em>StartFractionPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets Luma and Chroma start fractional values currently used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StartFractionPtr</em>&nbsp;</td><td>is a pointer to a start fractional value structure to be populated with the fractional values after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe44e79802fd28186ccd2f2d83653cad"></a><!-- doxytag: member="xscaler.h::XScaler_GetVersion" ref="fe44e79802fd28186ccd2f2d83653cad" args="(XScaler *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XScaler_GetVersion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the contents of version register of the Scaler core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler core instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Contents of the version register.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6fa8567138c2521f1eb9516fe1335ac3"></a><!-- doxytag: member="xscaler.h::XScaler_IntrHandler" ref="6fa8567138c2521f1eb9516fe1335ac3" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_IntrHandler           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is the interrupt handler for the Scaler driver.<p>
This handler calls callback, and finally clears the interrupts.<p>
The application is responsible for connecting this function to the interrupt system. Application beyond this driver is also responsible for providing callbacks to handle interrupts and installing the callbacks using <a class="el" href="xscaler_8h.html#bd9fccf4a3c562830e9f26140aaec73f">XScaler_SetCallBack()</a> during initialization phase.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_scaler.html">XScaler</a> instance that just interrupted. </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None. </dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="38beb0d182b0e794be3a56d7e5bb91f9"></a><!-- doxytag: member="xscaler.h::XScaler_LoadCoeffBank" ref="38beb0d182b0e794be3a56d7e5bb91f9" args="(XScaler *InstancePtr, XScalerCoeffBank *CoeffBankPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_LoadCoeffBank           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_coeff_bank.html">XScalerCoeffBank</a> *&nbsp;</td>
          <td class="paramname"> <em>CoeffBankPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function loads a coefficient bank to the Scaler core. A complete coefficient set contains 4 banks (if Luma, Chroma, Horizontal and Vertical filter operations do not share common banks. For more details see <a class="el" href="xscaler_8c.html#9223c7dbff7bbc1d126fd64f87af8767">XScaler_GetCoeffBankSharingInfo()</a>): Horizontal Luma, Horizontal Chroma, Vertical Luma and Vertical Chroma. all 4 banks must be loaded back to back in the order listed here. The caller is responsible for ensuring the sequence and this function does not check it.<p>
An example sequence to load an whole coefficient set is like: <pre>
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;HoriLumaCoeffBank);
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;HoriChromaCoeffBank);
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;VertLumaCoeffBank);
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;VertChromaCoeffBank);
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CoeffBankPtr</em>&nbsp;</td><td>is a pointer to a coefficient bank that is to be loaded.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="16813d03b87858b533742efe30f18daa"></a><!-- doxytag: member="xscaler.h::XScaler_LookupConfig" ref="16813d03b87858b533742efe30f18daa" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_scaler___config.html">XScaler_Config</a>* XScaler_LookupConfig           </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XScaler_LookupConfig returns a reference to an <a class="el" href="struct_x_scaler___config.html">XScaler_Config</a> structure based on the unique device id, <em>DeviceId</em>. The return value will refer to an entry in the device configuration table defined in the <a class="el" href="xscaler__g_8c.html">xscaler_g.c</a> file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device for the lookup operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XScaler_LookupConfig returns a reference to a config record in the configuration table (in <a class="el" href="xscaler__g_8c.html">xscaler_g.c</a>) corresponding to <em>DeviceId</em>, or NULL if no match is found. </dd></dl>

</div>
</div><p>
<a class="anchor" name="538a5c851ce9b06c883dcd89f8746d19"></a><!-- doxytag: member="xscaler.h::XScaler_SetActiveCoeffSet" ref="538a5c851ce9b06c883dcd89f8746d19" args="(XScaler *InstancePtr, u8 VertSetIndex, u8 HoriSetIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetActiveCoeffSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VertSetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>HoriSetIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function chooses the active vertical and horizontal coefficient sets to be used by a Scaler device.<p>
Each coefficient set contains 4 banks: Horizontal Luma, Horizontal Chroma, Vertical Luma and Vertical Chroma. The horizontal part is independent from the vertical part and the Scaler device supports using the horizontal part of one coefficient set w/ the vertical part of a different coefficient set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertSetIndex</em>&nbsp;</td><td>indicates the index of the coefficient set in which the vertical part will be used by the Scaler device. Valid value is from 0 to (the number of the coefficient sets implemented by the Scaler device - 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriSetIndex</em>&nbsp;</td><td>indicates the index of the coefficient set in which the horizontal part will be used by the Scaler device. Valid value is from 0 to (the number of the coefficient sets implemented by the Scaler device - 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ecf963404e7cdbb8bff372e8f3eabe7"></a><!-- doxytag: member="xscaler.h::XScaler_SetAperture" ref="9ecf963404e7cdbb8bff372e8f3eabe7" args="(XScaler *InstancePtr, XScalerAperture *AperturePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XScaler_SetAperture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *&nbsp;</td>
          <td class="paramname"> <em>AperturePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets up aperture of a Scaler device. The aperture setting consists of input video aperture and output video size. This function calculates the scale factor accordingly based on the aperture setting and sets up the Scaler appropriately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AperturePtr</em>&nbsp;</td><td>points to the aperture setting structure to set up the Scaler device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd9fccf4a3c562830e9f26140aaec73f"></a><!-- doxytag: member="xscaler.h::XScaler_SetCallBack" ref="bd9fccf4a3c562830e9f26140aaec73f" args="(XScaler *InstancePtr, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetCallBack           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This routine installs an asynchronous callback function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_scaler.html">XScaler</a> instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="76bd8e1ac73b7a0eb116206f97fe8502"></a><!-- doxytag: member="xscaler.h::XScaler_SetPhaseNum" ref="76bd8e1ac73b7a0eb116206f97fe8502" args="(XScaler *InstancePtr, u16 VertPhaseNum, u16 HoriPhaseNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetPhaseNum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>VertPhaseNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>HoriPhaseNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the numbers of vertical and horizontal phases to be used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertPhaseNum</em>&nbsp;</td><td>is the number of vertical phase to set to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriPhaseNum</em>&nbsp;</td><td>is the number of horizontal phase to set to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a13eaec4e81070651fd5d38cecca772"></a><!-- doxytag: member="xscaler.h::XScaler_SetStartFraction" ref="5a13eaec4e81070651fd5d38cecca772" args="(XScaler *InstancePtr, XScalerStartFraction *StartFractionPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetStartFraction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *&nbsp;</td>
          <td class="paramname"> <em>StartFractionPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets up Luma and Chroma start fractional values used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StartFractionPtr</em>&nbsp;</td><td>is a pointer to a start fractional value set to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
