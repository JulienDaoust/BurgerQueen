<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   xscaler.c File Reference
</title>
<link href="$DriverApiDocsCssPath" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<h1>xscaler.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This is main code of Xilinx MVI Video Scaler device driver. The Scaler device converts a specified rectangular area of an input digital video image from one original sampling grid to a desired target sampling grid. Please see <a class="el" href="xscaler_8h.html">xscaler.h</a> for more details of the driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who     Date     Changes
 ----- ----    -------- -------------------------------------------------------
 1.00a xd      02/10/09 First release
 2.00a xd      12/14/09 Updated Doxygen document tags
 4.01a cw      06/27/12 Updated tcl file with new parameter names (num_x_taps)
                        Updated mdd file with updated supported_peripherals
                        field.
 4.02a mpv     03/11/13 Updated the Driver to select the correct coeff bin.
                        Changed RegValue variable to a volatile type
                        Removed 10.x patch in the Tcl file
 4.03a mpv     05/28/13 Fixed version limit in MDD file
                        Updated the Driver input, output and aperture size
                        mask
 5.00a mpv     12/13/13 Updated to dynamic coeff generation to reduce driver
                        size
 7.0   adk     08/22/14 Modified prototype of XScaler_GetVersion API.
                        and functionality of StubCallBack. Modified assert
                        conditions in functions XScaler_CfgInitialize,
                        XScaler_SetPhaseNum, XScaler_LoadCoeffBank.
                        Removed error callback from XScaler_CfgInitialize
                        function.
                        Uncommented XScaler_Reset in XScaler_CfgInitialize
                        function.
                        Removed ErrorMask parameter in StubCallBack as there
                        was only one interrupt.
 </pre> 
<p>
<code>#include &quot;<a class="el" href="xscaler_8h.html">xscaler.h</a>&quot;</code><br>
<code>#include &quot;xenv.h&quot;</code><br>
<code>#include &quot;xil_io.h&quot;</code><br>
<code>#include &quot;xil_assert.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Utility Macros</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#6ea10f4260b54a61665ead26cb995ba3">round</a>(x)&nbsp;&nbsp;&nbsp;((x) &gt;= 0 ? (s32)((x) + 0.5) : (s32)((x) - 0.5))</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">s16 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#41df88fbe58daded2ac713e7cc5a4ec0">XScaler_GenCoefTable</a> (u32 Tap, u32 Phase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#15c509c2050d8b9fd555d07e7553ff74">XScaler_CfgInitialize</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler___config.html">XScaler_Config</a> *CfgPtr, u32 EffectiveAddr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#9ecf963404e7cdbb8bff372e8f3eabe7">XScaler_SetAperture</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *AperturePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#05d4fd7d79fb73ff82a13a81ac7c58ed">XScaler_GetAperture</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *AperturePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#76bd8e1ac73b7a0eb116206f97fe8502">XScaler_SetPhaseNum</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u16 VertPhaseNum, u16 HoriPhaseNum)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#52861252f27f173a530bb0c3758ab4d0">XScaler_GetPhaseNum</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u16 *VertPhaseNumPtr, u16 *HoriPhaseNumPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#5a13eaec4e81070651fd5d38cecca772">XScaler_SetStartFraction</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *StartFractionPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#5956eef6c759a3e38a15b670a3bea159">XScaler_GetStartFraction</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *StartFractionPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#9223c7dbff7bbc1d126fd64f87af8767">XScaler_GetCoeffBankSharingInfo</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u8 *ChromaFormat, u8 *ChromaLumaShareCoeff, u8 *HoriVertShareCoeff)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">s16 *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#6770efd9131c5c73d78c38c6c3c5cc81">XScaler_CoefValueLookup</a> (u32 InSize, u32 OutSize, u32 Tap, u32 Phase)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#38beb0d182b0e794be3a56d7e5bb91f9">XScaler_LoadCoeffBank</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, <a class="el" href="struct_x_scaler_coeff_bank.html">XScalerCoeffBank</a> *CoeffBankPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#538a5c851ce9b06c883dcd89f8746d19">XScaler_SetActiveCoeffSet</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u8 VertSetIndex, u8 HoriSetIndex)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#bc47b324dca847f1319cece8f261ce25">XScaler_GetActiveCoeffSet</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr, u8 *VertSetIndexPtr, u8 *HoriSetIndexPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#fe44e79802fd28186ccd2f2d83653cad">XScaler_GetVersion</a> (<a class="el" href="struct_x_scaler.html">XScaler</a> *InstancePtr)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xscaler_8c.html#59e75ae65e791e6f8c59aea4251a6c9e">XScaler_CoefficientBinScalingFactors</a> [XSCL_NUM_COEF_BINS]</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="6ea10f4260b54a61665ead26cb995ba3"></a><!-- doxytag: member="xscaler.c::round" ref="6ea10f4260b54a61665ead26cb995ba3" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define round          </td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((x) &gt;= 0 ? (s32)((x) + 0.5) : (s32)((x) - 0.5))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This macro calculates the integral value nearest to x rounding half-way cases away from zero, regardless of the current rounding direction.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>has a float type value</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The integral value nearest to x rounding half-way cases away from zero, regardless of the current rounding direction.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: s32 <a class="el" href="xscaler_8c.html#6ea10f4260b54a61665ead26cb995ba3">round(float x)</a>; </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="15c509c2050d8b9fd555d07e7553ff74"></a><!-- doxytag: member="xscaler.c::XScaler_CfgInitialize" ref="15c509c2050d8b9fd555d07e7553ff74" args="(XScaler *InstancePtr, XScaler_Config *CfgPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XScaler_CfgInitialize           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler___config.html">XScaler_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function initializes a Scaler device. This function must be called prior to using a Scaler device. Initialization of a Scaler includes setting up the instance data, and ensuring the hardware is in a quiescent state.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>points to the configuration structure associated with the Scaler device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the base address of the device. If address translation is being used, then this parameter must reflect the virtual base address. Otherwise, the physical address should be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6770efd9131c5c73d78c38c6c3c5cc81"></a><!-- doxytag: member="xscaler.c::XScaler_CoefValueLookup" ref="6770efd9131c5c73d78c38c6c3c5cc81" args="(u32 InSize, u32 OutSize, u32 Tap, u32 Phase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16* XScaler_CoefValueLookup           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>InSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>OutSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Tap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Phase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the pointer to the coefficients for a scaling operation given input/output sizes and the Tap and Phase numbers.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InSize</em>&nbsp;</td><td>indicates the size (width or height) of the input video. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OutSize</em>&nbsp;</td><td>indicates the size (width or height) of the output video. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Tap</em>&nbsp;</td><td>indicates the Tap number. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Phase</em>&nbsp;</td><td>indicates the Phase number.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The points to the coefficients ready for the scaling operation.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41df88fbe58daded2ac713e7cc5a4ec0"></a><!-- doxytag: member="xscaler.c::XScaler_GenCoefTable" ref="41df88fbe58daded2ac713e7cc5a4ec0" args="(u32 Tap, u32 Phase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s16* XScaler_GenCoefTable           </td>
          <td>(</td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Tap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Phase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function generates a table that contains the coefficient values for scaling operations<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Tap</em>&nbsp;</td><td>indicates the number of taps configured to the Scaler device. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Phase</em>&nbsp;</td><td>indicates the number of phase configured to the Scaler device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The pointer to XScaler_Coef_Table.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc47b324dca847f1319cece8f261ce25"></a><!-- doxytag: member="xscaler.c::XScaler_GetActiveCoeffSet" ref="bc47b324dca847f1319cece8f261ce25" args="(XScaler *InstancePtr, u8 *VertSetIndexPtr, u8 *HoriSetIndexPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetActiveCoeffSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>VertSetIndexPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>HoriSetIndexPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function fetches the indexes of active vertical and horizontal coefficient sets being used by a Scaler device.<p>
Each coefficient set contains 4 banks: Horizontal Luma, Horizontal Chroma, Vertical Luma and Vertical Chroma. The horizontal part is independent from the vertical part and the Scaler device supports using the horizontal part of one coefficient set w/ the vertical part of a different coefficient set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertSetIndexPtr</em>&nbsp;</td><td>points to the index of the active coefficient set in which the vertical part is being used by the Scaler device after this function returns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriSetIndexPtr</em>&nbsp;</td><td>points to the index of the active coefficient set in which the horizontal part is being used by the Scaler device after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="05d4fd7d79fb73ff82a13a81ac7c58ed"></a><!-- doxytag: member="xscaler.c::XScaler_GetAperture" ref="05d4fd7d79fb73ff82a13a81ac7c58ed" args="(XScaler *InstancePtr, XScalerAperture *AperturePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetAperture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *&nbsp;</td>
          <td class="paramname"> <em>AperturePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets aperture of a Scaler device. The aperture setting consists of input video aperture and output video size.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AperturePtr</em>&nbsp;</td><td>points to the aperture structure to store the current Scaler device setting after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9223c7dbff7bbc1d126fd64f87af8767"></a><!-- doxytag: member="xscaler.c::XScaler_GetCoeffBankSharingInfo" ref="9223c7dbff7bbc1d126fd64f87af8767" args="(XScaler *InstancePtr, u8 *ChromaFormat, u8 *ChromaLumaShareCoeff, u8 *HoriVertShareCoeff)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetCoeffBankSharingInfo           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ChromaFormat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>ChromaLumaShareCoeff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>HoriVertShareCoeff</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function fetches the color space format and coefficient bank sharing decisions made on a Scaler device at build-time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChromaFormat</em>&nbsp;</td><td>points to an 8-bit variable that will be assigned with the Chroma format chosen for the Scaler device at the build time after this function returns. Please use XSCL_CHROMA_FORMAT_* defined in <a class="el" href="xscaler__hw_8h.html">xscaler_hw.h</a> to interpret the variable value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChromaLumaShareCoeff</em>&nbsp;</td><td>points to an 8-bit variable that will be assigned by this function with the decision value on coefficient bank sharing between Chroma and Luma filter operations. The decision is made for the Scaler device at build time and can NOT be changed at run-time. Value 0 indicates that each of Chroma and Luma filter operations has its own coefficient bank. Value 1 indicates that Chroma and Luma filter operations share one common coefficient bank. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriVertShareCoeff</em>&nbsp;</td><td>points to an 8-bit variable that will be assigned by this function with the decision value on coefficient bank sharing between Horizontal and Vertical filter operations. The decision is made for the Scaler device at build time and can NOT be changed at run-time. Value 0 indicates that each of Horizontal and Vertical filter operations has its own coefficient bank. Value 1 indicates that Horizontal and Vertical filter operations share one common coefficient bank.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
!!!IMPORTANT!!!<p>
The application of this function is responsible for loading the correct number of coefficient banks in the proper sequence order. The number of coefficient banks to load and the proper loading sequence totally depends on the values of the output parameters of this function. Please use the table below as reference.<p>
<pre>
 ChromaFormat ChromaLumaShareCoeff HoriVertShareCoeff # of      sequence
                                                      coeff     of
                                                      banks     loading
                                                      to load   coeff
                                                                banks
 ------------ -------------------- ------------------ --------  -------------
 YUV420       1                    1                  1         1.Single bank
 ------------ -------------------- ------------------ --------  -------------
 YUV420       1                    0                  2         1.Hori bank
                                                                2.Vert bank
 ------------ -------------------- ------------------ --------  -------------
 YUV420       0                    1                  2         1.Luma bank
                                                                2.Chroma bank
 ------------ -------------------- ------------------ --------  -------------
 YUV420       0                    0                  4         1.Hori Luma
                                                                2.Hori Chroma
                                                                3.Vert Luma
                                                                4.Vert Chroma
 ------------ -------------------- ------------------ --------  -------------
 YUV422       1                    1                  1         1.Single bank
 ------------ -------------------- ------------------ --------  -------------
 YUV422       1                    0                  2         1.Hori bank
                                                                2.Vert bank
 ------------ -------------------- ------------------ --------  -------------
 YUV422       0                    1                  2         1.Luma bank
                                                                2.Chroma bank
 ------------ -------------------- ------------------ --------  -------------
 YUV422       0                    0                  4         1.Hori Luma
                                                                2.Hori Chroma
                                                                3.Vert Luma
                                                                4.Vert Chroma
 ------------ -------------------- ------------------ --------  -------------
 YUV444       Always 1             1                  1         1.Single bank
 ------------ -------------------- ------------------ --------  -------------
 YUV444       Always 1             0                  2         1.Hori bank
                                                                2.Vert bank
 ------------ -------------------- ------------------ --------  -------------
 </pre> 
</div>
</div><p>
<a class="anchor" name="52861252f27f173a530bb0c3758ab4d0"></a><!-- doxytag: member="xscaler.c::XScaler_GetPhaseNum" ref="52861252f27f173a530bb0c3758ab4d0" args="(XScaler *InstancePtr, u16 *VertPhaseNumPtr, u16 *HoriPhaseNumPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetPhaseNum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>VertPhaseNumPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16 *&nbsp;</td>
          <td class="paramname"> <em>HoriPhaseNumPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets the numbers of vertical and horizontal phases currently used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertPhaseNumPtr</em>&nbsp;</td><td>will point to the number of vertical phases used after this function returns. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriPhaseNumPtr</em>&nbsp;</td><td>will point to the number of horizontal phases used after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5956eef6c759a3e38a15b670a3bea159"></a><!-- doxytag: member="xscaler.c::XScaler_GetStartFraction" ref="5956eef6c759a3e38a15b670a3bea159" args="(XScaler *InstancePtr, XScalerStartFraction *StartFractionPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_GetStartFraction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *&nbsp;</td>
          <td class="paramname"> <em>StartFractionPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function gets Luma and Chroma start fractional values currently used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StartFractionPtr</em>&nbsp;</td><td>is a pointer to a start fractional value structure to be populated with the fractional values after this function returns.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fe44e79802fd28186ccd2f2d83653cad"></a><!-- doxytag: member="xscaler.c::XScaler_GetVersion" ref="fe44e79802fd28186ccd2f2d83653cad" args="(XScaler *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XScaler_GetVersion           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function returns the contents of version register of the Scaler core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler core instance to be worked on.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Contents of the version register.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="38beb0d182b0e794be3a56d7e5bb91f9"></a><!-- doxytag: member="xscaler.c::XScaler_LoadCoeffBank" ref="38beb0d182b0e794be3a56d7e5bb91f9" args="(XScaler *InstancePtr, XScalerCoeffBank *CoeffBankPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_LoadCoeffBank           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_coeff_bank.html">XScalerCoeffBank</a> *&nbsp;</td>
          <td class="paramname"> <em>CoeffBankPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function loads a coefficient bank to the Scaler core. A complete coefficient set contains 4 banks (if Luma, Chroma, Horizontal and Vertical filter operations do not share common banks. For more details see <a class="el" href="xscaler_8c.html#9223c7dbff7bbc1d126fd64f87af8767">XScaler_GetCoeffBankSharingInfo()</a>): Horizontal Luma, Horizontal Chroma, Vertical Luma and Vertical Chroma. all 4 banks must be loaded back to back in the order listed here. The caller is responsible for ensuring the sequence and this function does not check it.<p>
An example sequence to load an whole coefficient set is like: <pre>
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;HoriLumaCoeffBank);
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;HoriChromaCoeffBank);
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;VertLumaCoeffBank);
	   XScaler_LoadCoeffBank(&amp;Scaler, &amp;VertChromaCoeffBank);
 </pre><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CoeffBankPtr</em>&nbsp;</td><td>is a pointer to a coefficient bank that is to be loaded.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="538a5c851ce9b06c883dcd89f8746d19"></a><!-- doxytag: member="xscaler.c::XScaler_SetActiveCoeffSet" ref="538a5c851ce9b06c883dcd89f8746d19" args="(XScaler *InstancePtr, u8 VertSetIndex, u8 HoriSetIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetActiveCoeffSet           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>VertSetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>HoriSetIndex</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function chooses the active vertical and horizontal coefficient sets to be used by a Scaler device.<p>
Each coefficient set contains 4 banks: Horizontal Luma, Horizontal Chroma, Vertical Luma and Vertical Chroma. The horizontal part is independent from the vertical part and the Scaler device supports using the horizontal part of one coefficient set w/ the vertical part of a different coefficient set.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertSetIndex</em>&nbsp;</td><td>indicates the index of the coefficient set in which the vertical part will be used by the Scaler device. Valid value is from 0 to (the number of the coefficient sets implemented by the Scaler device - 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriSetIndex</em>&nbsp;</td><td>indicates the index of the coefficient set in which the horizontal part will be used by the Scaler device. Valid value is from 0 to (the number of the coefficient sets implemented by the Scaler device - 1).</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ecf963404e7cdbb8bff372e8f3eabe7"></a><!-- doxytag: member="xscaler.c::XScaler_SetAperture" ref="9ecf963404e7cdbb8bff372e8f3eabe7" args="(XScaler *InstancePtr, XScalerAperture *AperturePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XScaler_SetAperture           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_aperture.html">XScalerAperture</a> *&nbsp;</td>
          <td class="paramname"> <em>AperturePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets up aperture of a Scaler device. The aperture setting consists of input video aperture and output video size. This function calculates the scale factor accordingly based on the aperture setting and sets up the Scaler appropriately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AperturePtr</em>&nbsp;</td><td>points to the aperture setting structure to set up the Scaler device.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XST_SUCCESS.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="76bd8e1ac73b7a0eb116206f97fe8502"></a><!-- doxytag: member="xscaler.c::XScaler_SetPhaseNum" ref="76bd8e1ac73b7a0eb116206f97fe8502" args="(XScaler *InstancePtr, u16 VertPhaseNum, u16 HoriPhaseNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetPhaseNum           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>VertPhaseNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>HoriPhaseNum</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets the numbers of vertical and horizontal phases to be used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>VertPhaseNum</em>&nbsp;</td><td>is the number of vertical phase to set to </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HoriPhaseNum</em>&nbsp;</td><td>is the number of horizontal phase to set to</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5a13eaec4e81070651fd5d38cecca772"></a><!-- doxytag: member="xscaler.c::XScaler_SetStartFraction" ref="5a13eaec4e81070651fd5d38cecca772" args="(XScaler *InstancePtr, XScalerStartFraction *StartFractionPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XScaler_SetStartFraction           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_scaler.html">XScaler</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_scaler_start_fraction.html">XScalerStartFraction</a> *&nbsp;</td>
          <td class="paramname"> <em>StartFractionPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function sets up Luma and Chroma start fractional values used by a Scaler device.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the Scaler device instance to be worked on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StartFractionPtr</em>&nbsp;</td><td>is a pointer to a start fractional value set to be used.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="59e75ae65e791e6f8c59aea4251a6c9e"></a><!-- doxytag: member="xscaler.c::XScaler_CoefficientBinScalingFactors" ref="59e75ae65e791e6f8c59aea4251a6c9e" args="[XSCL_NUM_COEF_BINS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 <a class="el" href="xscaler__coefs_8c.html#59e75ae65e791e6f8c59aea4251a6c9e">XScaler_CoefficientBinScalingFactors</a>[XSCL_NUM_COEF_BINS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
XScaler_CoefficientsBinScalingFactors contains scaling factors calculated using (Output_Size * 10000 / Input_Size). This table could help find the index of coefficient Bin given an input size and a output size. 
</div>
</div><p>
Copyright @ 1995-2014 Xilinx, Inc. All rights reserved. 
