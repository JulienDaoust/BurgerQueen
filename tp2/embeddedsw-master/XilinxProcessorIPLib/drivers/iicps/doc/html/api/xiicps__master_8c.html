<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver iicps v2_2: xiicps_master.c File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xiicps_master.c File Reference</h1><code>#include &quot;<a class="el" href="xiicps_8h.html">xiicps.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#a6bf043d1f4ee43a6491cae17d69d6aab">TransmitFifoFill</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#a2397f3223a6a605589bd04f4efc19645">XIicPs_MasterSend</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#a1a5c4c30e909af535b86fe17e8042158">XIicPs_MasterRecv</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#a3fd667195d70969329f3fec24fd3705c">XIicPs_MasterSendPolled</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#af5baaa3766a6716254e6cf95ebf128a7">XIicPs_MasterRecvPolled</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#a597faa64ccaf3d8034e3e92989048f06">XIicPs_EnableSlaveMonitor</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#a15f2e8071ff8d8e1ec1dc56d29ab202b">XIicPs_DisableSlaveMonitor</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps__master_8c.html#ad64f0389aa694ecf21ca8a39e44cf13f">XIicPs_MasterInterruptHandler</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Handles master mode transfers.</p>
<pre> MODIFICATION HISTORY:</pre><pre> Ver   Who  Date     Changes
 ----- ---  -------- ---------------------------------------------
 1.00a jz   01/30/10 First release
 1.00a sdm  09/21/11 Updated the XIicPs_SetupMaster to not check for
		      Bus Busy condition when the Hold Bit is set.
 1.01a sg   03/30/12 Fixed an issue in XIicPs_MasterSendPolled where a
		      check for transfer completion is added, which indicates
			 the completion of current transfer.
 2.0   hk   03/07/14 Added check for error status in the while loop that
                     checks for completion. CR# 762244, 764875.
 2.1   hk   04/24/14 Fix for CR# 789821 to handle &gt;14 byte transfers.
                     Fix for CR# 761060 - provision for repeated start.</pre><pre> </pre> <hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6bf043d1f4ee43a6491cae17d69d6aab"></a><!-- doxytag: member="xiicps_master.c::TransmitFifoFill" ref="a6bf043d1f4ee43a6491cae17d69d6aab" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TransmitFifoFill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put more data into the transmit FIFO, number of bytes is ether expected number of bytes for this transfer or available space in FIFO, which ever is less.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of bytes left for this instance.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is function is shared by master and slave. </dd></dl>

</div>
</div>
<a class="anchor" id="a15f2e8071ff8d8e1ec1dc56d29ab202b"></a><!-- doxytag: member="xiicps_master.c::XIicPs_DisableSlaveMonitor" ref="a15f2e8071ff8d8e1ec1dc56d29ab202b" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_DisableSlaveMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables slave monitor mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a597faa64ccaf3d8034e3e92989048f06"></a><!-- doxytag: member="xiicps_master.c::XIicPs_EnableSlaveMonitor" ref="a597faa64ccaf3d8034e3e92989048f06" args="(XIicPs *InstancePtr, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_EnableSlaveMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the slave monitor mode.</p>
<p>It enables slave monitor in the control register and enables slave ready interrupt. It then does an address transfer to slave. Interrupt handler will signal the caller if slave responds to the address transfer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we want to contact.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad64f0389aa694ecf21ca8a39e44cf13f"></a><!-- doxytag: member="xiicps_master.c::XIicPs_MasterInterruptHandler" ref="ad64f0389aa694ecf21ca8a39e44cf13f" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_MasterInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interrupt handler for the master mode. It does the protocol handling for the interrupt-driven transfers.</p>
<p>Completion events and errors are signaled to upper layer for proper handling.</p>
<pre>
 The interrupts that are handled are:</p>
<ul>
<li>DATA
	This case is handled only for master receive data.
	The master has to request for more data (if there is more data to
	receive) and read the data from the FIFO .</li>
</ul>
</pre><pre><ul>
<li>COMP
	If the Master is transmitting data and there is more data to be
	sent then the data is written to the FIFO. If there is no more data to
	be transmitted then a completion event is signalled to the upper layer
	by calling the callback handler.</li>
</ul>
</pre><pre>	If the Master is receiving data then the data is read from the FIFO and
	the Master has to request for more data (if there is more data to
	receive). If all the data has been received then a completion event
	is signalled to the upper layer by calling the callback handler.
	It is an error if the amount of received data is more than expected.</pre><pre><ul>
<li>NAK and SLAVE_RDY
	This is signalled to the upper layer by calling the callback handler.</li>
</ul>
</pre><pre><ul>
<li>All Other interrupts
	These interrupts are marked as error. This is signalled to the upper
	layer by calling the callback handler.</li>
</ul>
</pre><pre> </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a5c4c30e909af535b86fe17e8042158"></a><!-- doxytag: member="xiicps_master.c::XIicPs_MasterRecv" ref="a1a5c4c30e909af535b86fe17e8042158" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_MasterRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates an interrupt-driven receive in master mode.</p>
<p>It sets the transfer size register so the slave can send data to us. The rest of the work is managed by interrupt handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are receiving from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This receive routine is for interrupt-driven transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="af5baaa3766a6716254e6cf95ebf128a7"></a><!-- doxytag: member="xiicps_master.c::XIicPs_MasterRecvPolled" ref="af5baaa3766a6716254e6cf95ebf128a7" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_MasterRecvPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates a polled mode receive in master mode.</p>
<p>It repeatedly sets the transfer size register so the slave can send data to us. It polls the data register for data to come in. If slave fails to send us data, it fails with time out.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are receiving from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything went well.</li>
<li>XST_FAILURE if timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This receive routine is for polled mode transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a2397f3223a6a605589bd04f4efc19645"></a><!-- doxytag: member="xiicps_master.c::XIicPs_MasterSend" ref="a2397f3223a6a605589bd04f4efc19645" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_MasterSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates an interrupt-driven send in master mode.</p>
<p>It tries to send the first FIFO-full of data, then lets the interrupt handler to handle the rest of the data if there is any.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the send buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are sending to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This send routine is for interrupt-driven transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fd667195d70969329f3fec24fd3705c"></a><!-- doxytag: member="xiicps_master.c::XIicPs_MasterSendPolled" ref="a3fd667195d70969329f3fec24fd3705c" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_MasterSendPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates a polled mode send in master mode.</p>
<p>It sends data to the FIFO and waits for the slave to pick them up. If slave fails to remove data from FIFO, the send fails with time out.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the send buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are sending to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything went well.</li>
<li>XST_FAILURE if timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This send routine is for polled mode transfer only. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
