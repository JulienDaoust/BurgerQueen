<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver iicps v2_2: xiicps.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xiicps.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xiicps__hw_8h.html">xiicps_hw.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_iic_ps___config.html">XIicPs_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_iic_ps.html">XIicPs</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a27348268a3738fea6e82f6ba0845a11b">XIICPS_H</a></td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration options</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp50f33d14f129e4548c1c270fd6725a78"></a> The following options may be specified or retrieved for the device and enable/disable additional features of the IIC. Each of the options are bit fields, so more than one may be specified. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#abaf93558635651b401ca9404cc777d73">XIICPS_7_BIT_ADDR_OPTION</a>&nbsp;&nbsp;&nbsp;0x01</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a4057e55c42ab0d06b32c55d5e67e0029">XIICPS_10_BIT_ADDR_OPTION</a>&nbsp;&nbsp;&nbsp;0x02</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a7748c81bca2cc231cba3fa780530d95a">XIICPS_SLAVE_MON_OPTION</a>&nbsp;&nbsp;&nbsp;0x04</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a820f2cd7e2c7b77b9b5966e87eae2c09">XIICPS_REP_START_OPTION</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td colspan="2"><div class="groupHeader">Callback events</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc478b096d0c15f7e00fb1b0587e19c87"></a> These constants specify the handler events that are passed to an application event handler from the driver. These constants are bit masks such that more than one event can be passed to the handler. </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a1646c08302f01007599cd95721006d35">XIICPS_EVENT_COMPLETE_SEND</a>&nbsp;&nbsp;&nbsp;0x0001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a6aa923029f051dc7a1f8db08cd8691ff">XIICPS_EVENT_COMPLETE_RECV</a>&nbsp;&nbsp;&nbsp;0x0002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ab1ed271a1272c5c85d84f4b71b740dfb">XIICPS_EVENT_TIME_OUT</a>&nbsp;&nbsp;&nbsp;0x0004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a60331546be6cd538df23e7ca3e1789fa">XIICPS_EVENT_ERROR</a>&nbsp;&nbsp;&nbsp;0x0008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ab784c2ba84387c6a91b0f279065bf396">XIICPS_EVENT_ARB_LOST</a>&nbsp;&nbsp;&nbsp;0x0010</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ad72c8977f9bab033f2c393d24a70d5be">XIICPS_EVENT_NACK</a>&nbsp;&nbsp;&nbsp;0x0020</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a71fcc8f7c4ee01454f8260667f30ed71">XIICPS_EVENT_SLAVE_RDY</a>&nbsp;&nbsp;&nbsp;0x0040</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a209dc1a98260b84e648df54ba923fc81">XIICPS_EVENT_RX_OVR</a>&nbsp;&nbsp;&nbsp;0x0080</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a809489609a6aabd5fd53c0242a565e59">XIICPS_EVENT_TX_OVR</a>&nbsp;&nbsp;&nbsp;0x0100</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ac593e16a56addd3ff460a40ff04e1ed4">XIICPS_EVENT_RX_UNF</a>&nbsp;&nbsp;&nbsp;0x0200</td></tr>
<tr><td colspan="2"><h2>Role constants</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrp9bbef19594e2bb00213beebd85d0861a"></a> These constants are used to pass into the device setup routines to set up the device according to transfer direction. </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a80e3362dd68172d429bb9361768d09e7">SENDING_ROLE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a9cfa5c76753b0658954c2c3dfec95d40">RECVING_ROLE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a6f509d74539ec1fa9580312e520ce0b8">XIICPS_MAX_TRANSFER_SIZE</a>&nbsp;&nbsp;&nbsp;(255 - 3)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a479fe9cf74b161f574917ec20852ad1c">XIicPs_SendByte</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a432020341d6b2c06bba8a084df9b5075">XIicPs_RecvByte</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ad5b508fb2987b4bf23a840389450deef">XIicPs_IntrHandler</a> )(void *CallBackRef, u32 StatusEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_iic_ps___config.html">XIicPs_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a870a0590f929871e55f6075baec5ca3a">XIicPs_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a904c028beeeb6ddb59c9b5506e15e7b3">XIicPs_CfgInitialize</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, <a class="el" href="struct_x_iic_ps___config.html">XIicPs_Config</a> *Config, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a3eaa694ecd774beca05bf79c1f9df6c0">XIicPs_Abort</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a1169a92eb8594d6f038816b5740916f7">XIicPs_Reset</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a0312ad44be4b3b1ff180b8ed5914b3d8">XIicPs_BusIsBusy</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#af01281358070e16262b5f3975fa3829b">XIicPs_SetStatusHandler</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, void *CallBackRef, <a class="el" href="xiicps_8h.html#ad5b508fb2987b4bf23a840389450deef">XIicPs_IntrHandler</a> FuncPtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a2397f3223a6a605589bd04f4efc19645">XIicPs_MasterSend</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a1a5c4c30e909af535b86fe17e8042158">XIicPs_MasterRecv</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a3fd667195d70969329f3fec24fd3705c">XIicPs_MasterSendPolled</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#af5baaa3766a6716254e6cf95ebf128a7">XIicPs_MasterRecvPolled</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a597faa64ccaf3d8034e3e92989048f06">XIicPs_EnableSlaveMonitor</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a15f2e8071ff8d8e1ec1dc56d29ab202b">XIicPs_DisableSlaveMonitor</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ad64f0389aa694ecf21ca8a39e44cf13f">XIicPs_MasterInterruptHandler</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ad1c7ffa09df93fb59f97b0a3bf5baaa7">XIicPs_SetupSlave</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u16 SlaveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a1a39e62019a5ec05553783cac9407c04">XIicPs_SlaveSend</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a254caa9f98a43ad9d9f70578c6755d18">XIicPs_SlaveRecv</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a5c1c2808b9167c733286e3ececdb492d">XIicPs_SlaveSendPolled</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#ac5aaa093732d91f467cec3afba9db192">XIicPs_SlaveRecvPolled</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u8 *MsgPtr, int ByteCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a716cdb9f63e56269824866872958dd78">XIicPs_SlaveInterruptHandler</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a00955258cdddc11409bb8ccd4982bc04">XIicPs_SelfTest</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a910b375d3b1509912a05823e39f23194">XIicPs_SetOptions</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#aef3f6a5df37b3fd0dcab3b767eb13d73">XIicPs_ClearOptions</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u32 Options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a20964e35a74f4e16f90e78510c9b4337">XIicPs_GetOptions</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a44112215ae990a4b118745ddede0d640">XIicPs_SetSClk</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr, u32 FsclHz)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xiicps_8h.html#a9f2d2d3d11c2c9125a5bc8a0d95593cb">XIicPs_GetSClk</a> (<a class="el" href="struct_x_iic_ps.html">XIicPs</a> *InstancePtr)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9cfa5c76753b0658954c2c3dfec95d40"></a><!-- doxytag: member="xiicps.h::RECVING_ROLE" ref="a9cfa5c76753b0658954c2c3dfec95d40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RECVING_ROLE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer direction is receiving </p>

</div>
</div>
<a class="anchor" id="a80e3362dd68172d429bb9361768d09e7"></a><!-- doxytag: member="xiicps.h::SENDING_ROLE" ref="a80e3362dd68172d429bb9361768d09e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SENDING_ROLE&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer direction is sending </p>

</div>
</div>
<a class="anchor" id="a4057e55c42ab0d06b32c55d5e67e0029"></a><!-- doxytag: member="xiicps.h::XIICPS_10_BIT_ADDR_OPTION" ref="a4057e55c42ab0d06b32c55d5e67e0029" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_10_BIT_ADDR_OPTION&nbsp;&nbsp;&nbsp;0x02</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>10-bit address mode </p>

</div>
</div>
<a class="anchor" id="abaf93558635651b401ca9404cc777d73"></a><!-- doxytag: member="xiicps.h::XIICPS_7_BIT_ADDR_OPTION" ref="abaf93558635651b401ca9404cc777d73" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_7_BIT_ADDR_OPTION&nbsp;&nbsp;&nbsp;0x01</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>7-bit address mode </p>

</div>
</div>
<a class="anchor" id="ab784c2ba84387c6a91b0f279065bf396"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_ARB_LOST" ref="ab784c2ba84387c6a91b0f279065bf396" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_ARB_LOST&nbsp;&nbsp;&nbsp;0x0010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Arbitration lost </p>

</div>
</div>
<a class="anchor" id="a6aa923029f051dc7a1f8db08cd8691ff"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_COMPLETE_RECV" ref="a6aa923029f051dc7a1f8db08cd8691ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_COMPLETE_RECV&nbsp;&nbsp;&nbsp;0x0002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive Complete Event </p>

</div>
</div>
<a class="anchor" id="a1646c08302f01007599cd95721006d35"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_COMPLETE_SEND" ref="a1646c08302f01007599cd95721006d35" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_COMPLETE_SEND&nbsp;&nbsp;&nbsp;0x0001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transmit Complete Event </p>

</div>
</div>
<a class="anchor" id="a60331546be6cd538df23e7ca3e1789fa"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_ERROR" ref="a60331546be6cd538df23e7ca3e1789fa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_ERROR&nbsp;&nbsp;&nbsp;0x0008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive error </p>

</div>
</div>
<a class="anchor" id="ad72c8977f9bab033f2c393d24a70d5be"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_NACK" ref="ad72c8977f9bab033f2c393d24a70d5be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_NACK&nbsp;&nbsp;&nbsp;0x0020</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>NACK Received </p>

</div>
</div>
<a class="anchor" id="a209dc1a98260b84e648df54ba923fc81"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_RX_OVR" ref="a209dc1a98260b84e648df54ba923fc81" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_RX_OVR&nbsp;&nbsp;&nbsp;0x0080</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RX overflow </p>

</div>
</div>
<a class="anchor" id="ac593e16a56addd3ff460a40ff04e1ed4"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_RX_UNF" ref="ac593e16a56addd3ff460a40ff04e1ed4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_RX_UNF&nbsp;&nbsp;&nbsp;0x0200</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>RX underflow </p>

</div>
</div>
<a class="anchor" id="a71fcc8f7c4ee01454f8260667f30ed71"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_SLAVE_RDY" ref="a71fcc8f7c4ee01454f8260667f30ed71" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_SLAVE_RDY&nbsp;&nbsp;&nbsp;0x0040</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slave ready </p>

</div>
</div>
<a class="anchor" id="ab1ed271a1272c5c85d84f4b71b740dfb"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_TIME_OUT" ref="ab1ed271a1272c5c85d84f4b71b740dfb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_TIME_OUT&nbsp;&nbsp;&nbsp;0x0004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Transfer timed out </p>

</div>
</div>
<a class="anchor" id="a809489609a6aabd5fd53c0242a565e59"></a><!-- doxytag: member="xiicps.h::XIICPS_EVENT_TX_OVR" ref="a809489609a6aabd5fd53c0242a565e59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_EVENT_TX_OVR&nbsp;&nbsp;&nbsp;0x0100</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TX overflow </p>

</div>
</div>
<a class="anchor" id="a27348268a3738fea6e82f6ba0845a11b"></a><!-- doxytag: member="xiicps.h::XIICPS_H" ref="a27348268a3738fea6e82f6ba0845a11b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f509d74539ec1fa9580312e520ce0b8"></a><!-- doxytag: member="xiicps.h::XIICPS_MAX_TRANSFER_SIZE" ref="a6f509d74539ec1fa9580312e520ce0b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_MAX_TRANSFER_SIZE&nbsp;&nbsp;&nbsp;(255 - 3)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a432020341d6b2c06bba8a084df9b5075"></a><!-- doxytag: member="xiicps.h::XIicPs_RecvByte" ref="a432020341d6b2c06bba8a084df9b5075" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIicPs_RecvByte</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                       \
        *(InstancePtr)-&gt;RecvBufferPtr ++ =                              \
         (u8)<a class="code" href="xiicps__hw_8h.html#a140ccea93d5db30437b80cefe55f3623">XIicPs_In32</a>((InstancePtr)-&gt;Config.BaseAddress              \
                  + <a class="code" href="xiicps__hw_8h.html#ac9101ca416d8b9e303b4a65c4840a1d5">XIICPS_DATA_OFFSET</a>);                                \
         (InstancePtr)-&gt;RecvByteCount --;                               \
}
</pre></div>
</div>
</div>
<a class="anchor" id="a820f2cd7e2c7b77b9b5966e87eae2c09"></a><!-- doxytag: member="xiicps.h::XIICPS_REP_START_OPTION" ref="a820f2cd7e2c7b77b9b5966e87eae2c09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_REP_START_OPTION&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Repeated Start </p>

</div>
</div>
<a class="anchor" id="a479fe9cf74b161f574917ec20852ad1c"></a><!-- doxytag: member="xiicps.h::XIicPs_SendByte" ref="a479fe9cf74b161f574917ec20852ad1c" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIicPs_SendByte</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                       \
         <a class="code" href="xiicps__hw_8h.html#a2b1db1e3cb3185be41fe8ea44c453f6d">XIicPs_Out32</a>((InstancePtr)-&gt;Config.BaseAddress                 \
                         + <a class="code" href="xiicps__hw_8h.html#ac9101ca416d8b9e303b4a65c4840a1d5">XIICPS_DATA_OFFSET</a>,                          \
        *(InstancePtr)-&gt;SendBufferPtr ++);                              \
         (InstancePtr)-&gt;SendByteCount --;                               \
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7748c81bca2cc231cba3fa780530d95a"></a><!-- doxytag: member="xiicps.h::XIICPS_SLAVE_MON_OPTION" ref="a7748c81bca2cc231cba3fa780530d95a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XIICPS_SLAVE_MON_OPTION&nbsp;&nbsp;&nbsp;0x04</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Slave monitor mode </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad5b508fb2987b4bf23a840389450deef"></a><!-- doxytag: member="xiicps.h::XIicPs_IntrHandler" ref="ad5b508fb2987b4bf23a840389450deef" args=")(void *CallBackRef, u32 StatusEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xiicps_8h.html#ad5b508fb2987b4bf23a840389450deef">XIicPs_IntrHandler</a>)(void *CallBackRef, u32 StatusEvent)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The handler data type allows the user to define a callback function to respond to interrupt events in the system. This function is executed in interrupt context, so amount of processing should be minimized.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. Its type is not important to the driver, so it is a void pointer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>StatusEvent</em>&nbsp;</td><td>indicates one or more status events that occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a3eaa694ecd774beca05bf79c1f9df6c0"></a><!-- doxytag: member="xiicps.h::XIicPs_Abort" ref="a3eaa694ecd774beca05bf79c1f9df6c0" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_Abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Aborts a transfer in progress by resetting the FIFOs. The byte counts are cleared.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a0312ad44be4b3b1ff180b8ed5914b3d8"></a><!-- doxytag: member="xiicps.h::XIicPs_BusIsBusy" ref="a0312ad44be4b3b1ff180b8ed5914b3d8" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_BusIsBusy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check whether the I2C bus is busy</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the bus is busy.</li>
<li>FALSE if the bus is not busy.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a904c028beeeb6ddb59c9b5506e15e7b3"></a><!-- doxytag: member="xiicps.h::XIicPs_CfgInitialize" ref="a904c028beeeb6ddb59c9b5506e15e7b3" args="(XIicPs *InstancePtr, XIicPs_Config *Config, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps___config.html">XIicPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes a specific <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance such that the driver is ready to use.</p>
<p>The state of the device after initialization is:</p>
<ul>
<li>Device is disabled</li>
<li>Slave mode</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>is a reference to a structure containing information about a specific IIC device. This function initializes an InstancePtr object for a specific device specified by the contents of Config. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. The caller is responsible for keeping the address mapping from EffectiveAddr to the device physical base address unchanged once this function is invoked. Unexpected errors may occur if the address mapping changes after this function is called. If address translation is not used, use ConfigPtr-&gt;BaseAddress for this parameter, passing the physical address instead.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The return value is XST_SUCCESS if successful.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aef3f6a5df37b3fd0dcab3b767eb13d73"></a><!-- doxytag: member="xiicps.h::XIicPs_ClearOptions" ref="aef3f6a5df37b3fd0dcab3b767eb13d73" args="(XIicPs *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_ClearOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears the options for the IIC device driver. The options control how the device behaves relative to the IIC bus. The device must be idle rather than busy transferring data before setting these device options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>contains the specified options to be cleared. This is a bit mask where a 1 means to turn the option off. One or more bit values may be contained in the mask. See the bit definitions named XIICPS_*_OPTION in <a class="el" href="xiicps_8h.html">xiicps.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if options are successfully set.</li>
<li>XST_DEVICE_IS_STARTED if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a15f2e8071ff8d8e1ec1dc56d29ab202b"></a><!-- doxytag: member="xiicps.h::XIicPs_DisableSlaveMonitor" ref="a15f2e8071ff8d8e1ec1dc56d29ab202b" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_DisableSlaveMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables slave monitor mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a597faa64ccaf3d8034e3e92989048f06"></a><!-- doxytag: member="xiicps.h::XIicPs_EnableSlaveMonitor" ref="a597faa64ccaf3d8034e3e92989048f06" args="(XIicPs *InstancePtr, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_EnableSlaveMonitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the slave monitor mode.</p>
<p>It enables slave monitor in the control register and enables slave ready interrupt. It then does an address transfer to slave. Interrupt handler will signal the caller if slave responds to the address transfer.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we want to contact.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a20964e35a74f4e16f90e78510c9b4337"></a><!-- doxytag: member="xiicps.h::XIicPs_GetOptions" ref="a20964e35a74f4e16f90e78510c9b4337" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIicPs_GetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the options for the IIC device. The options control how the device behaves relative to the IIC bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>32 bit mask of the options, where a 1 means the option is on, and a 0 means to the option is off. One or more bit values may be contained in the mask. See the bit definitions named XIICPS_*_OPTION in the file <a class="el" href="xiicps_8h.html">xiicps.h</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f2d2d3d11c2c9125a5bc8a0d95593cb"></a><!-- doxytag: member="xiicps.h::XIicPs_GetSClk" ref="a9f2d2d3d11c2c9125a5bc8a0d95593cb" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XIicPs_GetSClk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the serial clock rate for the IIC device. The device must be idle rather than busy transferring data before setting these device options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the IIC clock to the nearest Hz based on the control register settings. The actual value may not be exact to to integer math rounding errors.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a870a0590f929871e55f6075baec5ca3a"></a><!-- doxytag: member="xiicps.h::XIicPs_LookupConfig" ref="a870a0590f929871e55f6075baec5ca3a" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_iic_ps___config.html">XIicPs_Config</a>* XIicPs_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Looks up the device configuration based on the unique device ID. A table contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>contains the ID of the device to look up the configuration for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the configuration found or NULL if the specified device ID was not found. See <a class="el" href="xiicps_8h.html">xiicps.h</a> for the definition of <a class="el" href="struct_x_iic_ps___config.html">XIicPs_Config</a>.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad64f0389aa694ecf21ca8a39e44cf13f"></a><!-- doxytag: member="xiicps.h::XIicPs_MasterInterruptHandler" ref="ad64f0389aa694ecf21ca8a39e44cf13f" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_MasterInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interrupt handler for the master mode. It does the protocol handling for the interrupt-driven transfers.</p>
<p>Completion events and errors are signaled to upper layer for proper handling.</p>
<pre>
 The interrupts that are handled are:</p>
<ul>
<li>DATA
	This case is handled only for master receive data.
	The master has to request for more data (if there is more data to
	receive) and read the data from the FIFO .</li>
</ul>
</pre><pre><ul>
<li>COMP
	If the Master is transmitting data and there is more data to be
	sent then the data is written to the FIFO. If there is no more data to
	be transmitted then a completion event is signalled to the upper layer
	by calling the callback handler.</li>
</ul>
</pre><pre>	If the Master is receiving data then the data is read from the FIFO and
	the Master has to request for more data (if there is more data to
	receive). If all the data has been received then a completion event
	is signalled to the upper layer by calling the callback handler.
	It is an error if the amount of received data is more than expected.</pre><pre><ul>
<li>NAK and SLAVE_RDY
	This is signalled to the upper layer by calling the callback handler.</li>
</ul>
</pre><pre><ul>
<li>All Other interrupts
	These interrupts are marked as error. This is signalled to the upper
	layer by calling the callback handler.</li>
</ul>
</pre><pre> </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a5c4c30e909af535b86fe17e8042158"></a><!-- doxytag: member="xiicps.h::XIicPs_MasterRecv" ref="a1a5c4c30e909af535b86fe17e8042158" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_MasterRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates an interrupt-driven receive in master mode.</p>
<p>It sets the transfer size register so the slave can send data to us. The rest of the work is managed by interrupt handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are receiving from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This receive routine is for interrupt-driven transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="af5baaa3766a6716254e6cf95ebf128a7"></a><!-- doxytag: member="xiicps.h::XIicPs_MasterRecvPolled" ref="af5baaa3766a6716254e6cf95ebf128a7" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_MasterRecvPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates a polled mode receive in master mode.</p>
<p>It repeatedly sets the transfer size register so the slave can send data to us. It polls the data register for data to come in. If slave fails to send us data, it fails with time out.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be received. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are receiving from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything went well.</li>
<li>XST_FAILURE if timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This receive routine is for polled mode transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a2397f3223a6a605589bd04f4efc19645"></a><!-- doxytag: member="xiicps.h::XIicPs_MasterSend" ref="a2397f3223a6a605589bd04f4efc19645" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_MasterSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates an interrupt-driven send in master mode.</p>
<p>It tries to send the first FIFO-full of data, then lets the interrupt handler to handle the rest of the data if there is any.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the send buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are sending to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This send routine is for interrupt-driven transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fd667195d70969329f3fec24fd3705c"></a><!-- doxytag: member="xiicps.h::XIicPs_MasterSendPolled" ref="a3fd667195d70969329f3fec24fd3705c" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_MasterSendPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function initiates a polled mode send in master mode.</p>
<p>It sends data to the FIFO and waits for the slave to pick them up. If slave fails to remove data from FIFO, the send fails with time out.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the send buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be sent. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are sending to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything went well.</li>
<li>XST_FAILURE if timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This send routine is for polled mode transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a1169a92eb8594d6f038816b5740916f7"></a><!-- doxytag: member="xiicps.h::XIicPs_Reset" ref="a1169a92eb8594d6f038816b5740916f7" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Resets the IIC device. Reset must only be called after the driver has been initialized. The configuration of the device after reset is the same as its configuration after initialization. Any data transfer that is in progress is aborted.</p>
<p>The upper layer software is responsible for re-configuring (if necessary) and reenabling interrupts for the IIC device after the reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a00955258cdddc11409bb8ccd4982bc04"></a><!-- doxytag: member="xiicps.h::XIicPs_SelfTest" ref="a00955258cdddc11409bb8ccd4982bc04" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Runs a self-test on the driver/device. The self-test is destructive in that a reset of the device is performed in order to check the reset values of the registers and to get the device into a known state.</p>
<p>Upon successful return from the self-test, the device is reset.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
<li>XST_REGISTER_ERROR indicates a register did not read or write correctly</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a910b375d3b1509912a05823e39f23194"></a><!-- doxytag: member="xiicps.h::XIicPs_SetOptions" ref="a910b375d3b1509912a05823e39f23194" args="(XIicPs *InstancePtr, u32 Options)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Options</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the options for the IIC device driver. The options control how the device behaves relative to the IIC bus. The device must be idle rather than busy transferring data before setting these device options.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>contains the specified options to be set. This is a bit mask where a 1 means to turn the option on. One or more bit values may be contained in the mask. See the bit definitions named XIICPS_*_OPTION in <a class="el" href="xiicps_8h.html">xiicps.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if options are successfully set.</li>
<li>XST_DEVICE_IS_STARTED if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a44112215ae990a4b118745ddede0d640"></a><!-- doxytag: member="xiicps.h::XIicPs_SetSClk" ref="a44112215ae990a4b118745ddede0d640" args="(XIicPs *InstancePtr, u32 FsclHz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_SetSClk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>FsclHz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the serial clock rate for the IIC device. The device must be idle rather than busy transferring data before setting these device options.</p>
<p>The data rate is set by values in the control register. The formula for determining the correct register values is: Fscl = Fpclk/(22 x (divisor_a+1) x (divisor_b+1)) See the hardware data sheet for a full explanation of setting the serial clock rate.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FsclHz</em>&nbsp;</td><td>is the clock frequency in Hz. The two most common clock rates are 100KHz and 400KHz.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if options are successfully set.</li>
<li>XST_DEVICE_IS_STARTED if the device is currently transferring data. The transfer must complete or be aborted before setting options.</li>
<li>XST_FAILURE if the Fscl frequency can not be set.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The clock can not be faster than the input clock divide by 22. </dd></dl>

</div>
</div>
<a class="anchor" id="af01281358070e16262b5f3975fa3829b"></a><!-- doxytag: member="xiicps.h::XIicPs_SetStatusHandler" ref="af01281358070e16262b5f3975fa3829b" args="(XIicPs *InstancePtr, void *CallBackRef, XIicPs_IntrHandler FuncPtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_SetStatusHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="xiicps_8h.html#ad5b508fb2987b4bf23a840389450deef">XIicPs_IntrHandler</a>&nbsp;</td>
          <td class="paramname"> <em>FuncPtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the status callback function, the status handler, which the driver calls when it encounters conditions that should be reported to the higher layer software. The handler executes in an interrupt context, so the amount of processing should be minimized</p>
<p>Refer to the <a class="el" href="xiicps_8h.html">xiicps.h</a> file for a list of the Callback events. The events are defined to start with XIICPS_EVENT_*.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is the upper layer callback reference passed back when the callback function is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FuncPtr</em>&nbsp;</td><td>is the pointer to the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>The handler is called within interrupt context, so it should finish its work quickly. </p>

</div>
</div>
<a class="anchor" id="ad1c7ffa09df93fb59f97b0a3bf5baaa7"></a><!-- doxytag: member="xiicps.h::XIicPs_SetupSlave" ref="ad1c7ffa09df93fb59f97b0a3bf5baaa7" args="(XIicPs *InstancePtr, u16 SlaveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_SetupSlave </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>SlaveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets up the device to be a slave.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SlaveAddr</em>&nbsp;</td><td>is the address of the slave we are receiving from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Interrupt is always enabled no matter the tranfer is interrupt- driven or polled mode. Whether device will be interrupted or not depends on whether the device is connected to an interrupt controller and interrupt for the device is enabled. </dd></dl>

</div>
</div>
<a class="anchor" id="a716cdb9f63e56269824866872958dd78"></a><!-- doxytag: member="xiicps.h::XIicPs_SlaveInterruptHandler" ref="a716cdb9f63e56269824866872958dd78" args="(XIicPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_SlaveInterruptHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The interrupt handler for slave mode. It does the protocol handling for the interrupt-driven transfers.</p>
<p>Completion events and errors are signaled to upper layer for proper handling.</p>
<pre></pre><pre> The interrupts that are handled are:</p>
<ul>
<li>DATA
	If the instance is sending, it means that the master wants to read more
	data from us. Send more data, and check whether we are done with this
	send.</li>
</ul>
</pre><pre>	If the instance is receiving, it means that the master has writen
	more data to us. Receive more data, and check whether we are done with
	with this receive.</pre><pre><ul>
<li>COMP
	This marks that stop sequence has been sent from the master, transfer
	is about to terminate. However, for receiving, the master may have
	written us some data, so receive that first.</li>
</ul>
</pre><pre>	It is an error if the amount of transfered data is less than expected.</pre><pre><ul>
<li>NAK
	This marks that master does not want our data. It is for send only.</li>
</ul>
</pre><pre><ul>
<li>Other interrupts
	These interrupts are marked as error.</li>
</ul>
</pre><pre> </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a254caa9f98a43ad9d9f70578c6755d18"></a><!-- doxytag: member="xiicps.h::XIicPs_SlaveRecv" ref="a254caa9f98a43ad9d9f70578c6755d18" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_SlaveRecv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function setup a slave interrupt-driven receive. Data processing for the receive is handled by the interrupt handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This routine is for interrupt-driven transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5aaa093732d91f467cec3afba9db192"></a><!-- doxytag: member="xiicps.h::XIicPs_SlaveRecvPolled" ref="ac5aaa093732d91f467cec3afba9db192" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_SlaveRecvPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives a buffer in polled mode as a slave.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the receive buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be received.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything went well.</li>
<li>XST_FAILURE if timed out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This receive routine is for polled mode transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a39e62019a5ec05553783cac9407c04"></a><!-- doxytag: member="xiicps.h::XIicPs_SlaveSend" ref="a1a39e62019a5ec05553783cac9407c04" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XIicPs_SlaveSend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function setup a slave interrupt-driven send. It set the repeated start for the device is the tranfer size is larger than FIFO depth. Data processing for the send is initiated by the interrupt handler.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the send buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This send routine is for interrupt-driven transfer only. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c1c2808b9167c733286e3ececdb492d"></a><!-- doxytag: member="xiicps.h::XIicPs_SlaveSendPolled" ref="a5c1c2808b9167c733286e3ececdb492d" args="(XIicPs *InstancePtr, u8 *MsgPtr, int ByteCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XIicPs_SlaveSendPolled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_iic_ps.html">XIicPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>MsgPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ByteCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a buffer in polled mode as a slave.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_iic_ps.html">XIicPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MsgPtr</em>&nbsp;</td><td>is the pointer to the send buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ByteCount</em>&nbsp;</td><td>is the number of bytes to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if everything went well.</li>
<li>XST_FAILURE if master sends us data or master terminates the transfer before all data has sent out.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This send routine is for polled mode transfer only. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
