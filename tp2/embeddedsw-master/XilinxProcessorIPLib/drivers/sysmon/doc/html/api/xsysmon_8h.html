<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver sysmon v7_0: xsysmon.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xsysmon.h File Reference</h1><code>#include &quot;xil_types.h&quot;</code><br/>
<code>#include &quot;xil_assert.h&quot;</code><br/>
<code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_sys_mon___config.html">XSysMon_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_sys_mon.html">XSysMon</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a2983383ca62ff3388c03837f5fa59e64">XSYSMON_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a6107e293b2406555e93aaec74b2581c5">XSM_CH_CALIBRATION</a>&nbsp;&nbsp;&nbsp;XSM_CH_ADC_CALIB</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#acf2d376d1cb081da16ed3bb9082819c9">XSM_ATR_BRAM_UPPER</a>&nbsp;&nbsp;&nbsp;XSM_ATR_VBRAM_UPPER</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a9379c9f0bf54792abbe6557caf05c531">XSM_ATR_BRAM_LOWER</a>&nbsp;&nbsp;&nbsp;XSM_ATR_VBRAM_LOWER</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1d57ea7cf0aa423dc29cf14d8a45ddcf">XSysMon_IsEventSamplingModeSet</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3b2cfa1e10636a54c490f2e43d19d599">XSysMon_IsDrpBusy</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a63f1a8eed662201ee54f733d5ff64632">XSysMon_IsDrpLocked</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a251f2e509945b445a655fbc885f6a934">XSysMon_RawToTemperature</a>(AdcData)&nbsp;&nbsp;&nbsp;((((float)(AdcData)/65536.0f)/0.00198421639f ) - 273.15f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a2b75d20fe44358333e528a14340568ce">XSysMon_RawToVoltage</a>(AdcData)&nbsp;&nbsp;&nbsp;((((float)(AdcData))* (3.0f))/65536.0f)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a5564a9bf0b8fe67202118178139209c1">XSysMon_TemperatureToRaw</a>(Temperature)&nbsp;&nbsp;&nbsp;((int)(((Temperature) + 273.15f)*65536.0f*0.00198421639f))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aca23c289a4caa9f1ef31206e680216a4">XSysMon_VoltageToRaw</a>(Voltage)&nbsp;&nbsp;&nbsp;((int)((Voltage)*65536.0f/3.0f))</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for the different channels.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp4fe13686cfb18348d6fa7c41f272d652"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#af2f79c54dddbdf090934f80f315b2e60">XSM_CH_TEMP</a>&nbsp;&nbsp;&nbsp;0x0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a715e29a748cdd1b301bec9ac17c4c7f4">XSM_CH_VCCINT</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1c6a2517306958c69f3259057d3649a9">XSM_CH_VCCAUX</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#af9c81d9f5fa3d80cad2b374c84117840">XSM_CH_VPVN</a>&nbsp;&nbsp;&nbsp;0x3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a676a91c5452aa7ec285794dc3ee13d4b">XSM_CH_VREFP</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a120bab2a7a97a74da70eef07204728fb">XSM_CH_VREFN</a>&nbsp;&nbsp;&nbsp;0x5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a85ddd036ebae8bded2268b0e46846d8f">XSM_CH_VBRAM</a>&nbsp;&nbsp;&nbsp;0x6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3fdb14478def5283880cd4d65dfaf56f">XSM_CH_SUPPLY_CALIB</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a802955d06a498aca0909e488caee528c">XSM_CH_ADC_CALIB</a>&nbsp;&nbsp;&nbsp;0x08</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a15ea4b9f08ee9dc44fc000384ca36e42">XSM_CH_GAINERR_CALIB</a>&nbsp;&nbsp;&nbsp;0x09</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a8b490a3a6ed209a5bfc0096297c9bb02">XSM_CH_VCCPINT</a>&nbsp;&nbsp;&nbsp;0x0D</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#abf6a4e8e4a53c5938fb8c5adc1ec95f5">XSM_CH_VCCPAUX</a>&nbsp;&nbsp;&nbsp;0x0E</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3a9da1ca3c503d3015188e64b69b0a79">XSM_CH_VCCPDRO</a>&nbsp;&nbsp;&nbsp;0x0F</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a41aa90146d4e0786b8d36888e44aac34">XSM_CH_AUX_MIN</a>&nbsp;&nbsp;&nbsp;16</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ae8c007df4d1c481557120435619b4ff5">XSM_CH_AUX_MAX</a>&nbsp;&nbsp;&nbsp;31</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a679e35fd3d89ff1485bee5a3b9c76418">XSM_CH_VUSR0</a>&nbsp;&nbsp;&nbsp;32</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a09ec53e63383809409428cfe165d4b5e">XSM_CH_VUSR1</a>&nbsp;&nbsp;&nbsp;33</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#afc97ca44cd69c0c9bd9010cffc10e649">XSM_CH_VUSR2</a>&nbsp;&nbsp;&nbsp;34</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a24b8dbe8bcddbc7d58212d1127778936">XSM_CH_VUSR3</a>&nbsp;&nbsp;&nbsp;35</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for reading the Calibration Coefficient Data.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp4f35e0373c425f6004e7715938783468"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a6152ac28d736b4e0d1e214f3377fd1e9">XSM_CALIB_SUPPLY_OFFSET_COEFF</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a47dbdfce05bdc719f09f56e36ac154b1">XSM_CALIB_ADC_OFFSET_COEFF</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a173a9675e7f812b837aab6cf61457b6d">XSM_CALIB_GAIN_ERROR_COEFF</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indexes for reading the Minimum/Maximum Measurement Data.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpe958f5e9f4603bb7f6fd406d61a31e99"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a35d9814abedb2943f4a84ecff66351e5">XSM_MAX_TEMP</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ac4c1bb07247f2eec2f2b050895d0a6fe">XSM_MAX_VCCINT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a0318391019767d409a0df13f82003999">XSM_MAX_VCCAUX</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a125a6470843a75bf50cba26439d17c5d">XSM_MAX_VCCBRAM</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#af3acf3098ee563aa1cc3e35555d4e801">XSM_MIN_TEMP</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a0e819505f1aa02c85cfb49963509c9ef">XSM_MIN_VCCINT</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#abf3015adb8b42e4b09d5ef8634558852">XSM_MIN_VCCAUX</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a4cfd2213eaa970ea4ccb6af07266d4e0">XSM_MIN_VCCBRAM</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a0f35b47d8681e78aff84e6a0927801e8">XSM_MAX_VCCPINT</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aa517bc750733957f748a8599efcbd94b">XSM_MAX_VCCPAUX</a>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a9f5d09d03c91e4d4f6c5eb36ee51f49d">XSM_MAX_VCCPDRO</a>&nbsp;&nbsp;&nbsp;0xA</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a7ec80c726994b8a5d35aa5f3dab0abe0">XSM_MIN_VCCPINT</a>&nbsp;&nbsp;&nbsp;0xC</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a730ed3839f795398e98b4acab28ae871">XSM_MIN_VCCPAUX</a>&nbsp;&nbsp;&nbsp;0xD</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a29f9f37796fb6dd3d04c6bcee90aa5cb">XSM_MIN_VCCPDRO</a>&nbsp;&nbsp;&nbsp;0xE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3d9d131ad9160327f55e4eed30cda0b0">XSM_MAX_VUSR0</a>&nbsp;&nbsp;&nbsp;0x80</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a23ecddfc82defaf6705b023ff43720af">XSM_MAX_VUSR1</a>&nbsp;&nbsp;&nbsp;0x81</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a92939a6e07cbc27ad634ae6b7c0b06de">XSM_MAX_VUSR2</a>&nbsp;&nbsp;&nbsp;0x82</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a6821c504de1b1667ee26f1b99487ad05">XSM_MAX_VUSR3</a>&nbsp;&nbsp;&nbsp;0x83</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a81e445b9d831cbe255a00351c68d440f">XSM_MIN_VUSR0</a>&nbsp;&nbsp;&nbsp;0x88</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ab563dfe15d9b7b6a8fa0f3692f9b3e5e">XSM_MIN_VUSR1</a>&nbsp;&nbsp;&nbsp;0x89</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a8e69346a18ff738fe6c81388af226ffa">XSM_MIN_VUSR2</a>&nbsp;&nbsp;&nbsp;0x8A</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a2603d60079c74fa9386a95da99b6776f">XSM_MIN_VUSR3</a>&nbsp;&nbsp;&nbsp;0x8B</td></tr>
<tr><td colspan="2"><div class="groupHeader">Alarm Threshold(Limit) Register (ATR) indexes.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpa7f26e5519862974972f1a4af214e46e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a7e041ad6a624c7014aad8803d2f9667a">XSM_ATR_TEMP_UPPER</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#afaec457ade964c56292886c6351b6ff2">XSM_ATR_VCCINT_UPPER</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#af1f02865999885b46b1b1fdd64f71098">XSM_ATR_VCCAUX_UPPER</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aca2f92bee99f2e78c2418bb237763ab4">XSM_ATR_OT_UPPER</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a138ea63ae47cd1478f188045792a5aef">XSM_ATR_TEMP_LOWER</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#afd47f736b4ffb4dad7c37ff02a0c4cca">XSM_ATR_VCCINT_LOWER</a>&nbsp;&nbsp;&nbsp;5</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a6e1a39ae23bf829dbb3eb27f95582cea">XSM_ATR_VCCAUX_LOWER</a>&nbsp;&nbsp;&nbsp;6</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3c17894e2b8cc575bc8192c2ede7f019">XSM_ATR_OT_LOWER</a>&nbsp;&nbsp;&nbsp;7</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a66d8e4fa9b28a397f2ab3b8c4ec8c9bd">XSM_ATR_VBRAM_UPPER</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aa9c27ceda75f04117fd14c0d4953dfb1">XSM_ATR_VCCPINT_UPPER</a>&nbsp;&nbsp;&nbsp;9</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a7c9d3d4e2049d02ae0a2af56d369e3ec">XSM_ATR_VCCPAUX_UPPER</a>&nbsp;&nbsp;&nbsp;0xA</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a35093a4e5b2eb7b36175e697f7cab1da">XSM_ATR_VCCPDRO_UPPER</a>&nbsp;&nbsp;&nbsp;0xB</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a200ac191748136de6a8ea7933d326a82">XSM_ATR_VBRAM_LOWER</a>&nbsp;&nbsp;&nbsp;0xC</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a8515b5d767fdba85813d0e75196fef94">XSM_ATR_VCCPINT_LOWER</a>&nbsp;&nbsp;&nbsp;0xD</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a51615864452c57d8818072f4cab9c531">XSM_ATR_VCCPAUX_LOWER</a>&nbsp;&nbsp;&nbsp;0xE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ab9e2521f653d836c787840ce416dc755">XSM_ATR_VCCPDRO_LOWER</a>&nbsp;&nbsp;&nbsp;0xF</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a6d25afac70851006cbbfbdbdbb650aab">XSM_ATR_VUSR0_UPPER</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ab6ce2e0556ee79efdfd7f23da06831ab">XSM_ATR_VUSR1_UPPER</a>&nbsp;&nbsp;&nbsp;0x11</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1b8a7efe83b6b64fdf4c03a90ac4b127">XSM_ATR_VUSR2_UPPER</a>&nbsp;&nbsp;&nbsp;0x12</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a0e48e7d3ab3e83a42b2c7aa1373dff2f">XSM_ATR_VUSR3_UPPER</a>&nbsp;&nbsp;&nbsp;0x13</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a703b107a6f8a065db9221105c0b836f8">XSM_ATR_VUSR0_LOWER</a>&nbsp;&nbsp;&nbsp;0x18</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a9c72b6cf9fd3289855741cc9a89e25cd">XSM_ATR_VUSR1_LOWER</a>&nbsp;&nbsp;&nbsp;0x19</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a7003325ba0164c487b4cf0f113bf1099">XSM_ATR_VUSR2_LOWER</a>&nbsp;&nbsp;&nbsp;0x1A</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a4bbbbcead6d3f49bb23a83eda01c96e8">XSM_ATR_VUSR3_LOWER</a>&nbsp;&nbsp;&nbsp;0x1B</td></tr>
<tr><td colspan="2"><div class="groupHeader">Averaging to be done for the channels.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp2f5de4cba29b17ac80d9014b66f2a826"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a81e97c4d54cab391a4c816f2bb666a63">XSM_AVG_0_SAMPLES</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a7cd77d90e7456614726390476f3636c8">XSM_AVG_16_SAMPLES</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a30eabcd0f343d52159cce69aad462c37">XSM_AVG_64_SAMPLES</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a2bcf68b01a8ff59237bea9b303828e4f">XSM_AVG_256_SAMPLES</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td colspan="2"><div class="groupHeader">Channel Sequencer Modes of operation.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp0cf29d080fba74fda394cd25f28b43d6"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a223c74befcd8a6710ea7a7acbaf41636">XSM_SEQ_MODE_SAFE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#abd5917a2edc464012891450744a15a0c">XSM_SEQ_MODE_ONEPASS</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a090e870886f3ed8d58efc57c763772f2">XSM_SEQ_MODE_CONTINPASS</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3c4487fa8b08f41c807433ef456abc75">XSM_SEQ_MODE_SINGCHAN</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#acac995b84cec0748dde6c82998337b72">XSM_SEQ_MODE_SIMUL</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aa1b34b548ae9f0d95c1cd3185b6d84b4">XSM_SEQ_MODE_INDEPENDENT</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_sys_mon___config.html">XSysMon_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a02fbbb117ca8d4002ff222dcf2e4892d">XSysMon_LookupConfig</a> (u16 DeviceId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a543ff01a3a1c5b625c2b874cbb809465">XSysMon_CfgInitialize</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, <a class="el" href="struct_x_sys_mon___config.html">XSysMon_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a7f77755a291cf2bac28ff12a5cdd5d8a">XSysMon_Reset</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a34d731dace546db3397741f0d229cb3b">XSysMon_GetStatus</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a2220b73838f1d10b79b688d1a8ce4c03">XSysMon_GetAlarmOutputStatus</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ad9997219e88de3f17da39970d52014fe">XSysMon_StartAdcConversion</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a9efcdd44a813be1e9b0e33b64c616cb3">XSysMon_ResetAdc</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a07ab2025481799032cd40ff62f4b10f6">XSysMon_GetAdcData</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ae3e66317b9e918f0aeb5ca8bdc204c31">XSysMon_GetCalibCoefficient</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 CoeffType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a15022394c1ba90705c3227f6cfa0f892">XSysMon_GetMinMaxMeasurement</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 MeasurementType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#af3504732dccf017f38fa7ffd7483f358">XSysMon_SetAvg</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 Average)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ab3af3c52fe39c41739b9fe95657e23ed">XSysMon_GetAvg</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a44e6fba16cf4b8cc69301523ed8344ce">XSysMon_SetSingleChParams</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 Channel, int IncreaseAcqCycles, int IsEventMode, int IsDifferentialMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a458e2807135bef154d249e80b145520a">XSysMon_SetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u32 AlmEnableMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a97e7f65e62613938d74c4b4ddfa8a3fc">XSysMon_GetAlarmEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a94f9f1484443b0855b724b44e97f998c">XSysMon_SetCalibEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u16 Calibration)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1997b528dc71315f9ac87b7b3985967d">XSysMon_GetCalibEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a433e353cd5a25454ce2a6da51494e478">XSysMon_SetSequencerMode</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 SequencerMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a046913c88b8e3b794d21a14b8ed5219c">XSysMon_GetSequencerMode</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a415023d979e637bac035cf6f902ab256">XSysMon_SetSequencerEvent</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, int IsEventMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aa5e941d4d6d614920634a8ff1925cbfd">XSysMon_SetExtenalMux</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 Channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3c119682ea951295d41462e329da881a">XSysMon_SetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 Divisor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a78664f36e8cac2dd37b6cf6ddc340076">XSysMon_GetAdcClkDivisor</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a60d92b3a70aab326364319b3d1f1a7cc">XSysMon_SetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u64 ChEnableMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ad9aa35ccde843ef5b7182d171d3b4324">XSysMon_GetSeqChEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ae7072bfa213b7318fcc29408a459c0bb">XSysMon_SetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u64 AvgEnableChMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a5a31c725e3171a80ca4d90eebcee5577">XSysMon_GetSeqAvgEnables</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a3d3d8052fae049f4ca772b5956ced31f">XSysMon_SetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u32 InputModeChMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a45d42e268bdaba00cdbd121894aac96f">XSysMon_GetSeqInputMode</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#aeafd06e40eff4807b362edf043d725e8">XSysMon_SetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u32 AcqCyclesChMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#abbe503899860c22ba1ee72db5171ba34">XSysMon_GetSeqAcqTime</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#af9d2de8d4141ae1e7e073ea296df739d">XSysMon_SetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 AlarmThrReg, u16 Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#adacbf7c393aa18cacfc08e267db5e87b">XSysMon_GetAlarmThreshold</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u8 AlarmThrReg)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a433f79238dd1c1cdd6e1b1cfb9c0e7a1">XSysMon_SetOverTemp</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u16 Value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a40de55fb20bf40a5cc9c12fe9ee844bd">XSysMon_GetOverTemp</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a8967ba93f41673db1105df3d6d851e62">XSysMon_EnableUserOverTemp</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1d7558af57526ea84cb80a2395549b53">XSysMon_DisableUserOverTemp</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a6d5e047df91be7cc3463ae0881754f0f">XSysMon_EnableTempUpdate</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1d581ce24419f37988afac551a0f1a75">XSysMon_DisableTempUpdate</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#ae3c96e6cb365a22d5aff07acaedb2101">XSysMon_SetTempWaitCycles</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u16 WaitCycles)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a23b6bce798cabbee7cb637d36edd54da">XSysMon_SelfTest</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a10375fa7b5de21898a2184fa934d04ca">XSysMon_IntrGlobalEnable</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a025ee112aa4af95e592b05ce99b07497">XSysMon_IntrGlobalDisable</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a42618007571bfd0d5f51dfcc66de0c12">XSysMon_IntrEnable</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a2f1afce92df09c2b023605eb510fcc61">XSysMon_IntrDisable</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a1b3e61dde34a23c6c906ddde3aabcce3">XSysMon_IntrGetEnabled</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a49bbe691a17f0d77753754fb18cfadb4">XSysMon_IntrGetStatus</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xsysmon_8h.html#a27b30e66ba4301e6cb02d1cc6a478a2b">XSysMon_IntrClear</a> (<a class="el" href="struct_x_sys_mon.html">XSysMon</a> *InstancePtr, u32 Mask)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a9379c9f0bf54792abbe6557caf05c531"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_BRAM_LOWER" ref="a9379c9f0bf54792abbe6557caf05c531" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_BRAM_LOWER&nbsp;&nbsp;&nbsp;XSM_ATR_VBRAM_LOWER</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="acf2d376d1cb081da16ed3bb9082819c9"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_BRAM_UPPER" ref="acf2d376d1cb081da16ed3bb9082819c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_BRAM_UPPER&nbsp;&nbsp;&nbsp;XSM_ATR_VBRAM_UPPER</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c17894e2b8cc575bc8192c2ede7f019"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_OT_LOWER" ref="a3c17894e2b8cc575bc8192c2ede7f019" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_OT_LOWER&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lower Over Temperature limit </p>

</div>
</div>
<a class="anchor" id="aca2f92bee99f2e78c2418bb237763ab4"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_OT_UPPER" ref="aca2f92bee99f2e78c2418bb237763ab4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_OT_UPPER&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Lower Over Temperature limit </p>

</div>
</div>
<a class="anchor" id="a138ea63ae47cd1478f188045792a5aef"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_TEMP_LOWER" ref="a138ea63ae47cd1478f188045792a5aef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_LOWER&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Low user Temperature </p>

</div>
</div>
<a class="anchor" id="a7e041ad6a624c7014aad8803d2f9667a"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_TEMP_UPPER" ref="a7e041ad6a624c7014aad8803d2f9667a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_TEMP_UPPER&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>High user Temperature </p>

</div>
</div>
<a class="anchor" id="a200ac191748136de6a8ea7933d326a82"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VBRAM_LOWER" ref="a200ac191748136de6a8ea7933d326a82" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VBRAM_LOWER&nbsp;&nbsp;&nbsp;0xC</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VRBAM Lower Alarm, 7 Series and Zynq </p>

</div>
</div>
<a class="anchor" id="a66d8e4fa9b28a397f2ab3b8c4ec8c9bd"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VBRAM_UPPER" ref="a66d8e4fa9b28a397f2ab3b8c4ec8c9bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VBRAM_UPPER&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VBRAM high voltage limit </p>

</div>
</div>
<a class="anchor" id="a6e1a39ae23bf829dbb3eb27f95582cea"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCAUX_LOWER" ref="a6e1a39ae23bf829dbb3eb27f95582cea" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCAUX_LOWER&nbsp;&nbsp;&nbsp;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCAUX low voltage limit </p>

</div>
</div>
<a class="anchor" id="af1f02865999885b46b1b1fdd64f71098"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCAUX_UPPER" ref="af1f02865999885b46b1b1fdd64f71098" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCAUX_UPPER&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCAUX high voltage limit </p>

</div>
</div>
<a class="anchor" id="afd47f736b4ffb4dad7c37ff02a0c4cca"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCINT_LOWER" ref="afd47f736b4ffb4dad7c37ff02a0c4cca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCINT_LOWER&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCINT low voltage limit </p>

</div>
</div>
<a class="anchor" id="afaec457ade964c56292886c6351b6ff2"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCINT_UPPER" ref="afaec457ade964c56292886c6351b6ff2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCINT_UPPER&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCINT high voltage limit </p>

</div>
</div>
<a class="anchor" id="a51615864452c57d8818072f4cab9c531"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCPAUX_LOWER" ref="a51615864452c57d8818072f4cab9c531" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCPAUX_LOWER&nbsp;&nbsp;&nbsp;0xE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCPAUX Lower Alarm, Zynq </p>

</div>
</div>
<a class="anchor" id="a7c9d3d4e2049d02ae0a2af56d369e3ec"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCPAUX_UPPER" ref="a7c9d3d4e2049d02ae0a2af56d369e3ec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCPAUX_UPPER&nbsp;&nbsp;&nbsp;0xA</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCPAUX Upper Alarm, Zynq </p>

</div>
</div>
<a class="anchor" id="ab9e2521f653d836c787840ce416dc755"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCPDRO_LOWER" ref="ab9e2521f653d836c787840ce416dc755" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCPDRO_LOWER&nbsp;&nbsp;&nbsp;0xF</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCPDRO Lower Alarm, Zynq </p>

</div>
</div>
<a class="anchor" id="a35093a4e5b2eb7b36175e697f7cab1da"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCPDRO_UPPER" ref="a35093a4e5b2eb7b36175e697f7cab1da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCPDRO_UPPER&nbsp;&nbsp;&nbsp;0xB</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCPDRO Upper Alarm, Zynq </p>

</div>
</div>
<a class="anchor" id="a8515b5d767fdba85813d0e75196fef94"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCPINT_LOWER" ref="a8515b5d767fdba85813d0e75196fef94" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCPINT_LOWER&nbsp;&nbsp;&nbsp;0xD</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCPINT Lower Alarm, Zynq </p>

</div>
</div>
<a class="anchor" id="aa9c27ceda75f04117fd14c0d4953dfb1"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VCCPINT_UPPER" ref="aa9c27ceda75f04117fd14c0d4953dfb1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VCCPINT_UPPER&nbsp;&nbsp;&nbsp;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCPINT Upper Alarm, Zynq </p>

</div>
</div>
<a class="anchor" id="a703b107a6f8a065db9221105c0b836f8"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR0_LOWER" ref="a703b107a6f8a065db9221105c0b836f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR0_LOWER&nbsp;&nbsp;&nbsp;0x18</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER0 Lower Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a6d25afac70851006cbbfbdbdbb650aab"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR0_UPPER" ref="a6d25afac70851006cbbfbdbdbb650aab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR0_UPPER&nbsp;&nbsp;&nbsp;0x10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER0 Upper Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a9c72b6cf9fd3289855741cc9a89e25cd"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR1_LOWER" ref="a9c72b6cf9fd3289855741cc9a89e25cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR1_LOWER&nbsp;&nbsp;&nbsp;0x19</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER1 Lower Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="ab6ce2e0556ee79efdfd7f23da06831ab"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR1_UPPER" ref="ab6ce2e0556ee79efdfd7f23da06831ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR1_UPPER&nbsp;&nbsp;&nbsp;0x11</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER1 Upper Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a7003325ba0164c487b4cf0f113bf1099"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR2_LOWER" ref="a7003325ba0164c487b4cf0f113bf1099" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR2_LOWER&nbsp;&nbsp;&nbsp;0x1A</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER2 Lower Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a1b8a7efe83b6b64fdf4c03a90ac4b127"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR2_UPPER" ref="a1b8a7efe83b6b64fdf4c03a90ac4b127" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR2_UPPER&nbsp;&nbsp;&nbsp;0x12</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER2 Upper Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a4bbbbcead6d3f49bb23a83eda01c96e8"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR3_LOWER" ref="a4bbbbcead6d3f49bb23a83eda01c96e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR3_LOWER&nbsp;&nbsp;&nbsp;0x1B</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER3 Lower Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a0e48e7d3ab3e83a42b2c7aa1373dff2f"></a><!-- doxytag: member="xsysmon.h::XSM_ATR_VUSR3_UPPER" ref="a0e48e7d3ab3e83a42b2c7aa1373dff2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_ATR_VUSR3_UPPER&nbsp;&nbsp;&nbsp;0x13</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER3 Upper Alarm, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a81e97c4d54cab391a4c816f2bb666a63"></a><!-- doxytag: member="xsysmon.h::XSM_AVG_0_SAMPLES" ref="a81e97c4d54cab391a4c816f2bb666a63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_0_SAMPLES&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>No Averaging </p>

</div>
</div>
<a class="anchor" id="a7cd77d90e7456614726390476f3636c8"></a><!-- doxytag: member="xsysmon.h::XSM_AVG_16_SAMPLES" ref="a7cd77d90e7456614726390476f3636c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_16_SAMPLES&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Average 16 samples </p>

</div>
</div>
<a class="anchor" id="a2bcf68b01a8ff59237bea9b303828e4f"></a><!-- doxytag: member="xsysmon.h::XSM_AVG_256_SAMPLES" ref="a2bcf68b01a8ff59237bea9b303828e4f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_256_SAMPLES&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Average 256 samples </p>

</div>
</div>
<a class="anchor" id="a30eabcd0f343d52159cce69aad462c37"></a><!-- doxytag: member="xsysmon.h::XSM_AVG_64_SAMPLES" ref="a30eabcd0f343d52159cce69aad462c37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_AVG_64_SAMPLES&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Average 64 samples </p>

</div>
</div>
<a class="anchor" id="a47dbdfce05bdc719f09f56e36ac154b1"></a><!-- doxytag: member="xsysmon.h::XSM_CALIB_ADC_OFFSET_COEFF" ref="a47dbdfce05bdc719f09f56e36ac154b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_ADC_OFFSET_COEFF&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ADC Offset Calib Coefficient </p>

</div>
</div>
<a class="anchor" id="a173a9675e7f812b837aab6cf61457b6d"></a><!-- doxytag: member="xsysmon.h::XSM_CALIB_GAIN_ERROR_COEFF" ref="a173a9675e7f812b837aab6cf61457b6d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_GAIN_ERROR_COEFF&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gain Error Calib Coefficient </p>

</div>
</div>
<a class="anchor" id="a6152ac28d736b4e0d1e214f3377fd1e9"></a><!-- doxytag: member="xsysmon.h::XSM_CALIB_SUPPLY_OFFSET_COEFF" ref="a6152ac28d736b4e0d1e214f3377fd1e9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CALIB_SUPPLY_OFFSET_COEFF&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supply Offset Calib Coefficient </p>

</div>
</div>
<a class="anchor" id="a802955d06a498aca0909e488caee528c"></a><!-- doxytag: member="xsysmon.h::XSM_CH_ADC_CALIB" ref="a802955d06a498aca0909e488caee528c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_ADC_CALIB&nbsp;&nbsp;&nbsp;0x08</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>ADC Offset Channel Reg </p>

</div>
</div>
<a class="anchor" id="ae8c007df4d1c481557120435619b4ff5"></a><!-- doxytag: member="xsysmon.h::XSM_CH_AUX_MAX" ref="ae8c007df4d1c481557120435619b4ff5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_AUX_MAX&nbsp;&nbsp;&nbsp;31</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Channel number for Last Aux channel </p>

</div>
</div>
<a class="anchor" id="a41aa90146d4e0786b8d36888e44aac34"></a><!-- doxytag: member="xsysmon.h::XSM_CH_AUX_MIN" ref="a41aa90146d4e0786b8d36888e44aac34" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_AUX_MIN&nbsp;&nbsp;&nbsp;16</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Channel number for 1st Aux Channel </p>

</div>
</div>
<a class="anchor" id="a6107e293b2406555e93aaec74b2581c5"></a><!-- doxytag: member="xsysmon.h::XSM_CH_CALIBRATION" ref="a6107e293b2406555e93aaec74b2581c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_CALIBRATION&nbsp;&nbsp;&nbsp;XSM_CH_ADC_CALIB</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a15ea4b9f08ee9dc44fc000384ca36e42"></a><!-- doxytag: member="xsysmon.h::XSM_CH_GAINERR_CALIB" ref="a15ea4b9f08ee9dc44fc000384ca36e42" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_GAINERR_CALIB&nbsp;&nbsp;&nbsp;0x09</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gain Error Channel Reg </p>

</div>
</div>
<a class="anchor" id="a3fdb14478def5283880cd4d65dfaf56f"></a><!-- doxytag: member="xsysmon.h::XSM_CH_SUPPLY_CALIB" ref="a3fdb14478def5283880cd4d65dfaf56f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_SUPPLY_CALIB&nbsp;&nbsp;&nbsp;0x07</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Supply Calib Data Reg </p>

</div>
</div>
<a class="anchor" id="af2f79c54dddbdf090934f80f315b2e60"></a><!-- doxytag: member="xsysmon.h::XSM_CH_TEMP" ref="af2f79c54dddbdf090934f80f315b2e60" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_TEMP&nbsp;&nbsp;&nbsp;0x0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On Chip Temperature </p>

</div>
</div>
<a class="anchor" id="a85ddd036ebae8bded2268b0e46846d8f"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VBRAM" ref="a85ddd036ebae8bded2268b0e46846d8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VBRAM&nbsp;&nbsp;&nbsp;0x6</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VBRAM - 7 Series and Zynq </p>

</div>
</div>
<a class="anchor" id="a1c6a2517306958c69f3259057d3649a9"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VCCAUX" ref="a1c6a2517306958c69f3259057d3649a9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCAUX&nbsp;&nbsp;&nbsp;0x2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCAUX </p>

</div>
</div>
<a class="anchor" id="a715e29a748cdd1b301bec9ac17c4c7f4"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VCCINT" ref="a715e29a748cdd1b301bec9ac17c4c7f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCINT&nbsp;&nbsp;&nbsp;0x1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VCCINT </p>

</div>
</div>
<a class="anchor" id="abf6a4e8e4a53c5938fb8c5adc1ec95f5"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VCCPAUX" ref="abf6a4e8e4a53c5938fb8c5adc1ec95f5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCPAUX&nbsp;&nbsp;&nbsp;0x0E</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On-chip PS VCCPAUX Channel, Zynq </p>

</div>
</div>
<a class="anchor" id="a3a9da1ca3c503d3015188e64b69b0a79"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VCCPDRO" ref="a3a9da1ca3c503d3015188e64b69b0a79" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCPDRO&nbsp;&nbsp;&nbsp;0x0F</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On-chip PS VCCPDRO Channel, Zynq </p>

</div>
</div>
<a class="anchor" id="a8b490a3a6ed209a5bfc0096297c9bb02"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VCCPINT" ref="a8b490a3a6ed209a5bfc0096297c9bb02" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VCCPINT&nbsp;&nbsp;&nbsp;0x0D</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>On-chip PS VCCPINT Channel, Zynq </p>

</div>
</div>
<a class="anchor" id="af9c81d9f5fa3d80cad2b374c84117840"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VPVN" ref="af9c81d9f5fa3d80cad2b374c84117840" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VPVN&nbsp;&nbsp;&nbsp;0x3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VP/VN Dedicated analog inputs </p>

</div>
</div>
<a class="anchor" id="a120bab2a7a97a74da70eef07204728fb"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VREFN" ref="a120bab2a7a97a74da70eef07204728fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VREFN&nbsp;&nbsp;&nbsp;0x5</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VREFN </p>

</div>
</div>
<a class="anchor" id="a676a91c5452aa7ec285794dc3ee13d4b"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VREFP" ref="a676a91c5452aa7ec285794dc3ee13d4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VREFP&nbsp;&nbsp;&nbsp;0x4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VREFP </p>

</div>
</div>
<a class="anchor" id="a679e35fd3d89ff1485bee5a3b9c76418"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VUSR0" ref="a679e35fd3d89ff1485bee5a3b9c76418" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VUSR0&nbsp;&nbsp;&nbsp;32</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER0 Supply - UltraScale </p>

</div>
</div>
<a class="anchor" id="a09ec53e63383809409428cfe165d4b5e"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VUSR1" ref="a09ec53e63383809409428cfe165d4b5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VUSR1&nbsp;&nbsp;&nbsp;33</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER1 Supply - UltraScale </p>

</div>
</div>
<a class="anchor" id="afc97ca44cd69c0c9bd9010cffc10e649"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VUSR2" ref="afc97ca44cd69c0c9bd9010cffc10e649" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VUSR2&nbsp;&nbsp;&nbsp;34</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER2 Supply - UltraScale </p>

</div>
</div>
<a class="anchor" id="a24b8dbe8bcddbc7d58212d1127778936"></a><!-- doxytag: member="xsysmon.h::XSM_CH_VUSR3" ref="a24b8dbe8bcddbc7d58212d1127778936" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_CH_VUSR3&nbsp;&nbsp;&nbsp;35</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>VUSER3 Supply - UltraScale </p>

</div>
</div>
<a class="anchor" id="a35d9814abedb2943f4a84ecff66351e5"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_TEMP" ref="a35d9814abedb2943f4a84ecff66351e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_TEMP&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum Temperature Data </p>

</div>
</div>
<a class="anchor" id="a0318391019767d409a0df13f82003999"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VCCAUX" ref="a0318391019767d409a0df13f82003999" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCAUX&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VCCAUX Data </p>

</div>
</div>
<a class="anchor" id="a125a6470843a75bf50cba26439d17c5d"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VCCBRAM" ref="a125a6470843a75bf50cba26439d17c5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCBRAM&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VCCBRAM Data, 7 Series/Zynq </p>

</div>
</div>
<a class="anchor" id="ac4c1bb07247f2eec2f2b050895d0a6fe"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VCCINT" ref="ac4c1bb07247f2eec2f2b050895d0a6fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCINT&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VCCINT Data </p>

</div>
</div>
<a class="anchor" id="aa517bc750733957f748a8599efcbd94b"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VCCPAUX" ref="aa517bc750733957f748a8599efcbd94b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCPAUX&nbsp;&nbsp;&nbsp;9</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VCCPAUX Data, Zynq </p>

</div>
</div>
<a class="anchor" id="a9f5d09d03c91e4d4f6c5eb36ee51f49d"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VCCPDRO" ref="a9f5d09d03c91e4d4f6c5eb36ee51f49d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCPDRO&nbsp;&nbsp;&nbsp;0xA</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VCCPDRO Data, Zynq </p>

</div>
</div>
<a class="anchor" id="a0f35b47d8681e78aff84e6a0927801e8"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VCCPINT" ref="a0f35b47d8681e78aff84e6a0927801e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VCCPINT&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VCCPINT Data, Zynq </p>

</div>
</div>
<a class="anchor" id="a3d9d131ad9160327f55e4eed30cda0b0"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VUSR0" ref="a3d9d131ad9160327f55e4eed30cda0b0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VUSR0&nbsp;&nbsp;&nbsp;0x80</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VUSR0 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a23ecddfc82defaf6705b023ff43720af"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VUSR1" ref="a23ecddfc82defaf6705b023ff43720af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VUSR1&nbsp;&nbsp;&nbsp;0x81</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VUSR1 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a92939a6e07cbc27ad634ae6b7c0b06de"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VUSR2" ref="a92939a6e07cbc27ad634ae6b7c0b06de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VUSR2&nbsp;&nbsp;&nbsp;0x82</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VUSR2 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a6821c504de1b1667ee26f1b99487ad05"></a><!-- doxytag: member="xsysmon.h::XSM_MAX_VUSR3" ref="a6821c504de1b1667ee26f1b99487ad05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MAX_VUSR3&nbsp;&nbsp;&nbsp;0x83</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Maximum VUSR3 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="af3acf3098ee563aa1cc3e35555d4e801"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_TEMP" ref="af3acf3098ee563aa1cc3e35555d4e801" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_TEMP&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum Temperature Data </p>

</div>
</div>
<a class="anchor" id="abf3015adb8b42e4b09d5ef8634558852"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VCCAUX" ref="abf3015adb8b42e4b09d5ef8634558852" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCAUX&nbsp;&nbsp;&nbsp;6</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VCCAUX Data </p>

</div>
</div>
<a class="anchor" id="a4cfd2213eaa970ea4ccb6af07266d4e0"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VCCBRAM" ref="a4cfd2213eaa970ea4ccb6af07266d4e0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCBRAM&nbsp;&nbsp;&nbsp;7</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VCCBRAM Data, 7 Series/Zynq </p>

</div>
</div>
<a class="anchor" id="a0e819505f1aa02c85cfb49963509c9ef"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VCCINT" ref="a0e819505f1aa02c85cfb49963509c9ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCINT&nbsp;&nbsp;&nbsp;5</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VCCINT Data </p>

</div>
</div>
<a class="anchor" id="a730ed3839f795398e98b4acab28ae871"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VCCPAUX" ref="a730ed3839f795398e98b4acab28ae871" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCPAUX&nbsp;&nbsp;&nbsp;0xD</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VCCPAUX Data, Zynq </p>

</div>
</div>
<a class="anchor" id="a29f9f37796fb6dd3d04c6bcee90aa5cb"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VCCPDRO" ref="a29f9f37796fb6dd3d04c6bcee90aa5cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCPDRO&nbsp;&nbsp;&nbsp;0xE</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VCCPDRO Data, Zynq </p>

</div>
</div>
<a class="anchor" id="a7ec80c726994b8a5d35aa5f3dab0abe0"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VCCPINT" ref="a7ec80c726994b8a5d35aa5f3dab0abe0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VCCPINT&nbsp;&nbsp;&nbsp;0xC</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VCCPINT Data, Zynq </p>

</div>
</div>
<a class="anchor" id="a81e445b9d831cbe255a00351c68d440f"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VUSR0" ref="a81e445b9d831cbe255a00351c68d440f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VUSR0&nbsp;&nbsp;&nbsp;0x88</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VUSR0 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="ab563dfe15d9b7b6a8fa0f3692f9b3e5e"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VUSR1" ref="ab563dfe15d9b7b6a8fa0f3692f9b3e5e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VUSR1&nbsp;&nbsp;&nbsp;0x89</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VUSR1 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a8e69346a18ff738fe6c81388af226ffa"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VUSR2" ref="a8e69346a18ff738fe6c81388af226ffa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VUSR2&nbsp;&nbsp;&nbsp;0x8A</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VUSR2 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a2603d60079c74fa9386a95da99b6776f"></a><!-- doxytag: member="xsysmon.h::XSM_MIN_VUSR3" ref="a2603d60079c74fa9386a95da99b6776f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_MIN_VUSR3&nbsp;&nbsp;&nbsp;0x8B</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Minimum VUSR3 Data, Ultrascale </p>

</div>
</div>
<a class="anchor" id="a090e870886f3ed8d58efc57c763772f2"></a><!-- doxytag: member="xsysmon.h::XSM_SEQ_MODE_CONTINPASS" ref="a090e870886f3ed8d58efc57c763772f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_CONTINPASS&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Continuous Cycling Seqquencer </p>

</div>
</div>
<a class="anchor" id="aa1b34b548ae9f0d95c1cd3185b6d84b4"></a><!-- doxytag: member="xsysmon.h::XSM_SEQ_MODE_INDEPENDENT" ref="aa1b34b548ae9f0d95c1cd3185b6d84b4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_INDEPENDENT&nbsp;&nbsp;&nbsp;8</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Independent ADC Sequencer, 7 Series and Zynq XADC only </p>

</div>
</div>
<a class="anchor" id="abd5917a2edc464012891450744a15a0c"></a><!-- doxytag: member="xsysmon.h::XSM_SEQ_MODE_ONEPASS" ref="abd5917a2edc464012891450744a15a0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_ONEPASS&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Onepass through Sequencer </p>

</div>
</div>
<a class="anchor" id="a223c74befcd8a6710ea7a7acbaf41636"></a><!-- doxytag: member="xsysmon.h::XSM_SEQ_MODE_SAFE" ref="a223c74befcd8a6710ea7a7acbaf41636" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SAFE&nbsp;&nbsp;&nbsp;0</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default Safe Mode </p>

</div>
</div>
<a class="anchor" id="acac995b84cec0748dde6c82998337b72"></a><!-- doxytag: member="xsysmon.h::XSM_SEQ_MODE_SIMUL" ref="acac995b84cec0748dde6c82998337b72" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SIMUL&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Simultaneous Cycling Sequencer, 7 Series and Zynq XADC only </p>

</div>
</div>
<a class="anchor" id="a3c4487fa8b08f41c807433ef456abc75"></a><!-- doxytag: member="xsysmon.h::XSM_SEQ_MODE_SINGCHAN" ref="a3c4487fa8b08f41c807433ef456abc75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSM_SEQ_MODE_SINGCHAN&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Single channel - No Sequencing </p>

</div>
</div>
<a class="anchor" id="a2983383ca62ff3388c03837f5fa59e64"></a><!-- doxytag: member="xsysmon.h::XSYSMON_H" ref="a2983383ca62ff3388c03837f5fa59e64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSYSMON_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b2cfa1e10636a54c490f2e43d19d599"></a><!-- doxytag: member="xsysmon.h::XSysMon_IsDrpBusy" ref="a3b2cfa1e10636a54c490f2e43d19d599" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_IsDrpBusy</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xsysmon__hw_8h.html#a9c287afa2245c955bd1fbcd8ed4f9b02">XSysMon_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,              \
                                <a class="code" href="xsysmon__hw_8h.html#aaba7d7c2a7407d9c762149d5f0baeb42">XSM_SR_OFFSET</a>) &amp; <a class="code" href="xsysmon__hw_8h.html#a0673507d625cd648b0a8dc56d3b29855">XSM_SR_JTAG_BUSY_MASK</a>) ? \
                                TRUE : FALSE)
</pre></div><p>This macro checks if the Dynamic Reconfiguration Port (DRP) transaction from the JTAG is in progress.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the DRP transaction from JTAG is in Progress.</li>
<li>FALSE if there is no DRP transaction from the JTAG.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xsysmon_8h.html#a3b2cfa1e10636a54c490f2e43d19d599">XSysMon_IsDrpBusy(XSysMon *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a63f1a8eed662201ee54f733d5ff64632"></a><!-- doxytag: member="xsysmon.h::XSysMon_IsDrpLocked" ref="a63f1a8eed662201ee54f733d5ff64632" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_IsDrpLocked</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((<a class="code" href="xsysmon__hw_8h.html#a9c287afa2245c955bd1fbcd8ed4f9b02">XSysMon_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,               \
                                <a class="code" href="xsysmon__hw_8h.html#aaba7d7c2a7407d9c762149d5f0baeb42">XSM_SR_OFFSET</a>) &amp; <a class="code" href="xsysmon__hw_8h.html#a56a09c31ef097b8e419109a7ae4eac0a">XSM_SR_JTAG_LOCKED_MASK</a>) ? \
                                TRUE : FALSE))
</pre></div><p>This macro checks if the Dynamic Reconfiguration Port (DRP) is locked by the JTAG.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the DRP is locked by the JTAG.</li>
<li>FALSE if the DRP is not locked by the JTAG.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xsysmon_8h.html#a63f1a8eed662201ee54f733d5ff64632">XSysMon_IsDrpLocked(XSysMon *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a1d57ea7cf0aa423dc29cf14d8a45ddcf"></a><!-- doxytag: member="xsysmon.h::XSysMon_IsEventSamplingModeSet" ref="a1d57ea7cf0aa423dc29cf14d8a45ddcf" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_IsEventSamplingModeSet</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">(((<a class="code" href="xsysmon__hw_8h.html#a9c287afa2245c955bd1fbcd8ed4f9b02">XSysMon_ReadReg</a>((InstancePtr)-&gt;Config.BaseAddress,           \
                                <a class="code" href="xsysmon__hw_8h.html#a9336095a2666fc857fe4767577420af0">XSM_CFR0_OFFSET</a>) &amp; <a class="code" href="xsysmon__hw_8h.html#a99dc4622e2ad4127b068c9d99502c1c4">XSM_CFR0_EC_MASK</a>) ?  \
                                TRUE : FALSE))
</pre></div><p>This macro checks if the SysMonitor/ADC device is in Event Sampling mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is in Event Sampling Mode.</li>
<li>FALSE if the device is in Continuous Sampling Mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int XSysMon_IsEventSamplingMode(XSysMon *InstancePtr); </dd></dl>

</div>
</div>
<a class="anchor" id="a251f2e509945b445a655fbc885f6a934"></a><!-- doxytag: member="xsysmon.h::XSysMon_RawToTemperature" ref="a251f2e509945b445a655fbc885f6a934" args="(AdcData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_RawToTemperature</td>
          <td>(</td>
          <td class="paramtype">AdcData&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((((float)(AdcData)/65536.0f)/0.00198421639f ) - 273.15f)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro converts System Monitor/ADC Raw Data to Temperature(centigrades).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdcData</em>&nbsp;</td><td>is the SysMon Raw ADC Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Temperature in centigrades.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: float <a class="el" href="xsysmon_8h.html#a251f2e509945b445a655fbc885f6a934">XSysMon_RawToTemperature(u32 AdcData)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a2b75d20fe44358333e528a14340568ce"></a><!-- doxytag: member="xsysmon.h::XSysMon_RawToVoltage" ref="a2b75d20fe44358333e528a14340568ce" args="(AdcData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_RawToVoltage</td>
          <td>(</td>
          <td class="paramtype">AdcData&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((((float)(AdcData))* (3.0f))/65536.0f)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro converts System Monitor/ADC Raw Data to Voltage(volts).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>AdcData</em>&nbsp;</td><td>is the System Monitor/ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Voltage in volts.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: float <a class="el" href="xsysmon_8h.html#a2b75d20fe44358333e528a14340568ce">XSysMon_RawToVoltage(u32 AdcData)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a5564a9bf0b8fe67202118178139209c1"></a><!-- doxytag: member="xsysmon.h::XSysMon_TemperatureToRaw" ref="a5564a9bf0b8fe67202118178139209c1" args="(Temperature)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_TemperatureToRaw</td>
          <td>(</td>
          <td class="paramtype">Temperature&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((int)(((Temperature) + 273.15f)*65536.0f*0.00198421639f))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro converts Temperature in centigrades to System Monitor/ADC Raw Data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Temperature</em>&nbsp;</td><td>is the Temperature in centigrades to be converted to System Monitor/ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The System Monitor/ADC Raw Data.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xsysmon_8h.html#a5564a9bf0b8fe67202118178139209c1">XSysMon_TemperatureToRaw(float Temperature)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="aca23c289a4caa9f1ef31206e680216a4"></a><!-- doxytag: member="xsysmon.h::XSysMon_VoltageToRaw" ref="aca23c289a4caa9f1ef31206e680216a4" args="(Voltage)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XSysMon_VoltageToRaw</td>
          <td>(</td>
          <td class="paramtype">Voltage&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((int)((Voltage)*65536.0f/3.0f))</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro converts Voltage in Volts to System Monitor/ADC Raw Data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Voltage</em>&nbsp;</td><td>is the Voltage in volts to be converted to System Monitor/ADC Raw Data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The System Monitor/ADC Raw Data.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xsysmon_8h.html#aca23c289a4caa9f1ef31206e680216a4">XSysMon_VoltageToRaw(float Voltage)</a>; </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a543ff01a3a1c5b625c2b874cbb809465"></a><!-- doxytag: member="xsysmon.h::XSysMon_CfgInitialize" ref="a543ff01a3a1c5b625c2b874cbb809465" args="(XSysMon *InstancePtr, XSysMon_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon___config.html">XSysMon_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functions in <a class="el" href="xsysmon_8c.html">xsysmon.c</a></p>
<p>This function initializes a specific <a class="el" href="struct_x_sys_mon.html">XSysMon</a> device/instance. This function must be called prior to using the System Monitor/ADC device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ConfigPtr</em>&nbsp;</td><td>points to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> device configuration structure. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddr</em>&nbsp;</td><td>is the device base address in the virtual memory address space. If the address translation is not used then the physical address is passed. Unexpected errors may occur if the address mapping is changed after this function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if successful.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The user needs to first call the <a class="el" href="xsysmon_8h.html#a02fbbb117ca8d4002ff222dcf2e4892d">XSysMon_LookupConfig()</a> API which returns the Configuration structure pointer which is passed as a parameter to the <a class="el" href="xsysmon_8c.html#a543ff01a3a1c5b625c2b874cbb809465">XSysMon_CfgInitialize()</a> API. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d581ce24419f37988afac551a0f1a75"></a><!-- doxytag: member="xsysmon.h::XSysMon_DisableTempUpdate" ref="a1d581ce24419f37988afac551a0f1a75" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_DisableTempUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the Temperature updation logic for TEMP_OUT port</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a1d7558af57526ea84cb80a2395549b53"></a><!-- doxytag: member="xsysmon.h::XSysMon_DisableUserOverTemp" ref="a1d7558af57526ea84cb80a2395549b53" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_DisableUserOverTemp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables programming of the powerdown temperature for the OverTemp signal in the OT Powerdown register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API should be used only with V6 SysMon/7 Series and Zynq XADC since the upper threshold of OverTemp is programmable in only V6 SysMon/7 Series and Zynq XADC. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d5e047df91be7cc3463ae0881754f0f"></a><!-- doxytag: member="xsysmon.h::XSysMon_EnableTempUpdate" ref="a6d5e047df91be7cc3463ae0881754f0f" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_EnableTempUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the Temperature updation logic so that temperature can be sent over TEMP_OUT port.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="a8967ba93f41673db1105df3d6d851e62"></a><!-- doxytag: member="xsysmon.h::XSysMon_EnableUserOverTemp" ref="a8967ba93f41673db1105df3d6d851e62" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_EnableUserOverTemp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables programming of the powerdown temperature for the OverTemp signal in the OT Powerdown register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API should be used only with V6/7 Series since the upper threshold of OverTemp is programmable in only V6 SysMon/7 Series and Zynq XADC. </dd></dl>

</div>
</div>
<a class="anchor" id="a78664f36e8cac2dd37b6cf6ddc340076"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetAdcClkDivisor" ref="a78664f36e8cac2dd37b6cf6ddc340076" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMon_GetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function gets the ADCCLK divisor from the Configuration Register 2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The divisor read from the Configuration Register 2.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2. </dd></dl>

</div>
</div>
<a class="anchor" id="a07ab2025481799032cd40ff62f4b10f6"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetAdcData" ref="a07ab2025481799032cd40ff62f4b10f6" args="(XSysMon *InstancePtr, u8 Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMon_GetAdcData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the ADC converted data for the specified channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>is the channel number. Use the XSM_CH_* defined in the file <a class="el" href="xsysmon_8h.html">xsysmon.h</a>. The valid channels are 0 to 5 and 16 to 31 for all the device families. Channel 6 is valid for 7 Series and Zynq. Channel 13, 14, 15 are valid for Zynq. 32 to 35 are valid for Ultrascale.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit value representing the ADC converted data for the specified channel. The System Monitor/ADC device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The channels 7,8,9 are used for calibration of the device and hence there is no associated data with this channel. Please make sure that the proper channel number is passed. </dd></dl>

</div>
</div>
<a class="anchor" id="a97e7f65e62613938d74c4b4ddfa8a3fc"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetAlarmEnables" ref="a97e7f65e62613938d74c4b4ddfa8a3fc" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_GetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the status of the alarm output enables in the Configuration Register 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>This is the bit-mask of the enabled alarm outputs in the Configuration Register 1. Use the masks XSM_CFR_ALM_*, XSM_CFR_ALM*_* and XSM_CFR_OT_MASK defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the returned value.</dd></dl>
<p>Bit positions of 1 indicate that the alarm output is enabled. Bit positions of 0 indicate that the alarm output is disabled.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that alarms for the bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The enabled alarm outputs returned by this function is the negated value of the the data read from the Configuration Register 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a2220b73838f1d10b79b688d1a8ce4c03"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetAlarmOutputStatus" ref="a2220b73838f1d10b79b688d1a8ce4c03" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_GetAlarmOutputStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the contents of Alarm Output Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value read from the Alarm Output Register. Use the XSM_AOR_*_MASK constants defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adacbf7c393aa18cacfc08e267db5e87b"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetAlarmThreshold" ref="adacbf7c393aa18cacfc08e267db5e87b" args="(XSysMon *InstancePtr, u8 AlarmThrReg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMon_GetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>AlarmThrReg</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the contents of the specified Alarm Threshold Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AlarmThrReg</em>&nbsp;</td><td>is the index of an Alarm Threshold Register to be read. Use XSM_ATR_* constants defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a> to specify the index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit value representing the contents of the selected Alarm Threshold Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Over Temperature upper threshold is programmable only in V6 and 7 Series XADC BRAM high and low voltage threshold registers are available only in 7 Series and Zynq XADC. All the remaining Alarm Threshold registers specified by the constants XSM_ATR_*, are available in all the families of the Sysmon. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3af3c52fe39c41739b9fe95657e23ed"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetAvg" ref="ab3af3c52fe39c41739b9fe95657e23ed" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMon_GetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the number of samples of averaging configured for all the channels in the Configuration Register 0.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The averaging read from the Configuration Register 0 is returned. Use the XSM_AVG_* bit definitions defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a> file to interpret the returned value :<ul>
<li>XSM_AVG_0_SAMPLES means no averaging</li>
<li>XSM_AVG_16_SAMPLES means 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES means 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES means 256 samples of averaging</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3e66317b9e918f0aeb5ca8bdc204c31"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetCalibCoefficient" ref="ae3e66317b9e918f0aeb5ca8bdc204c31" args="(XSysMon *InstancePtr, u8 CoeffType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMon_GetCalibCoefficient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>CoeffType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the calibration coefficient data for the specified parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CoeffType</em>&nbsp;</td><td>specifies the calibration coefficient to be read. Use XSM_CALIB_* constants defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a> to specify the calibration coefficient to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit value representing the calibration coefficient. The System Monitor/ADC device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of the 16 data read from the device.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1997b528dc71315f9ac87b7b3985967d"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetCalibEnables" ref="a1997b528dc71315f9ac87b7b3985967d" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMon_GetCalibEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the value of the calibration enables from the Configuration Register 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the calibration enables in the Configuration Register 1 :<ul>
<li>XSM_CFR1_CAL_ADC_OFFSET_MASK : ADC offset correction</li>
<li>XSM_CFR1_CAL_ADC_GAIN_OFFSET_MASK : ADC gain and offset correction</li>
<li>XSM_CFR1_CAL_PS_OFFSET_MASK : Power Supply sensor offset correction</li>
<li>XSM_CFR1_CAL_PS_GAIN_OFFSET_MASK : Power Supply sensor gain and offset correction</li>
<li>XSM_CFR1_CAL_DISABLE_MASK : No Calibration</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a15022394c1ba90705c3227f6cfa0f892"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetMinMaxMeasurement" ref="a15022394c1ba90705c3227f6cfa0f892" args="(XSysMon *InstancePtr, u8 MeasurementType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMon_GetMinMaxMeasurement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>MeasurementType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the Minimum/Maximum measurement for one of the following parameters :</p>
<ul>
<li>Minimum Temperature (XSM_MIN_TEMP) - All families</li>
<li>Minimum VCCINT (XSM_MIN_VCCINT) - All families</li>
<li>Minimum VCCAUX (XSM_MIN_VCCAUX) - All families</li>
<li>Maximum Temperature (XSM_MAX_TEMP) - All families</li>
<li>Maximum VCCINT (XSM_MAX_VCCINT) - All families</li>
<li>Maximum VCCAUX (XSM_MAX_VCCAUX) - All families</li>
<li>Maximum VCCBRAM (XSM_MAX_VCCBRAM) - 7 series and Zynq only</li>
<li>Minimum VCCBRAM (XSM_MIN_VCCBRAM) - 7 series and Zynq only</li>
<li>Maximum VCCPINT (XSM_MAX_VCCPINT) - Zynq only</li>
<li>Maximum VCCPAUX (XSM_MAX_VCCPAUX) - Zynq only</li>
<li>Maximum VCCPDRO (XSM_MAX_VCCPDRO) - Zynq only</li>
<li>Minimum VCCPINT (XSM_MIN_VCCPINT) - Zynq only</li>
<li>Minimum VCCPAUX (XSM_MIN_VCCPAUX) - Zynq only</li>
<li>Minimum VCCPDRO (XSM_MIN_VCCPDRO) - Zynq only</li>
<li>Maximum VUSER0 (XSM_MAX_VUSR0) - Ultrascale</li>
<li>Maximum VUSER1 (XSM_MAX_VUSR1) - Ultrascale</li>
<li>Maximum VUSER2 (XSM_MAX_VUSR2) - Ultrascale</li>
<li>Maximum VUSER3 (XSM_MAX_VUSR3) - Ultrascale</li>
<li>Minimum VUSER0 (XSM_MIN_VUSR0) - Ultrascale</li>
<li>Minimum VUSER1 (XSM_MIN_VUSR1) - Ultrascale</li>
<li>Minimum VUSER2 (XSM_MIN_VUSR2) - Ultrascale</li>
<li>Minimum VUSER3 (XSM_MIN_VUSR3) - Ultrascale</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MeasurementType</em>&nbsp;</td><td>specifies the parameter for which the Minimum/Maximum measurement has to be read. Use XSM_MAX_* and XSM_MIN_* constants defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a> to specify the data to be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 16-bit value representing the maximum/minimum measurement for specified parameter. The System Monitor/ADC device guarantees a 10 bit resolution for the ADC converted data and data is the 10 MSB bits of 16 bit data read from the device. </dd></dl>

</div>
</div>
<a class="anchor" id="a40de55fb20bf40a5cc9c12fe9ee844bd"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetOverTemp" ref="a40de55fb20bf40a5cc9c12fe9ee844bd" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u16 XSysMon_GetOverTemp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the powerdown temperature of the OverTemp signal in the OT Powerdown register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 12-bit OT Upper Alarm Register powerdown value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API has been deprecated. Use <a class="el" href="xsysmon_8c.html#adacbf7c393aa18cacfc08e267db5e87b">XSysMon_GetAlarmThreshold()</a>, instead. This API should be used only with V6/7 Series since the upper threshold of OverTemp is programmable in only V6 SysMon/7 Series and Zynq XADC. </dd></dl>

</div>
</div>
<a class="anchor" id="abbe503899860c22ba1ee72db5171ba34"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetSeqAcqTime" ref="abbe503899860c22ba1ee72db5171ba34" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_GetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the status of acquisition from the ADC Channel Acquisition Time Sequencer Registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The acquisition time for all the channels. Use XSM_SEQ_CH__* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which acquisition cycles are extended and bit mask of 0 are the channels for which acquisition cycles are not extended.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a31c725e3171a80ca4d90eebcee5577"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetSeqAvgEnables" ref="a5a31c725e3171a80ca4d90eebcee5577" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMon_GetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the channels for which the averaging has been enabled in the ADC Channel Averaging Enables Sequencer Registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The status of averaging (enabled/disabled) for all the channels. Use XSM_SEQ_CH__* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which averaging is enabled and bit mask of 0 are the channels for averaging is disabled.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9aa35ccde843ef5b7182d171d3b4324"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetSeqChEnables" ref="ad9aa35ccde843ef5b7182d171d3b4324" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u64 XSysMon_GetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the channel enable bits status from the ADC Channel Selection Sequencer Registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Gets the channel enable bits. Use XSM_SEQ_CH_* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels that are enabled and bit mask of 0 are the channels that are disabled.</dd>
<dd>
None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a45d42e268bdaba00cdbd121894aac96f"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetSeqInputMode" ref="a45d42e268bdaba00cdbd121894aac96f" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_GetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the Analog input mode for all the channels from the ADC Channel Analog-Input Mode Sequencer Registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The input mode for all the channels. Use XSM_SEQ_CH_* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the Channel numbers. Bit masks of 1 are the channels for which input mode is differential and bit mask of 0 are the channels for which input mode is unipolar.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a046913c88b8e3b794d21a14b8ed5219c"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetSequencerMode" ref="a046913c88b8e3b794d21a14b8ed5219c" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XSysMon_GetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function gets the channel sequencer mode from the Configuration Register 1.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The channel sequencer mode :<ul>
<li>XSM_SEQ_MODE_SAFE : Default safe mode</li>
<li>XSM_SEQ_MODE_ONEPASS : One pass through sequence</li>
<li>XSM_SEQ_MODE_CONTINPASS : Continuous channel sequencing</li>
<li>XSM_SEQ_MODE_SINGCHAN : Single channel/Sequencer off</li>
<li>XSM_SEQ_MODE_SIMUL : Simulataneous sampling mode</li>
<li>XSM_SEQ_MODE_INDEPENDENT : Independent mode</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a34d731dace546db3397741f0d229cb3b"></a><!-- doxytag: member="xsysmon.h::XSysMon_GetStatus" ref="a34d731dace546db3397741f0d229cb3b" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The functions reads the contents of the Status Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the Status Register. Use the XSM_SR_*_MASK constants defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the returned value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b30e66ba4301e6cb02d1cc6a478a2b"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrClear" ref="a27b30e66ba4301e6cb02d1cc6a478a2b" args="(XSysMon *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_IntrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears the specified interrupts in the Interrupt Status Register (IPISR).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be cleared. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status. This mask is formed by OR'ing XSM_IPIXR_* bits which are defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f1afce92df09c2b023605eb510fcc61"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrDisable" ref="a2f1afce92df09c2b023605eb510fcc61" args="(XSysMon *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the specified interrupts in the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be disabled. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSM_IPIXR_* bits defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a42618007571bfd0d5f51dfcc66de0c12"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrEnable" ref="a42618007571bfd0d5f51dfcc66de0c12" args="(XSysMon *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified interrupts in the device. Interrupts enabled using this function will not occur until the global interrupt enable bit is set by using the <a class="el" href="xsysmon_8h.html#a10375fa7b5de21898a2184fa934d04ca">XSysMon_IntrGlobalEnable()</a>function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the bit-mask of the interrupts to be enabled. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XSM_IPIXR_* bits defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a1b3e61dde34a23c6c906ddde3aabcce3"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrGetEnabled" ref="a1b3e61dde34a23c6c906ddde3aabcce3" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the enabled interrupts read from the Interrupt Enable Register (IPIER). Use the XSM_IPIXR_* constants defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the IPIER.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a49bbe691a17f0d77753754fb18cfadb4"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrGetStatus" ref="a49bbe691a17f0d77753754fb18cfadb4" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XSysMon_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns the interrupt status read from Interrupt Status Register(IPISR). Use the XSM_IPIXR_* constants defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A 32-bit value representing the contents of the IPISR.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a025ee112aa4af95e592b05ce99b07497"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrGlobalDisable" ref="a025ee112aa4af95e592b05ce99b07497" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_IntrGlobalDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function disables the global interrupt in the Global Interrupt Enable Register (GIER) so that the interrupt output from the System Monitor/ADC device is disabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a10375fa7b5de21898a2184fa934d04ca"></a><!-- doxytag: member="xsysmon.h::XSysMon_IntrGlobalEnable" ref="a10375fa7b5de21898a2184fa934d04ca" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_IntrGlobalEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functions in <a class="el" href="xsysmon__intr_8c.html">xsysmon_intr.c</a></p>
<p>This function enables the global interrupt in the Global Interrupt Enable Register (GIER) so that the interrupt output from the System Monitor/ADC device is enabled. Interrupts enabled using <a class="el" href="xsysmon_8h.html#a42618007571bfd0d5f51dfcc66de0c12">XSysMon_IntrEnable()</a> will not occur until the global interrupt enable bit is set by using this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The device must be configured at hardware build time to include interrupt component for this function to work. </dd></dl>

</div>
</div>
<a class="anchor" id="a02fbbb117ca8d4002ff222dcf2e4892d"></a><!-- doxytag: member="xsysmon.h::XSysMon_LookupConfig" ref="a02fbbb117ca8d4002ff222dcf2e4892d" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_sys_mon___config.html">XSysMon_Config</a>* XSysMon_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functions in <a class="el" href="xsysmon__sinit_8c.html">xsysmon_sinit.c</a></p>
<p>This function looks up the device configuration based on the unique device ID. The table XSysMon_ConfigTable contains the configuration info for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>contains the ID of the device for which the device configuration pointer is to be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>A pointer to the configuration found.</li>
<li>NULL if the specified device ID was not found.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f77755a291cf2bac28ff12a5cdd5d8a"></a><!-- doxytag: member="xsysmon.h::XSysMon_Reset" ref="a7f77755a291cf2bac28ff12a5cdd5d8a" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function forces the software reset of the complete SystemMonitor/ADC Hard Macro and the SYSMON ADC Core Logic.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The Control registers in the SystemMonitor/ADC Hard Macro are not affected by this reset, only the Status registers are reset. Refer to the device data sheet for the device status and register values after the reset. Use the <a class="el" href="xsysmon_8c.html#a9efcdd44a813be1e9b0e33b64c616cb3">XSysMon_ResetAdc()</a> to reset only the SystemMonitor/ADC Hard Macro. </dd></dl>

</div>
</div>
<a class="anchor" id="a9efcdd44a813be1e9b0e33b64c616cb3"></a><!-- doxytag: member="xsysmon.h::XSysMon_ResetAdc" ref="a9efcdd44a813be1e9b0e33b64c616cb3" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_ResetAdc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the SystemMonitor/ADC Hard Macro in the device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The Control registers in the SystemMonitor/ADC Hard Macro are not affected by this reset, only the Status registers are reset. This reset causes the ADC to begin with a new conversion. Refer to the device data sheet for the device status and register values after the reset. Use the <a class="el" href="xsysmon_8c.html#a7f77755a291cf2bac28ff12a5cdd5d8a">XSysMon_Reset()</a> API to reset both the SystemMonitor/ADC Hard Macro and the SYSMON ADC Core Logic. </dd></dl>

</div>
</div>
<a class="anchor" id="a23b6bce798cabbee7cb637d36edd54da"></a><!-- doxytag: member="xsysmon.h::XSysMon_SelfTest" ref="a23b6bce798cabbee7cb637d36edd54da" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Functions in <a class="el" href="xsysmon__selftest_8c.html">xsysmon_selftest.c</a></p>
<p>Run a self-test on the driver/device. The test</p>
<ul>
<li>Resets the device,</li>
<li>Writes a value into the Alarm Threshold register and reads it back for comparison.</li>
<li>Resets the device again.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the value read from the Alarm Threshold register is the same as the value written.</li>
<li>XST_FAILURE Otherwise</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a destructive test in that resets of the device are performed. Refer to the device specification for the device status after the reset operation. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c119682ea951295d41462e329da881a"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetAdcClkDivisor" ref="a3c119682ea951295d41462e329da881a" args="(XSysMon *InstancePtr, u8 Divisor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetAdcClkDivisor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Divisor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the frequency of the ADCCLK by configuring the DCLK to ADCCLK ratio in the Configuration Register #2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is clock divisor used to derive ADCCLK from DCLK. Valid values of the divisor are</p>
<ul>
<li>8 to 255 for V5 SysMon.</li>
<li>0 to 255 for V6/7 Series and Zynq XADC. Values 0, 1, 2 are all mapped to 2. Refer to the device specification for more details.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>- The ADCCLK is an internal clock used by the ADC and is synchronized to the DCLK clock. The ADCCLK is equal to DCLK divided by the user selection in the Configuration Register 2.<ul>
<li>There is no Assert on the minimum value of the Divisor. Users must take care such that the minimum value of Divisor used is 8, in case of V5 SysMon. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a458e2807135bef154d249e80b145520a"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetAlarmEnables" ref="a458e2807135bef154d249e80b145520a" args="(XSysMon *InstancePtr, u32 AlmEnableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetAlarmEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>AlmEnableMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the alarm outputs for the specified alarms in the Configuration Registers 1 and 3:</p>
<ul>
<li>OT for Over Temperature (XSM_CFR_OT_MASK)</li>
<li>ALM0 for On board Temperature (XSM_CFR_ALM_TEMP_MASK)</li>
<li>ALM1 for VCCINT (XSM_CFR_ALM_VCCINT_MASK)</li>
<li>ALM2 for VCCAUX (XSM_CFR_ALM_VCCAUX_MASK)</li>
<li>ALM3 for VBRAM (XSM_CFR_ALM_VBRAM_MASK)for 7 Series and Zynq</li>
<li>ALM4 for VCCPINT (XSM_CFR_ALM_VCCPINT_MASK) for Zynq</li>
<li>ALM5 for VCCPAUX (XSM_CFR_ALM_VCCPAUX_MASK) for Zynq</li>
<li>ALM6 for VCCPDRO (XSM_CFR_ALM_VCCPDRO_MASK) for Zynq</li>
<li>ALM8 for VUSER0 (XSM_CFR_ALM_VUSR0_MASK) for Ultrascale</li>
<li>ALM9 for VUSER1 (XSM_CFR_ALM_VUSR1_MASK) for Ultrascale</li>
<li>ALM10 for VUSER2 (XSM_CFR_ALM_VUSR2_MASK) for Ultrascale</li>
<li>ALM11 for VUSER3 (XSM_CFR_ALM_VUSR3_MASK) for Ultrascale</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AlmEnableMask</em>&nbsp;</td><td>is the bit-mask of the alarm outputs to be enabled in the Configuration Register 1. Bit positions of 1 will be enabled. Bit positions of 0 will be disabled. This mask is formed by OR'ing XSM_CFR_ALM_*_MASK, XSM_CFR_ALM_*_MASK and XSM_CFR_OT_MASK masks defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The implementation of the alarm enables in the Configuration register 1 is such that the alarms for bit positions of 1 will be disabled and alarms for bit positions of 0 will be enabled. The alarm outputs specified by the AlmEnableMask are negated before writing to the Configuration Register 1. </dd></dl>

</div>
</div>
<a class="anchor" id="af9d2de8d4141ae1e7e073ea296df739d"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetAlarmThreshold" ref="af9d2de8d4141ae1e7e073ea296df739d" args="(XSysMon *InstancePtr, u8 AlarmThrReg, u16 Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetAlarmThreshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>AlarmThrReg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This functions sets the contents of the given Alarm Threshold Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AlarmThrReg</em>&nbsp;</td><td>is the index of an Alarm Threshold Register to be set. Use XSM_ATR_* constants defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a> to specify the index. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is the 16-bit threshold value to write into the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Over Temperature upper threshold is programmable only in V6, 7 Series/Zynq XADC and UltraScale. BRAM high and low voltage threshold registers are available only in 7 Series XADC and UltraScale. VUSER0 to VUSER3 threshold registers are available only in UltraScale. All the remaining Alarm Threshold registers specified by the constants XSM_ATR_*, are available in all the families of the Sysmon. </dd></dl>

</div>
</div>
<a class="anchor" id="af3504732dccf017f38fa7ffd7483f358"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetAvg" ref="af3504732dccf017f38fa7ffd7483f358" args="(XSysMon *InstancePtr, u8 Average)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetAvg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Average</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the number of samples of averaging that is to be done for all the channels in both the single channel mode and sequence mode of operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Average</em>&nbsp;</td><td>is the number of samples of averaging programmed to the Configuration Register 0. Use the XSM_AVG_* definitions defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a> file :</p>
<ul>
<li>XSM_AVG_0_SAMPLES for no averaging</li>
<li>XSM_AVG_16_SAMPLES for 16 samples of averaging</li>
<li>XSM_AVG_64_SAMPLES for 64 samples of averaging</li>
<li>XSM_AVG_256_SAMPLES for 256 samples of averaging</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a94f9f1484443b0855b724b44e97f998c"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetCalibEnables" ref="a94f9f1484443b0855b724b44e97f998c" args="(XSysMon *InstancePtr, u16 Calibration)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetCalibEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Calibration</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified calibration in the Configuration Register 1 :</p>
<ul>
<li>XSM_CFR1_CAL_ADC_OFFSET_MASK : Calibration 0 -ADC offset correction</li>
<li>XSM_CFR1_CAL_ADC_GAIN_OFFSET_MASK : Calibration 1 -ADC gain and offset correction</li>
<li>XSM_CFR1_CAL_PS_OFFSET_MASK : Calibration 2 -Power Supply sensor offset correction</li>
<li>XSM_CFR1_CAL_PS_GAIN_OFFSET_MASK : Calibration 3 -Power Supply sensor gain and offset correction</li>
<li>XSM_CFR1_CAL_DISABLE_MASK : No Calibration</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Calibration</em>&nbsp;</td><td>is the Calibration to be applied. Use XSM_CFR1_CAL*_* bits defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a>. Multiple calibrations can be enabled at a time by oring the XSM_CFR1_CAL_ADC_* and XSM_CFR1_CAL_PS_* bits. Calibration can be disabled by specifying XSM_CFR1_CAL_DISABLE_MASK;</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aa5e941d4d6d614920634a8ff1925cbfd"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetExtenalMux" ref="aa5e941d4d6d614920634a8ff1925cbfd" args="(XSysMon *InstancePtr, u8 Channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetExtenalMux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Channel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function enables the external mux and connects a channel to the mux.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>is the channel number used to connect to the external Mux. The valid channels are 0 to 6, 8, and 16 to 31.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The External Mux is only available in 7 Series and Zynq XADC. This API should be used only with 7 Series and Zynq XADC. </dd></dl>

</div>
</div>
<a class="anchor" id="a433f79238dd1c1cdd6e1b1cfb9c0e7a1"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetOverTemp" ref="a433f79238dd1c1cdd6e1b1cfb9c0e7a1" args="(XSysMon *InstancePtr, u16 Value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetOverTemp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>Value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the powerdown temperature for the OverTemp signal in the OT Powerdown register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Value</em>&nbsp;</td><td>is the 16-bit OT Upper Alarm Register powerdown value. Valid values are 0 to 0x0FFF.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API has been deprecated. Use <a class="el" href="xsysmon_8c.html#af9d2de8d4141ae1e7e073ea296df739d">XSysMon_SetAlarmThreshold()</a>, instead. This API should be used only with V6/7 Series since the upper threshold of OverTemp is programmable in in only V6 SysMon/7 Series and Zynq XADC. </dd></dl>

</div>
</div>
<a class="anchor" id="aeafd06e40eff4807b362edf043d725e8"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSeqAcqTime" ref="aeafd06e40eff4807b362edf043d725e8" args="(XSysMon *InstancePtr, u32 AcqCyclesChMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_SetSeqAcqTime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>AcqCyclesChMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the number of Acquisition cycles in the ADC Channel Acquisition Time Sequencer Registers. The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AcqCyclesChMask</em>&nbsp;</td><td>is the bit mask of all the channels for which the number of acquisition cycles is to be extended. Use XSM_SEQ_CH__* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to specify the Channel numbers. Acquisition cycles will be extended to 10 ADCCLK cycles for bit masks of 1 and will be the default 4 ADCCLK cycles for bit masks of 0. The AcqCyclesChMask is a 32 bit mask that is written to the two 16 bit ADC Channel Acquisition Time Sequencer Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Channel Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7072bfa213b7318fcc29408a459c0bb"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSeqAvgEnables" ref="ae7072bfa213b7318fcc29408a459c0bb" args="(XSysMon *InstancePtr, u64 AvgEnableChMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_SetSeqAvgEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&nbsp;</td>
          <td class="paramname"> <em>AvgEnableChMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the averaging for the specified channels in the ADC Channel Averaging Enable Sequencer Registers. The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AvgEnableChMask</em>&nbsp;</td><td>is the bit mask of all the channels for which averaging is to be enabled. Use XSM_SEQ_CH__* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to specify the Channel numbers. Averaging will be enabled for bit masks of 1 and disabled for bit mask of 0. The AvgEnableChMask is a 64 bit mask that is written to the three 16 bit ADC Channel Averaging Enable Sequencer Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Averaging Enables Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a60d92b3a70aab326364319b3d1f1a7cc"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSeqChEnables" ref="a60d92b3a70aab326364319b3d1f1a7cc" args="(XSysMon *InstancePtr, u64 ChEnableMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_SetSeqChEnables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u64&nbsp;</td>
          <td class="paramname"> <em>ChEnableMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function enables the specified channels in the ADC Channel Selection Sequencer Registers. The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ChEnableMask</em>&nbsp;</td><td>is the bit mask of all the channels to be enabled. Use XSM_SEQ_CH_* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to specify the Channel numbers. Bit masks of 1 will be enabled and bit mask of 0 will be disabled. The ChEnableMask is a 64 bit mask that is written to the three 16 bit ADC Channel Selection Sequencer Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Selection Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d3d8052fae049f4ca772b5956ced31f"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSeqInputMode" ref="a3d3d8052fae049f4ca772b5956ced31f" args="(XSysMon *InstancePtr, u32 InputModeChMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_SetSeqInputMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>InputModeChMask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the Analog input mode for the specified channels in the ADC Channel Analog-Input Mode Sequencer Registers. The sequencer must be in the Safe Mode before writing to these registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InputModeChMask</em>&nbsp;</td><td>is the bit mask of all the channels for which the input mode is differential mode. Use XSM_SEQ_CH__* defined in <a class="el" href="xsysmon__hw_8h.html">xsysmon_hw.h</a> to specify the channel numbers. Differential input mode will be set for bit masks of 1 and unipolar input mode for bit masks of 0. The InputModeChMask is a 32 bit mask that is written to the two 16 bit ADC Channel Analog-Input Mode Sequencer Registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the ADC Channel Analog-Input Mode Sequencer Registers.</li>
<li>XST_FAILURE if the channel sequencer is enabled.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a415023d979e637bac035cf6f902ab256"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSequencerEvent" ref="a415023d979e637bac035cf6f902ab256" args="(XSysMon *InstancePtr, int IsEventMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetSequencerEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>IsEventMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function enables the Event mode or Continuous mode in the sequencer mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsEventMode</em>&nbsp;</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the given channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The Event mode is only available in 7 Series XADC and Zynq. This API should be used only with 7 Series XADC and Zynq . </dd></dl>

</div>
</div>
<a class="anchor" id="a433e353cd5a25454ce2a6da51494e478"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSequencerMode" ref="a433e353cd5a25454ce2a6da51494e478" args="(XSysMon *InstancePtr, u8 SequencerMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetSequencerMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>SequencerMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the specified Channel Sequencer Mode in the Configuration Register 1 :</p>
<ul>
<li>Default safe mode (XSM_SEQ_MODE_SAFE)</li>
<li>One pass through sequence (XSM_SEQ_MODE_ONEPASS)</li>
<li>Continuous channel sequencing (XSM_SEQ_MODE_CONTINPASS)</li>
<li>Single Channel/Sequencer off (XSM_SEQ_MODE_SINGCHAN)</li>
<li>Simulataneous sampling mode (XSM_SEQ_MODE_SIMUL)</li>
<li>Independent mode (XSM_SEQ_MODE_INDEPENDENT)</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SequencerMode</em>&nbsp;</td><td>is the sequencer mode to be set. Use XSM_SEQ_MODE_* bits defined in <a class="el" href="xsysmon_8h.html">xsysmon.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Only one of the modes can be enabled at a time. </dd></dl>

</div>
</div>
<a class="anchor" id="a44e6fba16cf4b8cc69301523ed8344ce"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetSingleChParams" ref="a44e6fba16cf4b8cc69301523ed8344ce" args="(XSysMon *InstancePtr, u8 Channel, int IncreaseAcqCycles, int IsEventMode, int IsDifferentialMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XSysMon_SetSingleChParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Channel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>IncreaseAcqCycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>IsEventMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>IsDifferentialMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The function sets the given parameters in the Configuration Register 0 in the single channel mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Channel</em>&nbsp;</td><td>is the channel number for conversion. The valid channels are 0 to 5, 8, and 16 to 31. Channel 6 is valid for 7 series and Zynq XADC. Channel 32 to 35 are valid for Ultrascale. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IncreaseAcqCycles</em>&nbsp;</td><td>is a boolean parameter which specifies whether the Acquisition time for the external channels has to be increased to 10 ADCCLK cycles (specify TRUE) or remain at the default 4 ADCCLK cycles (specify FALSE). This parameter is only valid for the external channels. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsEventMode</em>&nbsp;</td><td>is a boolean parameter that specifies continuous sampling (specify FALSE) or event driven sampling mode (specify TRUE) for the given channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsDifferentialMode</em>&nbsp;</td><td>is a boolean parameter which specifies unipolar(specify FALSE) or differential mode (specify TRUE) for the analog inputs. The input mode is only valid for the external channels. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the given values were written successfully to the Configuration Register 0.</li>
<li>XST_FAILURE if the channel sequencer is enabled or the input parameters are not valid for the selected channel.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd><ul>
<li>The number of samples for the averaging for all the channels is set by using the function XSysMon_SetAvg.</li>
<li>The calibration of the device is done by doing a ADC conversion on the calibration channel(channel 8). The input parameters IncreaseAcqCycles, IsDifferentialMode and IsEventMode are not valid for this channel. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae3c96e6cb365a22d5aff07acaedb2101"></a><!-- doxytag: member="xsysmon.h::XSysMon_SetTempWaitCycles" ref="ae3c96e6cb365a22d5aff07acaedb2101" args="(XSysMon *InstancePtr, u16 WaitCycles)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_SetTempWaitCycles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>WaitCycles</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets the number of Wait Cycles for Temperature updation logic</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The default number of wait cycles are 1000(0x3E8). </dd></dl>

</div>
</div>
<a class="anchor" id="ad9997219e88de3f17da39970d52014fe"></a><!-- doxytag: member="xsysmon.h::XSysMon_StartAdcConversion" ref="ad9997219e88de3f17da39970d52014fe" args="(XSysMon *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XSysMon_StartAdcConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_sys_mon.html">XSysMon</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function starts the ADC conversion in the Single Channel event driven sampling mode. The EOC bit in Status Register will be set once the conversion is finished. Refer to the device specification for more details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_sys_mon.html">XSysMon</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The default state of the CONVST bit is a logic 0. The conversion is started when the CONVST bit is set to 1 from 0. This bit is cleared in this function so that the next conversion can be started by setting this bit. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
