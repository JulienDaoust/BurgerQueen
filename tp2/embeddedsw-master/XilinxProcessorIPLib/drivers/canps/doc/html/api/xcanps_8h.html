<html>
<head>
   <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
   Xilinx Driver canps v2_1: xcanps.h File Reference
</title>
<link href="doxygen_kalyanidocs/doc/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>xcanps.h File Reference</h1><code>#include &quot;xstatus.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a>&quot;</code><br/>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_can_ps___config.html">XCanPs_Config</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_can_ps.html">XCanPs</a></td></tr>
<tr><td colspan="2"><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a71176de5a3984478078d46c61727518b">XCANPS_H</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a97803151fa85361cf6f486bc1d278f08">XCanPs_IsTxDone</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a24933e3b4780683d895a385e7d1b50d7">XCanPs_IsTxFifoFull</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a8dc513dd3633b55910d20150ca42bc12">XCanPs_IsHighPriorityBufFull</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a50a4bad5973f5a8819541969a226eeff">XCanPs_IsRxEmpty</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#aecacd08d0192291be2907ddad81602c5">XCanPs_IsAcceptFilterBusy</a>(InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ada077a3bb7d30a6bca23529ee48ceb42">XCanPs_CreateIdValue</a>(StandardId, SubRemoteTransReq, IdExtension, ExtendedId, RemoteTransReq)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a8c9bf6d887f01a9726ef73fa9c3da816">XCanPs_CreateDlcValue</a>(DataLengCode)&nbsp;&nbsp;&nbsp;(((DataLengCode) &lt;&lt; XCANPS_DLCR_DLC_SHIFT) &amp; XCANPS_DLCR_DLC_MASK)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a7ab3760eb2d37d0385cf930fd1cba230">XCanPs_ClearTimestamp</a>(InstancePtr)</td></tr>
<tr><td colspan="2"><div class="groupHeader">CAN operation modes</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp760e965317160106d81dfdf2ffff90ef"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a4e4f2c00506467b58276539cc1c2333e">XCANPS_MODE_CONFIG</a>&nbsp;&nbsp;&nbsp;0x00000001</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#abfbce28099a84db3fb8199371fea2053">XCANPS_MODE_NORMAL</a>&nbsp;&nbsp;&nbsp;0x00000002</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a815748d9ef7547d7fd43f2b729c3108c">XCANPS_MODE_LOOPBACK</a>&nbsp;&nbsp;&nbsp;0x00000004</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#adedb96174b3c7af5c8b82003f3a269fe">XCANPS_MODE_SLEEP</a>&nbsp;&nbsp;&nbsp;0x00000008</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a6f5226ac1abe6816a8a807a1734aa1d2">XCANPS_MODE_SNOOP</a>&nbsp;&nbsp;&nbsp;0x00000010</td></tr>
<tr><td colspan="2"><div class="groupHeader">Callback identifiers used as parameters to XCanPs_SetHandler()</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp1b5f0bdd1d9eedb9173f0554777f5239"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#afed3df99b6f79d0ff7c39a6a03ec6c90">XCANPS_HANDLER_SEND</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a6393e21002da8517ac35ae9c1be58681">XCANPS_HANDLER_RECV</a>&nbsp;&nbsp;&nbsp;2</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a60962a646bcd90fd768f78ff34f17ba5">XCANPS_HANDLER_ERROR</a>&nbsp;&nbsp;&nbsp;3</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ad64733c5ddd21a972fc93a8d43f52d74">XCANPS_HANDLER_EVENT</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a8a0277ac1de7be22b9de36ef55da1c8d">XCanPs_SendRecvHandler</a> )(void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a72002ff7916781152d893abbe71d83a8">XCanPs_ErrorHandler</a> )(void *CallBackRef, u32 ErrorMask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ad81f0a8035bff610185b30bec4e012ea">XCanPs_EventHandler</a> )(void *CallBackRef, u32 Mask)</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a366349f6ab06338bec32ba61263612ed">XCanPs_CfgInitialize</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, <a class="el" href="struct_x_can_ps___config.html">XCanPs_Config</a> *ConfigPtr, u32 EffectiveAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a13dce9f4dede25f041852b1c893ebfba">XCanPs_Reset</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a3644ad3aa2b02def735751ed45d207a4">XCanPs_GetMode</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a5a32b11e15d347ecae566778bb1c5e33">XCanPs_EnterMode</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u8 OperationMode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a6d87194a88956cbe32f48ea3d25697ef">XCanPs_GetStatus</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#aecf35feac1fbc0df4029ca4e1150c650">XCanPs_GetBusErrorCounter</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u8 *RxErrorCount, u8 *TxErrorCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a647e39edd3f7247a5e283e9083d8d285">XCanPs_GetBusErrorStatus</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a616ac01563ef3d8f9ae57bf308bad534">XCanPs_ClearBusErrorStatus</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a4586901ededc2d25ccf6e931a492e129">XCanPs_Send</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 *FramePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a806105ce9bacbf450b3d2bcb4b0af4fb">XCanPs_Recv</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 *FramePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ab621053a5cb10c664b4994f231b33596">XCanPs_SendHighPriority</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 *FramePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a1ec6f79564deff77e496120552004ad8">XCanPs_AcceptFilterEnable</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 FilterIndexes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a1cffdc22b01e4b4d3aad5e556bf96d20">XCanPs_AcceptFilterDisable</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 FilterIndexes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a52a76621e921b66e70e1bed7a58b72f7">XCanPs_AcceptFilterGetEnabled</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a2b2ca95fd3ac7ff0955e61cc2b681b4f">XCanPs_AcceptFilterSet</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 FilterIndex, u32 MaskValue, u32 IdValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#af2ac50558c7d926fed54329667d4aaca">XCanPs_AcceptFilterGet</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 FilterIndex, u32 *MaskValue, u32 *IdValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a4036939c0c1112d137aaae9e5181c22c">XCanPs_SetBaudRatePrescaler</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u8 Prescaler)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ae452283471584ad19f0c854a782640ab">XCanPs_GetBaudRatePrescaler</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a8829d144510518e4f8e7f9e65fe37ad3">XCanPs_SetBitTiming</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u8 SyncJumpWidth, u8 TimeSegment2, u8 TimeSegment1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#aecaff4cbadbea1a01f570a7e6917a027">XCanPs_GetBitTiming</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u8 *SyncJumpWidth, u8 *TimeSegment2, u8 *TimeSegment1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a3c8048df67199eafe40346c33babf236">XCanPs_SetRxIntrWatermark</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u8 Threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#adc59b9185cd5973cb03ea2bae94b70cb">XCanPs_GetRxIntrWatermark</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a7b41aa40bddd212d039bd7e5171f0cf3">XCanPs_SelfTest</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a06e4eda1022a81ea619ac7d66e345577">XCanPs_IntrEnable</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#a6228ea25a1ccf31608231b07f3ae54a7">XCanPs_IntrDisable</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ac3325adebecffcb97cb01ff3c75391b0">XCanPs_IntrGetEnabled</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ac6640f1ea5f9e4027d67af3b4eec4623">XCanPs_IntrGetStatus</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ae573e5472755420a3b6ded5d01814534">XCanPs_IntrClear</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 Mask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#ad7c797dfe9aef613d20c2a822ed301dc">XCanPs_IntrHandler</a> (void *InstancePtr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#aeb1da97683c78ca3efd6690a0a2b3060">XCanPs_SetHandler</a> (<a class="el" href="struct_x_can_ps.html">XCanPs</a> *InstancePtr, u32 HandlerType, void *CallBackFunc, void *CallBackRef)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_x_can_ps___config.html">XCanPs_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xcanps_8h.html#aaccd26e8072c612cd44a0b6645813581">XCanPs_LookupConfig</a> (u16 DeviceId)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a7ab3760eb2d37d0385cf930fd1cba230"></a><!-- doxytag: member="xcanps.h::XCanPs_ClearTimestamp" ref="a7ab3760eb2d37d0385cf930fd1cba230" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_ClearTimestamp</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="xcanps__hw_8h.html#a54552fe78115d81806e23a03646efb55">XCanPs_WriteReg</a>((InstancePtr)-&gt;CanConfig.BaseAddr,              \
                                <a class="code" href="xcanps__hw_8h.html#a9548e23d85404e5d7c99dba105d0ace0">XCANPS_TCR_OFFSET</a>, <a class="code" href="xcanps__hw_8h.html#a73ebdb9f11b9c769acc0d2cdc085fdc7">XCANPS_TCR_CTS_MASK</a>)
</pre></div><p>This macro clears the timestamp in the Timestamp Control Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: void <a class="el" href="xcanps_8h.html#a7ab3760eb2d37d0385cf930fd1cba230">XCanPs_ClearTimestamp(XCanPs *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a8c9bf6d887f01a9726ef73fa9c3da816"></a><!-- doxytag: member="xcanps.h::XCanPs_CreateDlcValue" ref="a8c9bf6d887f01a9726ef73fa9c3da816" args="(DataLengCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_CreateDlcValue</td>
          <td>(</td>
          <td class="paramtype">DataLengCode&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;(((DataLengCode) &lt;&lt; XCANPS_DLCR_DLC_SHIFT) &amp; XCANPS_DLCR_DLC_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This macro calculates value for Data Length Code register given Data Length Code value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DataLengCode</em>&nbsp;</td><td>indicates Data Length Code value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value that can be assigned to Data Length Code register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 <a class="el" href="xcanps_8h.html#a8c9bf6d887f01a9726ef73fa9c3da816">XCanPs_CreateDlcValue(u32 DataLengCode)</a>;</dd></dl>
<p>Read the CAN specification for meaning of Data Length Code. </p>

</div>
</div>
<a class="anchor" id="ada077a3bb7d30a6bca23529ee48ceb42"></a><!-- doxytag: member="xcanps.h::XCanPs_CreateIdValue" ref="ada077a3bb7d30a6bca23529ee48ceb42" args="(StandardId, SubRemoteTransReq, IdExtension, ExtendedId, RemoteTransReq)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_CreateIdValue</td>
          <td>(</td>
          <td class="paramtype">StandardId, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubRemoteTransReq, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IdExtension, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExtendedId, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RemoteTransReq&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((((StandardId) &lt;&lt; <a class="code" href="xcanps__hw_8h.html#a4941ee8f7d5736d356d6ab633a0ddcbb">XCANPS_IDR_ID1_SHIFT</a>) &amp; <a class="code" href="xcanps__hw_8h.html#a03c570854310ffd7198a240aa3e5b450">XCANPS_IDR_ID1_MASK</a>) |       \
 (((SubRemoteTransReq) &lt;&lt; <a class="code" href="xcanps__hw_8h.html#ab747ed0dcfb5a078a77c4b192bbb05fb">XCANPS_IDR_SRR_SHIFT</a>) &amp; <a class="code" href="xcanps__hw_8h.html#ad77824652aaf9b68e9031e4c1ab52e08">XCANPS_IDR_SRR_MASK</a>)|\
 (((IdExtension) &lt;&lt; <a class="code" href="xcanps__hw_8h.html#a38afdb344a0ffc14fd74026903b48399">XCANPS_IDR_IDE_SHIFT</a>) &amp; <a class="code" href="xcanps__hw_8h.html#ae6a7ad9f02cb2b57195783ced2dff986">XCANPS_IDR_IDE_MASK</a>) |      \
 (((ExtendedId) &lt;&lt; <a class="code" href="xcanps__hw_8h.html#af1f453f117b64787f8b2707e2e9ac510">XCANPS_IDR_ID2_SHIFT</a>) &amp; <a class="code" href="xcanps__hw_8h.html#a23de74a7d58119de9d629f830c28aa53">XCANPS_IDR_ID2_MASK</a>) |       \
 ((RemoteTransReq) &amp; <a class="code" href="xcanps__hw_8h.html#af7c18bde3aed08f7411934f977145cc8">XCANPS_IDR_RTR_MASK</a>))
</pre></div><p>This macro calculates CAN message identifier value given identifier field values.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>StandardId</em>&nbsp;</td><td>contains Standard Message ID value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SubRemoteTransReq</em>&nbsp;</td><td>contains Substitute Remote Transmission Request value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IdExtension</em>&nbsp;</td><td>contains Identifier Extension value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ExtendedId</em>&nbsp;</td><td>contains Extended Message ID value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RemoteTransReq</em>&nbsp;</td><td>contains Remote Transmission Request value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Message Identifier value.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: u32 XCanPs_CreateIdValue(u32 StandardId, u32 SubRemoteTransReq, u32 IdExtension, u32 ExtendedId, u32 RemoteTransReq);</dd></dl>
<p>Read the CAN specification for meaning of each parameter. </p>

</div>
</div>
<a class="anchor" id="a71176de5a3984478078d46c61727518b"></a><!-- doxytag: member="xcanps.h::XCANPS_H" ref="a71176de5a3984478078d46c61727518b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_H</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a60962a646bcd90fd768f78ff34f17ba5"></a><!-- doxytag: member="xcanps.h::XCANPS_HANDLER_ERROR" ref="a60962a646bcd90fd768f78ff34f17ba5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_HANDLER_ERROR&nbsp;&nbsp;&nbsp;3</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler type for error interrupt </p>

</div>
</div>
<a class="anchor" id="ad64733c5ddd21a972fc93a8d43f52d74"></a><!-- doxytag: member="xcanps.h::XCANPS_HANDLER_EVENT" ref="ad64733c5ddd21a972fc93a8d43f52d74" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_HANDLER_EVENT&nbsp;&nbsp;&nbsp;4</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler type for all other interrupts </p>

</div>
</div>
<a class="anchor" id="a6393e21002da8517ac35ae9c1be58681"></a><!-- doxytag: member="xcanps.h::XCANPS_HANDLER_RECV" ref="a6393e21002da8517ac35ae9c1be58681" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_HANDLER_RECV&nbsp;&nbsp;&nbsp;2</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler type for frame reception interrupt </p>

</div>
</div>
<a class="anchor" id="afed3df99b6f79d0ff7c39a6a03ec6c90"></a><!-- doxytag: member="xcanps.h::XCANPS_HANDLER_SEND" ref="afed3df99b6f79d0ff7c39a6a03ec6c90" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_HANDLER_SEND&nbsp;&nbsp;&nbsp;1</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Handler type for frame sending interrupt </p>

</div>
</div>
<a class="anchor" id="aecacd08d0192291be2907ddad81602c5"></a><!-- doxytag: member="xcanps.h::XCanPs_IsAcceptFilterBusy" ref="aecacd08d0192291be2907ddad81602c5" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_IsAcceptFilterBusy</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xcanps__hw_8h.html#a6bace9f8a3ecc5df69b5e9611deaa47c">XCanPs_ReadReg</a>(((InstancePtr)-&gt;CanConfig.BaseAddr),   \
                <a class="code" href="xcanps__hw_8h.html#ab03b1427d6741629e7c78dccfa818dff">XCANPS_SR_OFFSET</a>) &amp; <a class="code" href="xcanps__hw_8h.html#a395ca492e1b1699df527987b3d1b5982">XCANPS_SR_ACFBSY_MASK</a>) ? TRUE : FALSE)
</pre></div><p>This macro checks if the CAN device is ready for the driver to change Acceptance Filter Identifier Registers (AFIR) and Acceptance Filter Mask Registers (AFMR).</p>
<p>AFIR and AFMR for a filter are changeable only after the filter is disabled and this routine returns FALSE. The filter can be disabled using the XCanPs_AcceptFilterDisable function.</p>
<p>Use the XCanPs_Accept_* functions for configuring the acceptance filters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the device is busy and NOT ready to accept writes to AFIR and AFMR.</li>
<li>FALSE if the device is ready to accept writes to AFIR and AFMR.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xcanps_8h.html#aecacd08d0192291be2907ddad81602c5">XCanPs_IsAcceptFilterBusy(XCanPs *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a8dc513dd3633b55910d20150ca42bc12"></a><!-- doxytag: member="xcanps.h::XCanPs_IsHighPriorityBufFull" ref="a8dc513dd3633b55910d20150ca42bc12" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_IsHighPriorityBufFull</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xcanps__hw_8h.html#a6bace9f8a3ecc5df69b5e9611deaa47c">XCanPs_ReadReg</a>(((InstancePtr)-&gt;CanConfig.BaseAddr),   \
                <a class="code" href="xcanps__hw_8h.html#ab03b1427d6741629e7c78dccfa818dff">XCANPS_SR_OFFSET</a>) &amp; <a class="code" href="xcanps__hw_8h.html#a1785ab9ad6f36795a567d7503afda2b8">XCANPS_SR_TXBFLL_MASK</a>) ? TRUE : FALSE)
</pre></div><p>This macro checks if the Transmission High Priority Buffer is full.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the TX High Priority Buffer is full.</li>
<li>FALSE if the TX High Priority Buffer is NOT full.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xcanps_8h.html#a8dc513dd3633b55910d20150ca42bc12">XCanPs_IsHighPriorityBufFull(XCanPs *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a50a4bad5973f5a8819541969a226eeff"></a><!-- doxytag: member="xcanps.h::XCanPs_IsRxEmpty" ref="a50a4bad5973f5a8819541969a226eeff" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_IsRxEmpty</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xcanps__hw_8h.html#a6bace9f8a3ecc5df69b5e9611deaa47c">XCanPs_ReadReg</a>(((InstancePtr)-&gt;CanConfig.BaseAddr),   \
                <a class="code" href="xcanps__hw_8h.html#af4dd00135421b512fc9c7eb7ce6b67bc">XCANPS_ISR_OFFSET</a>) &amp; <a class="code" href="xcanps__hw_8h.html#a63bd136fc25bca2796bce56d60a31ea6">XCANPS_IXR_RXNEMP_MASK</a>) ? FALSE : TRUE)
</pre></div><p>This macro checks if the receive FIFO is empty.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if RX FIFO is empty.</li>
<li>FALSE if the RX FIFO is NOT empty.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xcanps_8h.html#a50a4bad5973f5a8819541969a226eeff">XCanPs_IsRxEmpty(XCanPs *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a97803151fa85361cf6f486bc1d278f08"></a><!-- doxytag: member="xcanps.h::XCanPs_IsTxDone" ref="a97803151fa85361cf6f486bc1d278f08" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_IsTxDone</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xcanps__hw_8h.html#a6bace9f8a3ecc5df69b5e9611deaa47c">XCanPs_ReadReg</a>(((InstancePtr)-&gt;CanConfig.BaseAddr),           \
                <a class="code" href="xcanps__hw_8h.html#af4dd00135421b512fc9c7eb7ce6b67bc">XCANPS_ISR_OFFSET</a>) &amp; <a class="code" href="xcanps__hw_8h.html#a5270e4112cfc21e4a7ed8c168f2ccb10">XCANPS_IXR_TXOK_MASK</a>) ? TRUE : FALSE)
</pre></div><p>This macro checks if the transmission is complete.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if the transmission is done.</li>
<li>FALSE if the transmission is not done.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xcanps_8h.html#a97803151fa85361cf6f486bc1d278f08">XCanPs_IsTxDone(XCanPs *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a24933e3b4780683d895a385e7d1b50d7"></a><!-- doxytag: member="xcanps.h::XCanPs_IsTxFifoFull" ref="a24933e3b4780683d895a385e7d1b50d7" args="(InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCanPs_IsTxFifoFull</td>
          <td>(</td>
          <td class="paramtype">InstancePtr&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">((<a class="code" href="xcanps__hw_8h.html#a6bace9f8a3ecc5df69b5e9611deaa47c">XCanPs_ReadReg</a>(((InstancePtr)-&gt;CanConfig.BaseAddr),   \
                <a class="code" href="xcanps__hw_8h.html#ab03b1427d6741629e7c78dccfa818dff">XCANPS_SR_OFFSET</a>) &amp; <a class="code" href="xcanps__hw_8h.html#ad9255c34d0981002d1b06825ba872c53">XCANPS_SR_TXFLL_MASK</a>) ? TRUE : FALSE)
</pre></div><p>This macro checks if the transmission FIFO is full.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>TRUE if TX FIFO is full.</li>
<li>FALSE if the TX FIFO is NOT full.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>C-Style signature: int <a class="el" href="xcanps_8h.html#a24933e3b4780683d895a385e7d1b50d7">XCanPs_IsTxFifoFull(XCanPs *InstancePtr)</a>; </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4f2c00506467b58276539cc1c2333e"></a><!-- doxytag: member="xcanps.h::XCANPS_MODE_CONFIG" ref="a4e4f2c00506467b58276539cc1c2333e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_MODE_CONFIG&nbsp;&nbsp;&nbsp;0x00000001</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Configuration mode </p>

</div>
</div>
<a class="anchor" id="a815748d9ef7547d7fd43f2b729c3108c"></a><!-- doxytag: member="xcanps.h::XCANPS_MODE_LOOPBACK" ref="a815748d9ef7547d7fd43f2b729c3108c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_MODE_LOOPBACK&nbsp;&nbsp;&nbsp;0x00000004</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Loop Back mode </p>

</div>
</div>
<a class="anchor" id="abfbce28099a84db3fb8199371fea2053"></a><!-- doxytag: member="xcanps.h::XCANPS_MODE_NORMAL" ref="abfbce28099a84db3fb8199371fea2053" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_MODE_NORMAL&nbsp;&nbsp;&nbsp;0x00000002</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Normal mode </p>

</div>
</div>
<a class="anchor" id="adedb96174b3c7af5c8b82003f3a269fe"></a><!-- doxytag: member="xcanps.h::XCANPS_MODE_SLEEP" ref="adedb96174b3c7af5c8b82003f3a269fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_MODE_SLEEP&nbsp;&nbsp;&nbsp;0x00000008</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sleep mode </p>

</div>
</div>
<a class="anchor" id="a6f5226ac1abe6816a8a807a1734aa1d2"></a><!-- doxytag: member="xcanps.h::XCANPS_MODE_SNOOP" ref="a6f5226ac1abe6816a8a807a1734aa1d2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define XCANPS_MODE_SNOOP&nbsp;&nbsp;&nbsp;0x00000010</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Snoop mode </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a72002ff7916781152d893abbe71d83a8"></a><!-- doxytag: member="xcanps.h::XCanPs_ErrorHandler" ref="a72002ff7916781152d893abbe71d83a8" args=")(void *CallBackRef, u32 ErrorMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xcanps_8h.html#a72002ff7916781152d893abbe71d83a8">XCanPs_ErrorHandler</a>)(void *CallBackRef, u32 ErrorMask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback type for error interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ErrorMask</em>&nbsp;</td><td>is a bit mask indicating the cause of the error. Its value equals 'OR'ing one or more XCANPS_ESR_* values defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad81f0a8035bff610185b30bec4e012ea"></a><!-- doxytag: member="xcanps.h::XCanPs_EventHandler" ref="ad81f0a8035bff610185b30bec4e012ea" args=")(void *CallBackRef, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xcanps_8h.html#ad81f0a8035bff610185b30bec4e012ea">XCanPs_EventHandler</a>)(void *CallBackRef, u32 Mask)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback type for all kinds of interrupts except sending frame interrupt, receiving frame interrupt, and error interrupt.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is a bit mask indicating the pending interrupts. Its value equals 'OR'ing one or more XCANPS_IXR_* defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a0277ac1de7be22b9de36ef55da1c8d"></a><!-- doxytag: member="xcanps.h::XCanPs_SendRecvHandler" ref="a8a0277ac1de7be22b9de36ef55da1c8d" args=")(void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="xcanps_8h.html#a8a0277ac1de7be22b9de36ef55da1c8d">XCanPs_SendRecvHandler</a>)(void *CallBackRef)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Callback type for frame sending and reception interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a callback reference passed in by the upper layer when setting the callback functions, and passed back to the upper layer when the callback is invoked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1cffdc22b01e4b4d3aad5e556bf96d20"></a><!-- doxytag: member="xcanps.h::XCanPs_AcceptFilterDisable" ref="a1cffdc22b01e4b4d3aad5e556bf96d20" args="(XCanPs *InstancePtr, u32 FilterIndexes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_AcceptFilterDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>FilterIndexes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine disables individual acceptance filters. Up to 4 filters could be disabled. If all acceptance filters are disabled then all the received frames are stored in the RX FIFO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FilterIndexes</em>&nbsp;</td><td>specifies which filter(s) to disable. Use any XCANPS_AFR_UAF*_MASK to disable one filter, and "Or" multiple XCANPS_AFR_UAF*_MASK values if multiple filters need to be disabled. Any filter not specified in this parameter will keep its previous enable/disable setting. If all acceptance filters are disabled then all received frames are stored in the RX FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ec6f79564deff77e496120552004ad8"></a><!-- doxytag: member="xcanps.h::XCanPs_AcceptFilterEnable" ref="a1ec6f79564deff77e496120552004ad8" args="(XCanPs *InstancePtr, u32 FilterIndexes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_AcceptFilterEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>FilterIndexes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine enables individual acceptance filters. Up to 4 filters could be enabled.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FilterIndexes</em>&nbsp;</td><td>specifies which filter(s) to enable. Use any XCANPS_AFR_UAF*_MASK to enable one filter, and "Or" multiple XCANPS_AFR_UAF*_MASK values if multiple filters need to be enabled. Any filter not specified in this parameter will keep its previous enable/disable setting.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="af2ac50558c7d926fed54329667d4aaca"></a><!-- doxytag: member="xcanps.h::XCanPs_AcceptFilterGet" ref="af2ac50558c7d926fed54329667d4aaca" args="(XCanPs *InstancePtr, u32 FilterIndex, u32 *MaskValue, u32 *IdValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_AcceptFilterGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>FilterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>MaskValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>IdValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads the values of the Acceptance Filter Mask and ID Register for the specified Acceptance Filter. Use XCANPS_IDR_* defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to interpret the values. Read the <a class="el" href="xcanps_8h.html">xcanps.h</a> file and device specification for details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FilterIndex</em>&nbsp;</td><td>defines which Acceptance Filter Mask Register to get Mask and ID from. Use any single XCANPS_FILTER_* value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MaskValue</em>&nbsp;</td><td>is a pointer to the data in which the Mask value read from the chosen Acceptance Filter Mask Register is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IdValue</em>&nbsp;</td><td>is a pointer to the data in which the ID value read from the chosen Acceptance Filter ID Register is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a52a76621e921b66e70e1bed7a58b72f7"></a><!-- doxytag: member="xcanps.h::XCanPs_AcceptFilterGetEnabled" ref="a52a76621e921b66e70e1bed7a58b72f7" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XCanPs_AcceptFilterGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns enabled acceptance filters. Use XCANPS_AFR_UAF*_MASK defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to interpret the returned value. If no acceptance filters are enabled then all received frames are stored in the RX FIFO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value stored in Acceptance Filter Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b2ca95fd3ac7ff0955e61cc2b681b4f"></a><!-- doxytag: member="xcanps.h::XCanPs_AcceptFilterSet" ref="a2b2ca95fd3ac7ff0955e61cc2b681b4f" args="(XCanPs *InstancePtr, u32 FilterIndex, u32 MaskValue, u32 IdValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_AcceptFilterSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>FilterIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>MaskValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>IdValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sets values to the Acceptance Filter Mask Register (AFMR) and Acceptance Filter ID Register (AFIR) for the specified Acceptance Filter. Use XCANPS_IDR_* defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to create the values to set the filter. Read the <a class="el" href="xcanps_8h.html">xcanps.h</a> file and device specification for details.</p>
<p>This function should be called only after:</p>
<ul>
<li>The given filter is disabled by calling <a class="el" href="xcanps_8c.html#a1cffdc22b01e4b4d3aad5e556bf96d20">XCanPs_AcceptFilterDisable()</a>;</li>
<li>And the CAN device is ready to accept writes to AFMR and AFIR, i.e., <a class="el" href="xcanps_8h.html#aecacd08d0192291be2907ddad81602c5">XCanPs_IsAcceptFilterBusy()</a> returns FALSE.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FilterIndex</em>&nbsp;</td><td>defines which Acceptance Filter Mask and ID Register to set. Use any single XCANPS_AFR_UAF*_MASK value. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>MaskValue</em>&nbsp;</td><td>is the value to write to the chosen Acceptance Filter Mask Register. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IdValue</em>&nbsp;</td><td>is the value to write to the chosen Acceptance Filter ID Register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the values were set successfully.</li>
<li>XST_FAILURE if the given filter was not disabled, or the CAN device was not ready to accept writes to AFMR and AFIR.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a366349f6ab06338bec32ba61263612ed"></a><!-- doxytag: member="xcanps.h::XCanPs_CfgInitialize" ref="a366349f6ab06338bec32ba61263612ed" args="(XCanPs *InstancePtr, XCanPs_Config *ConfigPtr, u32 EffectiveAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_CfgInitialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps___config.html">XCanPs_Config</a> *&nbsp;</td>
          <td class="paramname"> <em>ConfigPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>EffectiveAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a616ac01563ef3d8f9ae57bf308bad534"></a><!-- doxytag: member="xcanps.h::XCanPs_ClearBusErrorStatus" ref="a616ac01563ef3d8f9ae57bf308bad534" args="(XCanPs *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_ClearBusErrorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears Error Status bit(s) previously set in Error Status Register (ESR). Use the XCANPS_ESR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to create the value to pass in. If a bit was cleared in Error Status Register before this function is called, it will not be modified.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is he 32-bit mask used to clear bits in Error Status Register. Multiple XCANPS_ESR_* values can be 'OR'ed to clear multiple bits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a32b11e15d347ecae566778bb1c5e33"></a><!-- doxytag: member="xcanps.h::XCanPs_EnterMode" ref="a5a32b11e15d347ecae566778bb1c5e33" args="(XCanPs *InstancePtr, u8 OperationMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_EnterMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>OperationMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function allows the CAN device to enter one of the following operation modes:</p>
<ul>
<li>Configuration Mode: Pass in parameter XCANPS_MODE_CONFIG</li>
<li>Sleep Mode: Pass in parameter XCANPS_MODE_SLEEP</li>
<li>Normal Mode: Pass in parameter XCANPS_MODE_NORMAL</li>
<li>Loop Back Mode: Pass in parameter XCANPS_MODE_LOOPBACK.</li>
<li>Snoop Mode: Pass in parameter XCANPS_MODE_SNOOP.</li>
</ul>
<p>Read the <a class="el" href="xcanps_8h.html">xcanps.h</a> file and device specification for detailed description of each operation mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>OperationMode</em>&nbsp;</td><td>specify which operation mode to enter. Valid value is any of XCANPS_MODE_* defined in <a class="el" href="xcanps_8h.html">xcanps.h</a>. Multiple modes can not be entered at the same time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>This function does NOT ensure CAN device enters the specified operation mode before it returns the control to the caller. The caller is responsible for checking current operation mode using <a class="el" href="xcanps_8c.html#a3644ad3aa2b02def735751ed45d207a4">XCanPs_GetMode()</a>. </p>

</div>
</div>
<a class="anchor" id="ae452283471584ad19f0c854a782640ab"></a><!-- doxytag: member="xcanps.h::XCanPs_GetBaudRatePrescaler" ref="ae452283471584ad19f0c854a782640ab" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XCanPs_GetBaudRatePrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine gets Baud Rate Prescaler value. The system clock for the CAN controller is divided by (Prescaler + 1) to generate the quantum clock needed for sampling and synchronization. Read the device specification for details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Current used Baud Rate Prescaler value. The value's range is from 0 to 255.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aecaff4cbadbea1a01f570a7e6917a027"></a><!-- doxytag: member="xcanps.h::XCanPs_GetBitTiming" ref="aecaff4cbadbea1a01f570a7e6917a027" args="(XCanPs *InstancePtr, u8 *SyncJumpWidth, u8 *TimeSegment2, u8 *TimeSegment1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_GetBitTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>SyncJumpWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TimeSegment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TimeSegment1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine gets Bit time. Time segment 1, Time segment 2 and Synchronization Jump Width values are read in this function. According to device specification, the actual value of each of these fields is one more than the value read. Read the device specification for details.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SyncJumpWidth</em>&nbsp;</td><td>will store the Synchronization Jump Width value after this function returns. Its value ranges from 0 to 3. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeSegment2</em>&nbsp;</td><td>will store the Time Segment 2 value after this function returns. Its value ranges from 0 to 7. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeSegment1</em>&nbsp;</td><td>will store the Time Segment 1 value after this function returns. Its value ranges from 0 to 15.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf35feac1fbc0df4029ca4e1150c650"></a><!-- doxytag: member="xcanps.h::XCanPs_GetBusErrorCounter" ref="aecf35feac1fbc0df4029ca4e1150c650" args="(XCanPs *InstancePtr, u8 *RxErrorCount, u8 *TxErrorCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_GetBusErrorCounter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>RxErrorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8 *&nbsp;</td>
          <td class="paramname"> <em>TxErrorCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads Receive and Transmit error counters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>RxErrorCount</em>&nbsp;</td><td>is a pointer to data in which the Receive Error counter value is returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TxErrorCount</em>&nbsp;</td><td>is a pointer to data in which the Transmit Error counter value is returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a647e39edd3f7247a5e283e9083d8d285"></a><!-- doxytag: member="xcanps.h::XCanPs_GetBusErrorStatus" ref="a647e39edd3f7247a5e283e9083d8d285" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XCanPs_GetBusErrorStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function reads Error Status value from Error Status Register (ESR). Use the XCANPS_ESR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 32-bit value read from Error Status Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a3644ad3aa2b02def735751ed45d207a4"></a><!-- doxytag: member="xcanps.h::XCanPs_GetMode" ref="a3644ad3aa2b02def735751ed45d207a4" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XCanPs_GetMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine returns the current operation mode of the CAN device.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XCANPS_MODE_CONFIG if the device is in Configuration Mode.</li>
<li>XCANPS_MODE_SLEEP if the device is in Sleep Mode.</li>
<li>XCANPS_MODE_NORMAL if the device is in Normal Mode.</li>
<li>XCANPS_MODE_LOOPBACK if the device is in Loop Back Mode.</li>
<li>XCANPS_MODE_SNOOP if the device is in Snoop Mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="adc59b9185cd5973cb03ea2bae94b70cb"></a><!-- doxytag: member="xcanps.h::XCanPs_GetRxIntrWatermark" ref="adc59b9185cd5973cb03ea2bae94b70cb" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 XCanPs_GetRxIntrWatermark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine gets the Rx Full threshold from the Watermark Interrupt Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The Rx FIFO full watermark threshold value. The valid values are 1 to 63.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d87194a88956cbe32f48ea3d25697ef"></a><!-- doxytag: member="xcanps.h::XCanPs_GetStatus" ref="a6d87194a88956cbe32f48ea3d25697ef" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XCanPs_GetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function returns Status value from Status Register (SR). Use the XCANPS_SR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The 32-bit value read from Status Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ae573e5472755420a3b6ded5d01814534"></a><!-- doxytag: member="xcanps.h::XCanPs_IntrClear" ref="ae573e5472755420a3b6ded5d01814534" args="(XCanPs *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_IntrClear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function clears interrupt(s). Every bit set in Interrupt Status Register indicates that a specific type of interrupt is occurring, and this function clears one or more interrupts by writing a bit mask to Interrupt Clear Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to clear. Bit positions of 1 will be cleared. Bit positions of 0 will not change the previous interrupt status. This mask is formed by OR'ing XCANPS_IXR_* bits defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a6228ea25a1ccf31608231b07f3ae54a7"></a><!-- doxytag: member="xcanps.h::XCanPs_IntrDisable" ref="a6228ea25a1ccf31608231b07f3ae54a7" args="(XCanPs *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_IntrDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine disables interrupt(s). Use the XCANPS_IXR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to create the bit-mask to disable interrupt(s).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to disable. Bit positions of 1 will be disabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XCANPS_IXR_* bits defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a06e4eda1022a81ea619ac7d66e345577"></a><!-- doxytag: member="xcanps.h::XCanPs_IntrEnable" ref="a06e4eda1022a81ea619ac7d66e345577" args="(XCanPs *InstancePtr, u32 Mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_IntrEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>Mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine enables interrupt(s). Use the XCANPS_IXR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to create the bit-mask to enable interrupts.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>is the mask to enable. Bit positions of 1 will be enabled. Bit positions of 0 will keep the previous setting. This mask is formed by OR'ing XCANPS_IXR_* bits defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3325adebecffcb97cb01ff3c75391b0"></a><!-- doxytag: member="xcanps.h::XCanPs_IntrGetEnabled" ref="ac3325adebecffcb97cb01ff3c75391b0" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XCanPs_IntrGetEnabled </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine returns enabled interrupt(s). Use the XCANPS_IXR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Enabled interrupt(s) in a 32-bit format.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6640f1ea5f9e4027d67af3b4eec4623"></a><!-- doxytag: member="xcanps.h::XCanPs_IntrGetStatus" ref="ac6640f1ea5f9e4027d67af3b4eec4623" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u32 XCanPs_IntrGetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine returns interrupt status read from Interrupt Status Register. Use the XCANPS_IXR_* constants defined in <a class="el" href="xcanps__hw_8h.html">xcanps_hw.h</a> to interpret the returned value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value stored in Interrupt Status Register.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c797dfe9aef613d20c2a822ed301dc"></a><!-- doxytag: member="xcanps.h::XCanPs_IntrHandler" ref="ad7c797dfe9aef613d20c2a822ed301dc" args="(void *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_IntrHandler </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine is the interrupt handler for the CAN driver.</p>
<p>This handler reads the interrupt status from the ISR, determines the source of the interrupts, calls according callbacks, and finally clears the interrupts.</p>
<p>Application beyond this driver is responsible for providing callbacks to handle interrupts and installing the callbacks using <a class="el" href="xcanps_8h.html#aeb1da97683c78ca3efd6690a0a2b3060">XCanPs_SetHandler()</a> during initialization phase. An example delivered with this driver demonstrates how this could be done.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance that just interrupted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aaccd26e8072c612cd44a0b6645813581"></a><!-- doxytag: member="xcanps.h::XCanPs_LookupConfig" ref="aaccd26e8072c612cd44a0b6645813581" args="(u16 DeviceId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_x_can_ps___config.html">XCanPs_Config</a>* XCanPs_LookupConfig </td>
          <td>(</td>
          <td class="paramtype">u16&nbsp;</td>
          <td class="paramname"> <em>DeviceId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function looks for the device configuration based on the unique device ID. The table XCanPs_ConfigTable[] contains the configuration information for each device in the system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device being looked up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the configuration table entry corresponding to the given device ID, or NULL if no match is found.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a806105ce9bacbf450b3d2bcb4b0af4fb"></a><!-- doxytag: member="xcanps.h::XCanPs_Recv" ref="a806105ce9bacbf450b3d2bcb4b0af4fb" args="(XCanPs *InstancePtr, u32 *FramePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_Recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>FramePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function receives a CAN Frame. This function first checks if RX FIFO is empty, if not, it then reads a frame from the RX FIFO into the given buffer. This function returns error code immediately if there is no frame in the RX FIFO.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FramePtr</em>&nbsp;</td><td>is a pointer to a 32-bit aligned buffer where the CAN frame to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if RX FIFO was not empty and a frame was read from RX FIFO successfully and written into the given buffer.</li>
<li>XST_NO_DATA if there is no frame to be received from the FIFO.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a13dce9f4dede25f041852b1c893ebfba"></a><!-- doxytag: member="xcanps.h::XCanPs_Reset" ref="a13dce9f4dede25f041852b1c893ebfba" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XCanPs_Reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function resets the CAN device. Calling this function resets the device immediately, and any pending transmission or reception is terminated at once. Both Object Layer and Transfer Layer are reset. This function does not reset the Physical Layer. All registers are reset to the default values, and no previous status will be restored. TX FIFO, RX FIFO and TX High Priority Buffer are also reset.</p>
<p>When a reset is required due to an internal error, the driver notifies the upper layer software of this need through the error status code or interrupts. The upper layer software is responsible for calling this Reset function and then re-configuring the device.</p>
<p>The CAN device will be in Configuration Mode immediately after this function returns.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b41aa40bddd212d039bd7e5171f0cf3"></a><!-- doxytag: member="xcanps.h::XCanPs_SelfTest" ref="a7b41aa40bddd212d039bd7e5171f0cf3" args="(XCanPs *InstancePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_SelfTest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function runs a self-test on the CAN driver/device. The test resets the device, sets up the Loop Back mode, sends a standard frame, receives the frame, verifies the contents, and resets the device again.</p>
<p>Note that this is a destructive test in that resets of the device are performed. Refer the device specification for the device status after the reset operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the self-test passed. i.e., the frame received via the internal loop back has the same contents as the frame sent.</li>
<li>XST_FAILURE Otherwise.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>If the CAN device does not work properly, this function may enter an infinite loop and will never return to the caller. <br/>
<br/>
 If XST_FAILURE is returned, the device is not reset so that the caller could have a chance to check reason(s) causing the failure. </p>

</div>
</div>
<a class="anchor" id="a4586901ededc2d25ccf6e931a492e129"></a><!-- doxytag: member="xcanps.h::XCanPs_Send" ref="a4586901ededc2d25ccf6e931a492e129" args="(XCanPs *InstancePtr, u32 *FramePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_Send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>FramePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function sends a CAN Frame. If the TX FIFO is not full then the given frame is written into the the TX FIFO otherwise, it returns an error code immediately. This function does not wait for the given frame being sent to CAN bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FramePtr</em>&nbsp;</td><td>is a pointer to a 32-bit aligned buffer containing the CAN frame to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if TX FIFO was not full and the given frame was written into the FIFO.</li>
<li>XST_FIFO_NO_ROOM if there is no room in the TX FIFO for the given frame.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ab621053a5cb10c664b4994f231b33596"></a><!-- doxytag: member="xcanps.h::XCanPs_SendHighPriority" ref="ab621053a5cb10c664b4994f231b33596" args="(XCanPs *InstancePtr, u32 *FramePtr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_SendHighPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32 *&nbsp;</td>
          <td class="paramname"> <em>FramePtr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine sends a CAN High Priority frame. This function first checks if TX High Priority Buffer is empty. If yes, it then writes the given frame into the Buffer. If not, this function returns immediately. This function does not wait for the given frame being sent to CAN bus.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>FramePtr</em>&nbsp;</td><td>is a pointer to a 32-bit aligned buffer containing the CAN High Priority frame to be sent.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if TX High Priority Buffer was not full and the given frame was written into the buffer;</li>
<li>XST_FIFO_NO_ROOM if there is no room in the TX High Priority Buffer for this frame.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd></dd></dl>
<p>If the frame needs to be sent immediately and not delayed by processor's interrupt handling, the caller should disable interrupt at processor level before invoking this function. </p>

</div>
</div>
<a class="anchor" id="a4036939c0c1112d137aaae9e5181c22c"></a><!-- doxytag: member="xcanps.h::XCanPs_SetBaudRatePrescaler" ref="a4036939c0c1112d137aaae9e5181c22c" args="(XCanPs *InstancePtr, u8 Prescaler)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_SetBaudRatePrescaler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Prescaler</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine sets Baud Rate Prescaler value. The system clock for the CAN controller is divided by (Prescaler + 1) to generate the quantum clock needed for sampling and synchronization. Read the device specification for details.</p>
<p>Baud Rate Prescaler can be set only if the CAN device is in Configuration Mode. Call <a class="el" href="xcanps_8c.html#a5a32b11e15d347ecae566778bb1c5e33">XCanPs_EnterMode()</a> to enter Configuration Mode before using this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Prescaler</em>&nbsp;</td><td>is the value to set. Valid values are from 0 to 255.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the Baud Rate Prescaler value is set successfully.</li>
<li>XST_FAILURE if CAN device is not in Configuration Mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="a8829d144510518e4f8e7f9e65fe37ad3"></a><!-- doxytag: member="xcanps.h::XCanPs_SetBitTiming" ref="a8829d144510518e4f8e7f9e65fe37ad3" args="(XCanPs *InstancePtr, u8 SyncJumpWidth, u8 TimeSegment2, u8 TimeSegment1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_SetBitTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>SyncJumpWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimeSegment2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>TimeSegment1</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine sets Bit time. Time segment 1, Time segment 2 and Synchronization Jump Width are set in this function. Device specification requires the values passed into this function be one less than the actual values of these fields. Read the device specification for details.</p>
<p>Bit time can be set only if the CAN device is in Configuration Mode. Call <a class="el" href="xcanps_8c.html#a5a32b11e15d347ecae566778bb1c5e33">XCanPs_EnterMode()</a> to enter Configuration Mode before using this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SyncJumpWidth</em>&nbsp;</td><td>is the Synchronization Jump Width value to set. Valid values are from 0 to 3. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeSegment2</em>&nbsp;</td><td>is the Time Segment 2 value to set. Valid values are from 0 to 7. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TimeSegment1</em>&nbsp;</td><td>is the Time Segment 1 value to set. Valid values are from 0 to 15.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS if the Bit time is set successfully.</li>
<li>XST_FAILURE if CAN device is not in Configuration Mode.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="aeb1da97683c78ca3efd6690a0a2b3060"></a><!-- doxytag: member="xcanps.h::XCanPs_SetHandler" ref="aeb1da97683c78ca3efd6690a0a2b3060" args="(XCanPs *InstancePtr, u32 HandlerType, void *CallBackFunc, void *CallBackRef)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_SetHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32&nbsp;</td>
          <td class="paramname"> <em>HandlerType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>CallBackRef</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine installs an asynchronous callback function for the given HandlerType:</p>
<pre>
 HandlerType			Callback Function Type
 -----------------------	------------------------
 XCANPS_HANDLER_SEND		XCanPs_SendRecvHandler
 XCANPS_HANDLER_RECV		XCanPs_SendRecvHandler
 XCANPS_HANDLER_ERROR		XCanPs_ErrorHandler
 XCANPS_HANDLER_EVENT		XCanPs_EventHandler</pre><pre> HandlerType			Invoked by this driver when:
 -------------------------------------------------------------------------
 XCANPS_HANDLER_SEND		A frame transmitted by a call to
				<a class="el" href="xcanps_8c.html#a4586901ededc2d25ccf6e931a492e129">XCanPs_Send()</a> has been sent successfully.</pre><pre> XCANPS_HANDLER_RECV		A frame(s) has been received and is sitting in
				the RX FIFO.</pre><pre> XCANPS_HANDLER_ERROR		An error interrupt is occurring.</pre><pre> XCANPS_HANDLER_EVENT		Any other kind of interrupt is occurring.
 </pre><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HandlerType</em>&nbsp;</td><td>specifies which handler is to be attached. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackFunc</em>&nbsp;</td><td>is the address of the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CallBackRef</em>&nbsp;</td><td>is a user data item that will be passed to the callback function when it is invoked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_SUCCESS when handler is installed.</li>
<li>XST_INVALID_PARAM when HandlerType is invalid.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Invoking this function for a handler that already has been installed replaces it with the new handler. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c8048df67199eafe40346c33babf236"></a><!-- doxytag: member="xcanps.h::XCanPs_SetRxIntrWatermark" ref="a3c8048df67199eafe40346c33babf236" args="(XCanPs *InstancePtr, u8 Threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int XCanPs_SetRxIntrWatermark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_x_can_ps.html">XCanPs</a> *&nbsp;</td>
          <td class="paramname"> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>Threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This routine sets the Rx Full threshold in the Watermark Interrupt Register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>is a pointer to the <a class="el" href="struct_x_can_ps.html">XCanPs</a> instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Threshold</em>&nbsp;</td><td>is the threshold to be set. The valid values are from 1 to 63.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><ul>
<li>XST_FAILURE - If the CAN device is not in Configuration Mode.</li>
<li>XST_SUCCESS - If the Rx Full threshold is set in Watermark Interrupt Register.</li>
</ul>
</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The threshold can only be set when the CAN device is in the configuration mode. </dd></dl>

</div>
</div>
</div>
<p class="Copyright">
Copyright &copy; 1995-2014 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>
